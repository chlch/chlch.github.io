---
title: Java线程基础
date: 2019-03-18 10:11:45
tags: [Java, Thread, 基础]
category: Java线程
description: Java线程定义、创建、状态、各状态转换
---

## 定义
> A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.

一条线程指的是一个程序（进程）中执行的控制流，Java虚拟机允许一个应用程序并发执行多个线程。
每一个线程都有一个优先级，优先级高的比低的先执行。每一个线程都有可能标记为守护线程，守护线程随主线程退出而退出。在线程中新建的线程与它创建时所在的线程有着同样的优先级，线程A中创建了一个线程B，那么B优先级等价于A，如果A是守护线程，那么B也是。
## 线程状态
> A thread can be in one of the following states:
 RUNNABLE: A thread executing in the Java virtual machine is in this state.
  BLOCKED: A thread that is blocked waiting for a monitor lock is in this state.
  WAITING: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.
TIMED_WAITING: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.
TERMINATED: A thread that has exited is in this state.
A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.

这里面比较重要的就是阻塞和等待状态，当等待一个监视器锁的时候线程是处于阻塞状态的。下面是一个打印线程A状态的代码
```
public class TestThread {
	final Object lock = new Object();

	public static void main(String[] args) throws InterruptedException {
		TestThread t = new TestThread();
		Thread b = new Thread(t.new ThreadB(), "B");
		b.start();
		ThreadA a = t.new ThreadA();
		a.setName("A");
		System.out.println(a.getState());  //NEW
		a.start();
		System.out.println(a.getState()); //RUNNABLE
		Thread.sleep(1000);
		System.out.println(a.getState()); //BLOCKED
		
	}

	class ThreadB implements Runnable {

		public void run() {
			synchronized (lock) {
				  System.out.println(Thread.currentThread().getName() + " invoke");
				try {
					Thread.sleep(150000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}

	}
	class ThreadA extends Thread {
		public void run() {
			synchronized (lock) {
				System.out.println(Thread.currentThread().getName() + " invoke");
				try {
					Thread.sleep(1500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				try {
					Thread.sleep(200);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}

	}
}
```
处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。处于等待状态的线程会等待另外一个线程处理特殊的行为。 
有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间

## 线程创建
上面代码块的两个线程创建的方式就是不同的，两者最大区别的区别就是一个继承Thread，一个实现Runnable接口，Thread类本身也实现了Runnable接口，Java中没有多继承，所以能实现接口就实现接口，除非当你的线程需要Thread类中除了run方法以外的其它方法时，可以采用继承的方式创建。
## 线程中断
当线程对象调用interrupt()方法时中断，为线程设置一个中断标志。
需要用isInterrupted()时刻判断线程中断的条件。
当线程处于阻塞等待状态时中断，会抛出InterruptedException异常。
