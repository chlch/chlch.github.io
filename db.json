{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/googledef28c5c0d972669.html","hash":"6446ecf1851313a99b4163434a19dee862870361","modified":1564653212577},{"_id":"source/2019-04-11-MordernOS（一）.md","hash":"d10a899b8e657633c2018d848f75e3ebb57088b1","modified":1555395333566},{"_id":"source/favicon.ico","hash":"d92fc1e1f9a3ad203cf2e16380635fae1d3feff7","modified":1554197609222},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1551673868822},{"_id":"themes/maupassant/.gitignore","hash":"d7d27e5a9bcffe7f90dc2f4f0752e19020e40f40","modified":1551673868820},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1551673868823},{"_id":"themes/maupassant/_config.yml","hash":"0da45929efd08c4ccdcd3965b2672b41991834f3","modified":1565334832995},{"_id":"themes/maupassant/README.md","hash":"1c8631bc25c0f616e2dbd01c7fc224fa19eefdf3","modified":1551673868826},{"_id":"themes/maupassant/package.json","hash":"5328c4c435cd4a5fe47caae31b9975013cdca5bb","modified":1551673868877},{"_id":"source/_posts/2019-03-04-The-Internet-and-IP------todo.md","hash":"aed371e795d80d691625c0d6c59eb68528cdacb5","modified":1563435094978},{"_id":"source/_posts/2019-03-14-BST系列（一）.md","hash":"97437ea4af9ce94d661c485a4999ce08456da98a","modified":1552555397523},{"_id":"source/_posts/2019-03-18-Java线程基础.md","hash":"4d2b6ff89cb2e08e819598b42be249e47acaf1e0","modified":1565765717503},{"_id":"source/_posts/2019-03-15-BST系列（二）.md","hash":"49059b2237dca02c58c97b3030eebb63943aa1dc","modified":1552875063546},{"_id":"source/_posts/2019-03-19-BST系列（三）.md","hash":"c9bbea7c3b85c0143a1e470a068f910b8f9ca5ec","modified":1553064755580},{"_id":"source/_posts/2019-03-20-BST系列（四）.md","hash":"1b21d57a290ce605b1b73b0806bbb1cd5a341eed","modified":1553481148337},{"_id":"source/_posts/2019-03-25-BST系列（五）.md","hash":"f5dc93c853d46a930fd6269b3995437da6463990","modified":1553487219800},{"_id":"source/_posts/2019-04-01-Heap系列（二）.md","hash":"c231ce19d54d4e87f1b8deb0a65be0cbdda14de7","modified":1554195680296},{"_id":"source/_posts/2019-03-28-Heap系列（一）.md","hash":"2a5dfff58ff40c346fd1aa10ece011ce882117b3","modified":1553875683189},{"_id":"source/_posts/2019-04-02-jsTest----todo.md","hash":"54c67348cf823691d0f4ddfce6e65b597c575f31","modified":1563435090192},{"_id":"source/_posts/2019-07-09-LeetCode-HashTable系列（一）.md","hash":"1fe716916fce16cd44050894a5c292dc292b697e","modified":1562908203721},{"_id":"source/_posts/2019-06-27-JVM-Run-Time-Data-Area.md","hash":"45b191ea7e9779c0e4ea4b723f0b80a23eff7ab6","modified":1562212248826},{"_id":"source/_posts/2019-07-15-Leetcode-HashTaable系列（二）.md","hash":"54ec5e035852529826572b953d8b68704b95562c","modified":1564652343186},{"_id":"source/_posts/2019-08-01-LeetCode-Stack系列（一）.md","hash":"e357808c2a96b574efb6b35275be622d6aef1e31","modified":1564652333893},{"_id":"source/_posts/2019-08-05-移动端Video标签踩坑记录.md","hash":"ef9af9324dcea78f5d0d2880b115a8f004790c83","modified":1564974967682},{"_id":"source/_posts/2019-08-13-LeetCode-Sort系列（一）.md","hash":"705ee86b659c3263566f9ce762052e7f6c496652","modified":1565770461909},{"_id":"source/_posts/2019-08-09-CodingBat-递归练习题解.md","hash":"1442e0fb3e60bcd0ba10c98fd4b1b26aeef1a567","modified":1565333084939},{"_id":"source/_posts/interview.md","hash":"e56997ce1ad7223c1b3a9a345691f68800cf0a87","modified":1553487027507},{"_id":"source/about/index.md","hash":"882251dfa94cafd921f8b9da42b85b54abcdc39f","modified":1564971129839},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1551673863879},{"_id":"themes/maupassant/.git/config","hash":"3dbf80769093e21ccab51f5f2b02a6d764498803","modified":1551673868784},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1551673868752},{"_id":"themes/maupassant/.git/index","hash":"de8e6d2e5b8b6967986ddc9253e1cc169f5cedf9","modified":1564626646139},{"_id":"themes/maupassant/.git/packed-refs","hash":"5f510c2b61b71e001996507330f87979e3f484da","modified":1551673868735},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1551673868830},{"_id":"themes/maupassant/languages/en.yml","hash":"518beaa8538a772ca697122264d667059797e458","modified":1551673868832},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1551673868834},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1551673868836},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1551673868835},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"34dba7ac67aeb316f629ca73e546fa143cc362d5","modified":1551673868840},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"a1a9888b6cd0fd3dc45ffed3490f4ca8ce1abfd7","modified":1551673868839},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1551673868838},{"_id":"themes/maupassant/layout/archive.pug","hash":"05f751cb766616ff96ff22ad0790d9cd28777270","modified":1551673868868},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"b0a0ec63ee0225eaa0996d72164202bc9a28a225","modified":1551673868869},{"_id":"themes/maupassant/layout/base.pug","hash":"7451a590db6943edc099dc0e13b317c38686e8fc","modified":1551673868870},{"_id":"themes/maupassant/layout/page.pug","hash":"a21e638d5459120d88e45e8f18a23dc072d9ca07","modified":1551673868872},{"_id":"themes/maupassant/layout/index.pug","hash":"d1d56fa62f1293cd0cbefe96dbbde2d35b557a0a","modified":1551673868871},{"_id":"themes/maupassant/layout/post.pug","hash":"b112011fbb6a32b33e341be7edf043bc4ad5f97e","modified":1551673868873},{"_id":"themes/maupassant/layout/single-column.pug","hash":"8b4b731cdf86379d526821a1fa950bf15ed61f15","modified":1551673868874},{"_id":"themes/maupassant/layout/timeline.pug","hash":"04f7efdc45acda1faff409d0f80fa5a0dd2309d0","modified":1551673868876},{"_id":"source/_posts/2019-03-19-BST系列（三）/1.png","hash":"14334dccebdd33b2ec4d138d1b0b305b1ace9f81","modified":1552963936831},{"_id":"source/_posts/2019-04-02-jsTest/a.js","hash":"30711a61f42d2c8be9951d8c872a27aceef1fa97","modified":1562908836234},{"_id":"source/_posts/2019-06-27-JVM-Run-Time-Data-Area/JVM-Run-time-Data-Areas.png","hash":"5bc8ad054ac581beda491a455309cfe161ec86af","modified":1561617019578},{"_id":"source/_posts/2019-06-27-JVM-Run-Time-Data-Area/heap.gif","hash":"3b2a2b1cba8344b652d73c71cdb117acead59c5a","modified":1562211770392},{"_id":"source/_posts/2019-08-05-移动端Video标签踩坑记录/ios-blank-video.png","hash":"bb79aafd8b75e6f09c3ed4e6b82b788638af2cd6","modified":1564972940824},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1551673863894},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1551673863879},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1551673863894},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1551673863894},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"1dd7382938c5b9b4574ccc93f038b11e201846e6","modified":1551673868763},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1551673863894},{"_id":"themes/maupassant/source/css/style.scss","hash":"41ba9c8623bd8d78b3fafa0a8abeb94f23e83a15","modified":1565333733190},{"_id":"themes/maupassant/source/donate/index.html","hash":"e6c9cbaf77300787329201cdf1ca663b2ea1bd15","modified":1551673868886},{"_id":"themes/maupassant/source/css/donate.css","hash":"ca39d14a598e1de5c51db4170ceb399c6a7131fe","modified":1551673868882},{"_id":"themes/maupassant/source/css/default.css","hash":"b41d95120f9e64fd4530ae00ceaef09c7ea20818","modified":1551673868880},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1551673868888},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1551673868889},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1551673868891},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1551673868890},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1551673868894},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"eeb2ee8cf44ba5c298baeed84bb90866f4814955","modified":1551673868893},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1551673868895},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"e916dea1c1bba1bc935510310f65b2c9328a401a","modified":1551673868897},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"30418295bed44bcc4b29076eb7deed49cf4d6c1c","modified":1551673868898},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1551673868899},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1551673868901},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1551673868900},{"_id":"themes/maupassant/source/js/search.js","hash":"dbda07a03e6edc73f1dc28a068c24a6037b97b56","modified":1551673868905},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1551673868909},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1551673868861},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"7bc7c17cfd498c3e0c3371cef78f08f1dc25db36","modified":1551673868862},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"68bae3eb2f80e6127e03faa7ee1b78fb2e70aafc","modified":1551673868863},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1551673868864},{"_id":"themes/maupassant/source/js/share.js","hash":"514e726c1efae9f6566600fa0e945b4b9e620f2e","modified":1551673868906},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1551673868907},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1551673868867},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6aa743486f282545f553a4fad6aae037afe26108","modified":1551673868866},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"92aa15e813bfb411803cc54218feb5410469a9c2","modified":1551673868847},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1551673868850},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1551673868851},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1551673868852},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1551673868856},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1551673868855},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1551673868857},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1551673868854},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"6fb1d8ee09cfc4fd31e8ae53736e4f479d45e31e","modified":1551673868858},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"9b4f833039606798f90a85013cbfbc7b735234a2","modified":1551673868844},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"efaf0788b6b70aa03c928137cd13b28afa706f75","modified":1551673868846},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"b3c96f55afaeaeb010daeb96014f911db10c7f99","modified":1551673868848},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"491663a8794038aeea0f679f365d2b616d19d619","modified":1551673868762},{"_id":"themes/maupassant/.git/objects/pack/pack-e8e15ff9bc443d1e9bf28062ffd8c73b9c3658f6.idx","hash":"8e53371a0a227e14b4287efa1efa5739960dd73d","modified":1551673868623},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1551673868904},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"1dd7382938c5b9b4574ccc93f038b11e201846e6","modified":1551673868766},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1551673868749},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"1dd7382938c5b9b4574ccc93f038b11e201846e6","modified":1551673868748},{"_id":"themes/maupassant/.git/objects/pack/pack-e8e15ff9bc443d1e9bf28062ffd8c73b9c3658f6.pack","hash":"5d8197a141c3c5ac2d148560a8f9fe041a3dee30","modified":1551673868630},{"_id":"public/sitemap.xml","hash":"a56641cb0f861bbc402186e9b476418494b96c2a","modified":1565770480269},{"_id":"public/googledef28c5c0d972669.html","hash":"aa73482bcbef49b1f5317a533830a5e818a6ffdf","modified":1565765829581},{"_id":"public/2019-04-11-MordernOS（一）.html","hash":"e58850133a50b789e7682053451e880826c252c4","modified":1565765829583},{"_id":"public/about/index.html","hash":"6f10ef6d7e79c7381288050446871f430b851eb8","modified":1565765829591},{"_id":"public/2019/08/05/移动端Video标签踩坑记录/index.html","hash":"853634f2d01710a82ed97087dbe645746b077fc2","modified":1565765829591},{"_id":"public/2019/06/27/JVM-Run-Time-Data-Area/index.html","hash":"9d1948ae4df24427bcc411fd3819dcfc63502016","modified":1565765829591},{"_id":"public/2019/03/15/BST系列（二）/index.html","hash":"6b651925c4a314b4ca2fbcc89566121b0c0eb753","modified":1565765829591},{"_id":"public/archives/index.html","hash":"b897c4bcf658435b55fb306f54ffccc012d31b9e","modified":1565765829591},{"_id":"public/archives/page/2/index.html","hash":"be91946c52b322263a0175670a4ced227eacae8d","modified":1565765829591},{"_id":"public/archives/2019/index.html","hash":"980754129e5cc3c91be36519c462d97712e2921c","modified":1565765829592},{"_id":"public/archives/2019/03/index.html","hash":"d086298be6c1ca70de67757b6443f104261586b4","modified":1565765829592},{"_id":"public/archives/2019/page/2/index.html","hash":"7eddc25c407f652d0dc20c28be40a684c86cbbbd","modified":1565765829592},{"_id":"public/archives/2019/04/index.html","hash":"d1d36623c1d3d83403639877d83126f4a2d143ce","modified":1565765829592},{"_id":"public/archives/2019/06/index.html","hash":"afdb80487547043f129599c3376eb9719f68a2fb","modified":1565765829592},{"_id":"public/archives/2019/07/index.html","hash":"da74ae12f70d2c7b32e2da520c268983da0f5c12","modified":1565765829592},{"_id":"public/archives/2019/08/index.html","hash":"bd68bc08ef59f87808d7297ad3fa5d778f37f6ed","modified":1565765829593},{"_id":"public/categories/LeetCode/index.html","hash":"eb588fb6f822f9b6b09551c5884b2583f2c25e35","modified":1565765829593},{"_id":"public/categories/算法/index.html","hash":"24d564febaed977510fe43b04ee603819cacf59f","modified":1565765829593},{"_id":"public/categories/前端/index.html","hash":"5c4a5e184f32ad4ed2e88322e450592eb1d30410","modified":1565765829593},{"_id":"public/2019/08/09/CodingBat-递归练习题解/index.html","hash":"faa18788fbf08821814160616f910fa83463372e","modified":1565765829593},{"_id":"public/2019/07/15/Leetcode-HashTaable系列（二）/index.html","hash":"cc3b652b644587327b3cf595c3ad8d87db24d011","modified":1565765829593},{"_id":"public/2019/07/09/LeetCode-HashTable系列（一）/index.html","hash":"2ab05c68902c47149fb22a3fa8fefe96ee5748d3","modified":1565765829594},{"_id":"public/2019/08/01/LeetCode-Stack系列（一）/index.html","hash":"ac5014749d19b1b3849d8e79350581ee0f90d209","modified":1565765829594},{"_id":"public/2019/04/01/Heap系列（二）/index.html","hash":"e0a29b809b99a3a14014740dd7358421f3f04631","modified":1565765829594},{"_id":"public/2019/03/29/Heap系列（一）/index.html","hash":"fc8b5c7f365cb9ecacab9517c5fa11741498eb00","modified":1565765829594},{"_id":"public/2019/03/20/BST系列（三）/index.html","hash":"be89b0247f3c4cd465cf0f3e80e8b4b5ee17e114","modified":1565765829594},{"_id":"public/2019/03/25/BST系列（五）/index.html","hash":"01444add959aaf1af496b7e225bd64441fb3fb66","modified":1565765829595},{"_id":"public/2019/03/20/interview/index.html","hash":"a04fc62bb8acd8d2712ec02ed3889ebc7c9747fc","modified":1565765829595},{"_id":"public/2019/03/14/BST系列（一）/index.html","hash":"de4a9b6857fcdba7255dedbc632d4cf37d1deec6","modified":1565765829595},{"_id":"public/2019/03/18/Java线程基础/index.html","hash":"490c1c58ceb5e37027aeddeb42520598446579fe","modified":1565765829596},{"_id":"public/2019/03/20/BST系列（四）/index.html","hash":"53f9c29347eef2ec0367e25a5eb5f3b4f92f49dc","modified":1565765829596},{"_id":"public/categories/LeetCode/page/2/index.html","hash":"fba87a8ff885ecc7f60c0f06afd01d71462c0829","modified":1565765829615},{"_id":"public/categories/Java/index.html","hash":"10aae57aee9363ce663c8f5715602c3b689986a2","modified":1565765829615},{"_id":"public/categories/面试/index.html","hash":"866e7703c8dcd827d81e2443cfd0ddca44cfcf61","modified":1565765829616},{"_id":"public/categories/JVM/index.html","hash":"e7dffda745f28a48d146d9cf34957b70c15c34ff","modified":1565765829616},{"_id":"public/index.html","hash":"1a6795c41fd9716da0f3ab2a71ac648d6fbe5941","modified":1565770480891},{"_id":"public/page/2/index.html","hash":"4226324f11ee388045cba15c1956f2ce9c566532","modified":1565765829616},{"_id":"public/tags/LeetCode/index.html","hash":"be952d736d5a0d692fd1e67223368729309ae62a","modified":1565765829617},{"_id":"public/tags/BST/index.html","hash":"ed1f316f2f6827d51dbc05124c511caa42154052","modified":1565765829617},{"_id":"public/tags/algorithm/index.html","hash":"95a7c3b70c93a0cbd3845f4a01f05b057ef77159","modified":1565765829617},{"_id":"public/tags/algorithm/page/2/index.html","hash":"7440c5d7088c6e6a2948bb60924ad0c60c6f8e09","modified":1565765829617},{"_id":"public/tags/基础/index.html","hash":"c2d37987f7495780febbd049a649c19ac80b73b2","modified":1565765829619},{"_id":"public/tags/Heap/index.html","hash":"dfcf0d697d54ca46fb8c36be9a4ffe962798c3f5","modified":1565765829619},{"_id":"public/tags/Java/index.html","hash":"354cd47901665a601b852208e176cf4e8e2d1184","modified":1565765829619},{"_id":"public/tags/JVM/index.html","hash":"e7dffda745f28a48d146d9cf34957b70c15c34ff","modified":1565765829619},{"_id":"public/tags/HashTable/index.html","hash":"486e1069317194e08fd3db1dc912561a87db00c6","modified":1565765829619},{"_id":"public/tags/Data-Area/index.html","hash":"ee06adaf66f121f3813fdae2903160c29bb0f68b","modified":1565765829620},{"_id":"public/tags/Stack/index.html","hash":"009bd58fa10cbd5dbeab33beff9289d97f9d36d6","modified":1565765829620},{"_id":"public/tags/Thread/index.html","hash":"1a95b8b39c04bb860f423aaa901b93f13deaf4f5","modified":1565765829620},{"_id":"public/tags/video/index.html","hash":"b6bb4ee52f0c733c68e44f20fedd00fee5892084","modified":1565765829620},{"_id":"public/tags/canvas/index.html","hash":"e7470a152dba6a3d08d0a4697565aef951ad1a89","modified":1565765829620},{"_id":"public/tags/html/index.html","hash":"0254ce7c2e5fbbcf90e5569d8b79cd3c7ec680dd","modified":1565765829620},{"_id":"public/tags/js/index.html","hash":"6399fd7eb453fcab4ade2e8ada071a0ca29eb97d","modified":1565765829621},{"_id":"public/tags/ios/index.html","hash":"4ff8e10ca0feb98ce67d1483dcb5692c0e68b386","modified":1565765829621},{"_id":"public/tags/递归/index.html","hash":"45413b2c0a058f8bb6fc45d63b67ea48c84a4a24","modified":1565765829621},{"_id":"public/tags/CodingBat/index.html","hash":"f9343d013414293de20613cba0169a3d50af7f59","modified":1565765829621},{"_id":"public/tags/面试/index.html","hash":"866e7703c8dcd827d81e2443cfd0ddca44cfcf61","modified":1565765829621},{"_id":"public/tags/Android/index.html","hash":"513a543af1fac36e2cc95d7535c5af79d00f109a","modified":1565765829621},{"_id":"public/tags/前端/index.html","hash":"5c4a5e184f32ad4ed2e88322e450592eb1d30410","modified":1565765829622},{"_id":"public/tags/mobile/index.html","hash":"4c42c972e96dd6a27d09b45bce2063b50c32474c","modified":1565765829622},{"_id":"public/2019/08/13/LeetCode-Sort系列（一）/index.html","hash":"4510eb95016017897c014c99e6fbc743ee6a959d","modified":1565765829622},{"_id":"public/tags/LeetCode/page/2/index.html","hash":"152d0ba4e4fec8407669bfcf1b2fff509c44634e","modified":1565765829625},{"_id":"public/tags/Sort/index.html","hash":"c92690401df2a998a165f5b5cf6b3643ac836dbf","modified":1565765829625}],"Category":[{"name":"LeetCode","_id":"cjzawewny0004i0h69j43bbou"},{"name":"Java线程","_id":"cjzawewot000ki0h655i6qczr"},{"name":"JVM","_id":"cjzawewp2000ti0h6rbjlex58"},{"name":"前端","_id":"cjzawewp90012i0h6ut7raul5"},{"name":"算法","_id":"cjzawewpd0019i0h6s8sbmuoy"},{"name":"面试","_id":"cjzawewph001gi0h6bb8w0th2"},{"name":"Java","_id":"cjzawjnsg00003ch6jy1ehf9s"}],"Data":[],"Page":[{"_content":"google-site-verification: googledef28c5c0d972669.html","source":"googledef28c5c0d972669.html","raw":"google-site-verification: googledef28c5c0d972669.html","date":"2019-08-01T10:15:23.065Z","updated":"2019-08-01T09:53:32.577Z","path":"googledef28c5c0d972669.html","title":"","comments":1,"layout":"page","_id":"cjzawewma0000i0h6vozez7vj","content":"google-site-verification: googledef28c5c0d972669.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: googledef28c5c0d972669.html"},{"title":"Mordern Operate System Intruction Solution（一）","date":"2019-04-11T02:51:50.000Z","tags":["操作系统"],"category":"操作系统","description":"现代操作系统第四版第一章习题作答。","_content":"\n继续开坑系列，弥补计算机基础来了。\n### 1.What are the two main functions of an operating system?\nproviding application programmers (and application programs, naturally) a clean abstract set of resources instead of the messy hardware ones and managing these hardware resources. \n1. 为用户程序提供抽象。——将混乱复杂的硬件接口统一抽象管理方便上层程序使用。\n2. 管理电脑（硬件）资源\n\n### 2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).\n\n1. Mainframe OS(大型机操作系统)\nThe operating systems for mainframes are heavily oriented toward processing\nmany jobs at once, most of which need prodigious amounts of I/O.\n2. Server OS\n3. Multiprocessors OS\n4. personal computer OS （笔记本）\n5. handheld computer OS （手机）\n6. Embedded OS （TV、MP3）\n7. Sensor-Node OS \n8. real-time OS\n9. smart card OS （Java applet）\n\n### 3.What is the difference between timesharing and multiprogramming systems?\n\n\n### 4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?\n","source":"2019-04-11-MordernOS（一）.md","raw":"---\ntitle: Mordern Operate System Intruction Solution（一）\ndate: 2019-04-11 10:51:50\ntags: [操作系统]\ncategory: 操作系统\ndescription: 现代操作系统第四版第一章习题作答。\n---\n\n继续开坑系列，弥补计算机基础来了。\n### 1.What are the two main functions of an operating system?\nproviding application programmers (and application programs, naturally) a clean abstract set of resources instead of the messy hardware ones and managing these hardware resources. \n1. 为用户程序提供抽象。——将混乱复杂的硬件接口统一抽象管理方便上层程序使用。\n2. 管理电脑（硬件）资源\n\n### 2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).\n\n1. Mainframe OS(大型机操作系统)\nThe operating systems for mainframes are heavily oriented toward processing\nmany jobs at once, most of which need prodigious amounts of I/O.\n2. Server OS\n3. Multiprocessors OS\n4. personal computer OS （笔记本）\n5. handheld computer OS （手机）\n6. Embedded OS （TV、MP3）\n7. Sensor-Node OS \n8. real-time OS\n9. smart card OS （Java applet）\n\n### 3.What is the difference between timesharing and multiprogramming systems?\n\n\n### 4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?\n","updated":"2019-04-16T06:15:33.566Z","path":"2019-04-11-MordernOS（一）.html","comments":1,"layout":"page","_id":"cjzawewme0001i0h67viql9qy","content":"<p>继续开坑系列，弥补计算机基础来了。</p>\n<h3 id=\"1-What-are-the-two-main-functions-of-an-operating-system\"><a href=\"#1-What-are-the-two-main-functions-of-an-operating-system\" class=\"headerlink\" title=\"1.What are the two main functions of an operating system?\"></a>1.What are the two main functions of an operating system?</h3><p>providing application programmers (and application programs, naturally) a clean abstract set of resources instead of the messy hardware ones and managing these hardware resources. </p>\n<ol>\n<li>为用户程序提供抽象。——将混乱复杂的硬件接口统一抽象管理方便上层程序使用。</li>\n<li>管理电脑（硬件）资源</li>\n</ol>\n<h3 id=\"2-In-Section-1-4-nine-different-types-of-operating-systems-are-described-Give-a-list-of-applications-for-each-of-these-systems-one-per-operating-systems-type\"><a href=\"#2-In-Section-1-4-nine-different-types-of-operating-systems-are-described-Give-a-list-of-applications-for-each-of-these-systems-one-per-operating-systems-type\" class=\"headerlink\" title=\"2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).\"></a>2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).</h3><ol>\n<li>Mainframe OS(大型机操作系统)<br>The operating systems for mainframes are heavily oriented toward processing<br>many jobs at once, most of which need prodigious amounts of I/O.</li>\n<li>Server OS</li>\n<li>Multiprocessors OS</li>\n<li>personal computer OS （笔记本）</li>\n<li>handheld computer OS （手机）</li>\n<li>Embedded OS （TV、MP3）</li>\n<li>Sensor-Node OS </li>\n<li>real-time OS</li>\n<li>smart card OS （Java applet）</li>\n</ol>\n<h3 id=\"3-What-is-the-difference-between-timesharing-and-multiprogramming-systems\"><a href=\"#3-What-is-the-difference-between-timesharing-and-multiprogramming-systems\" class=\"headerlink\" title=\"3.What is the difference between timesharing and multiprogramming systems?\"></a>3.What is the difference between timesharing and multiprogramming systems?</h3><h3 id=\"4-To-use-cache-memory-main-memory-is-divided-into-cache-lines-typically-32-or-64-bytes-long-An-entire-cache-line-is-cached-at-once-What-is-the-advantage-of-caching-an-entire-line-instead-of-a-single-byte-or-word-at-a-time\"><a href=\"#4-To-use-cache-memory-main-memory-is-divided-into-cache-lines-typically-32-or-64-bytes-long-An-entire-cache-line-is-cached-at-once-What-is-the-advantage-of-caching-an-entire-line-instead-of-a-single-byte-or-word-at-a-time\" class=\"headerlink\" title=\"4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?\"></a>4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?</h3>","site":{"data":{}},"excerpt":"","more":"<p>继续开坑系列，弥补计算机基础来了。</p>\n<h3 id=\"1-What-are-the-two-main-functions-of-an-operating-system\"><a href=\"#1-What-are-the-two-main-functions-of-an-operating-system\" class=\"headerlink\" title=\"1.What are the two main functions of an operating system?\"></a>1.What are the two main functions of an operating system?</h3><p>providing application programmers (and application programs, naturally) a clean abstract set of resources instead of the messy hardware ones and managing these hardware resources. </p>\n<ol>\n<li>为用户程序提供抽象。——将混乱复杂的硬件接口统一抽象管理方便上层程序使用。</li>\n<li>管理电脑（硬件）资源</li>\n</ol>\n<h3 id=\"2-In-Section-1-4-nine-different-types-of-operating-systems-are-described-Give-a-list-of-applications-for-each-of-these-systems-one-per-operating-systems-type\"><a href=\"#2-In-Section-1-4-nine-different-types-of-operating-systems-are-described-Give-a-list-of-applications-for-each-of-these-systems-one-per-operating-systems-type\" class=\"headerlink\" title=\"2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).\"></a>2.In Section 1.4, nine different types of operating systems are described. Give a list of applications for each of these systems (one per operating systems type).</h3><ol>\n<li>Mainframe OS(大型机操作系统)<br>The operating systems for mainframes are heavily oriented toward processing<br>many jobs at once, most of which need prodigious amounts of I/O.</li>\n<li>Server OS</li>\n<li>Multiprocessors OS</li>\n<li>personal computer OS （笔记本）</li>\n<li>handheld computer OS （手机）</li>\n<li>Embedded OS （TV、MP3）</li>\n<li>Sensor-Node OS </li>\n<li>real-time OS</li>\n<li>smart card OS （Java applet）</li>\n</ol>\n<h3 id=\"3-What-is-the-difference-between-timesharing-and-multiprogramming-systems\"><a href=\"#3-What-is-the-difference-between-timesharing-and-multiprogramming-systems\" class=\"headerlink\" title=\"3.What is the difference between timesharing and multiprogramming systems?\"></a>3.What is the difference between timesharing and multiprogramming systems?</h3><h3 id=\"4-To-use-cache-memory-main-memory-is-divided-into-cache-lines-typically-32-or-64-bytes-long-An-entire-cache-line-is-cached-at-once-What-is-the-advantage-of-caching-an-entire-line-instead-of-a-single-byte-or-word-at-a-time\"><a href=\"#4-To-use-cache-memory-main-memory-is-divided-into-cache-lines-typically-32-or-64-bytes-long-An-entire-cache-line-is-cached-at-once-What-is-the-advantage-of-caching-an-entire-line-instead-of-a-single-byte-or-word-at-a-time\" class=\"headerlink\" title=\"4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?\"></a>4.To use cache memory, main memory is divided into cache lines, typically 32 or 64 bytes long. An entire cache line is cached at once. What is the advantage of caching an entire line instead of a single byte or word at a time?</h3>"},{"title":"关于","_content":"如果文章有问题或者哪里有不足，欢迎大家联系我探讨。\n\n邮箱：nightoxray@gamil.com\n微博：[黑夜下的X光线](https://weibo.com/clc727 \"黑夜下的X光线\")","source":"about/index.md","raw":"---\ntitle: 关于\n---\n如果文章有问题或者哪里有不足，欢迎大家联系我探讨。\n\n邮箱：nightoxray@gamil.com\n微博：[黑夜下的X光线](https://weibo.com/clc727 \"黑夜下的X光线\")","date":"2019-08-05T02:12:09.839Z","updated":"2019-08-05T02:12:09.839Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjzawexra003li0h6ar99u5k9","content":"<p>如果文章有问题或者哪里有不足，欢迎大家联系我探讨。</p>\n<p>邮箱：<a href=\"mailto:nightoxray@gamil.com\" target=\"_blank\" rel=\"noopener\">nightoxray@gamil.com</a><br>微博：<a href=\"https://weibo.com/clc727\" title=\"黑夜下的X光线\" target=\"_blank\" rel=\"noopener\">黑夜下的X光线</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果文章有问题或者哪里有不足，欢迎大家联系我探讨。</p>\n<p>邮箱：<a href=\"mailto:nightoxray@gamil.com\" target=\"_blank\" rel=\"noopener\">nightoxray@gamil.com</a><br>微博：<a href=\"https://weibo.com/clc727\" title=\"黑夜下的X光线\" target=\"_blank\" rel=\"noopener\">黑夜下的X光线</a></p>\n"}],"Post":[{"title":"Leetcode BST系列（一）","date":"2019-03-14T02:25:15.000Z","description":"Leetcode BST 530/653/783","_content":"## BST定义\n> 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n> 1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n> 2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n> 3.任意节点的左、右子树也分别为二叉查找树；\n> 4.没有键值相等的节点。\n> 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n) 。\n> 二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n\n### 653. Two Sum IV - Input is a BST\n从这一题开始的原因是LeetCode第一题就是两数之和，以前做653这个题目的思路就是把遍历到的每一个节点的值放到set中，然后再判断当前节点值与目标值的差是否在set中，这样解题是可行的。但是第一题的两数之和有一个解法就是把数组排序然后两端逼近，然后就想到了BST也是可以通过中序遍历转成一个有序的数组，那么再两头逼近又可以求解了。所以我又提交了一遍新的解法，上面显示速度还比我一年前提交的快。\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n        int n = list.size()-1;\n        for(int i=0, j=n; i<j;){\n            if(list.get(i) + list.get(j) > k) {\n                j--;\n            } else if (list.get(i) + list.get(j) < k) {\n                i++;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n    // 中序遍历\n    public void inorder(TreeNode root, List<Integer> list) {\n        if(root == null) {\n            return;\n        }\n        inorder(root.left, list);\n        list.add(root.val);\n        inorder(root.right, list);\n    }\n}\n```\n### 783. Minimum Distance Between BST Nodes && 530. Minimum Absolute Difference in BST\n在讨论区有人说这两题代码提交一样的，所以我也放到一起。题意是找出BST中任意两个节点相差最小的值。\n很明显还是要用到BST中序遍历时是从小到大的性质，那么只需要比较任意相邻两个节点相减的值，第一遍提交我是直接把上面代码复制过去改了for循环的逻辑。\n```\nint n = list.size();\nint min = Integer.MAX_VALUE;\nfor(int i=0; i<n-1; i++) {\n    int t = list.get(i+1) - list.get(i);\n    if(t < min) {\n        min = t;\n    }\n}\n```\n其实放到list中是多余的，因为中序遍历的时候可以直接计算相邻两个节点的差值，所以直接把计算放到中序遍历的时候处理。\n```\nclass Solution {\n\n\tprivate Integer min = Integer.MAX_VALUE;\n\tprivate Integer pre = null;\n\n    public int minDiffInBST(TreeNode root) {\n       \tif(root == null) {\n       \t\treturn min;\n       \t}\n        \n        minDiffInBST(root.left);\n        if(pre != null) {\n\t\t\tmin = Math.min(min, root.val - pre);        \t\n        }\n        pre = root.val;  //保存节点值\n        minDiffInBST(root.right);\n        return min;\n    }\n}\n```\n","source":"_posts/2019-03-14-BST系列（一）.md","raw":"---\ntitle: Leetcode BST系列（一）\ndate: 2019-03-14 10:25:15\ntags: [LeetCode,BST,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 530/653/783\n---\n## BST定义\n> 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n> 1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n> 2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n> 3.任意节点的左、右子树也分别为二叉查找树；\n> 4.没有键值相等的节点。\n> 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n) 。\n> 二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n\n### 653. Two Sum IV - Input is a BST\n从这一题开始的原因是LeetCode第一题就是两数之和，以前做653这个题目的思路就是把遍历到的每一个节点的值放到set中，然后再判断当前节点值与目标值的差是否在set中，这样解题是可行的。但是第一题的两数之和有一个解法就是把数组排序然后两端逼近，然后就想到了BST也是可以通过中序遍历转成一个有序的数组，那么再两头逼近又可以求解了。所以我又提交了一遍新的解法，上面显示速度还比我一年前提交的快。\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n        int n = list.size()-1;\n        for(int i=0, j=n; i<j;){\n            if(list.get(i) + list.get(j) > k) {\n                j--;\n            } else if (list.get(i) + list.get(j) < k) {\n                i++;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n    // 中序遍历\n    public void inorder(TreeNode root, List<Integer> list) {\n        if(root == null) {\n            return;\n        }\n        inorder(root.left, list);\n        list.add(root.val);\n        inorder(root.right, list);\n    }\n}\n```\n### 783. Minimum Distance Between BST Nodes && 530. Minimum Absolute Difference in BST\n在讨论区有人说这两题代码提交一样的，所以我也放到一起。题意是找出BST中任意两个节点相差最小的值。\n很明显还是要用到BST中序遍历时是从小到大的性质，那么只需要比较任意相邻两个节点相减的值，第一遍提交我是直接把上面代码复制过去改了for循环的逻辑。\n```\nint n = list.size();\nint min = Integer.MAX_VALUE;\nfor(int i=0; i<n-1; i++) {\n    int t = list.get(i+1) - list.get(i);\n    if(t < min) {\n        min = t;\n    }\n}\n```\n其实放到list中是多余的，因为中序遍历的时候可以直接计算相邻两个节点的差值，所以直接把计算放到中序遍历的时候处理。\n```\nclass Solution {\n\n\tprivate Integer min = Integer.MAX_VALUE;\n\tprivate Integer pre = null;\n\n    public int minDiffInBST(TreeNode root) {\n       \tif(root == null) {\n       \t\treturn min;\n       \t}\n        \n        minDiffInBST(root.left);\n        if(pre != null) {\n\t\t\tmin = Math.min(min, root.val - pre);        \t\n        }\n        pre = root.val;  //保存节点值\n        minDiffInBST(root.right);\n        return min;\n    }\n}\n```\n","slug":"BST系列（一）","published":1,"updated":"2019-03-14T09:23:17.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewnp0002i0h6i44q1iow","content":"<h2 id=\"BST定义\"><a href=\"#BST定义\" class=\"headerlink\" title=\"BST定义\"></a>BST定义</h2><blockquote>\n<p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：<br>1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>3.任意节点的左、右子树也分别为二叉查找树；<br>4.没有键值相等的节点。<br>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n) 。<br>二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</p>\n</blockquote>\n<h3 id=\"653-Two-Sum-IV-Input-is-a-BST\"><a href=\"#653-Two-Sum-IV-Input-is-a-BST\" class=\"headerlink\" title=\"653. Two Sum IV - Input is a BST\"></a>653. Two Sum IV - Input is a BST</h3><p>从这一题开始的原因是LeetCode第一题就是两数之和，以前做653这个题目的思路就是把遍历到的每一个节点的值放到set中，然后再判断当前节点值与目标值的差是否在set中，这样解题是可行的。但是第一题的两数之和有一个解法就是把数组排序然后两端逼近，然后就想到了BST也是可以通过中序遍历转成一个有序的数组，那么再两头逼近又可以求解了。所以我又提交了一遍新的解法，上面显示速度还比我一年前提交的快。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> findTarget(TreeNode root, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">List</span>&lt;Integer&gt; <span class=\"keyword\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        inorder(root, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"keyword\">list</span>.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=n; i&lt;j;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">list</span>.get(i) + <span class=\"keyword\">list</span>.get(j) &gt; k) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">list</span>.get(i) + <span class=\"keyword\">list</span>.get(j) &lt; k) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> void inorder(TreeNode root, <span class=\"keyword\">List</span>&lt;Integer&gt; <span class=\"keyword\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">list</span>.add(root.val);</span><br><span class=\"line\">        inorder(root.right, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"783-Minimum-Distance-Between-BST-Nodes-amp-amp-530-Minimum-Absolute-Difference-in-BST\"><a href=\"#783-Minimum-Distance-Between-BST-Nodes-amp-amp-530-Minimum-Absolute-Difference-in-BST\" class=\"headerlink\" title=\"783. Minimum Distance Between BST Nodes &amp;&amp; 530. Minimum Absolute Difference in BST\"></a>783. Minimum Distance Between BST Nodes &amp;&amp; 530. Minimum Absolute Difference in BST</h3><p>在讨论区有人说这两题代码提交一样的，所以我也放到一起。题意是找出BST中任意两个节点相差最小的值。<br>很明显还是要用到BST中序遍历时是从小到大的性质，那么只需要比较任意相邻两个节点相减的值，第一遍提交我是直接把上面代码复制过去改了for循环的逻辑。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = list.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">min</span> = Integer.MAX_VALUE;</span><br><span class=\"line\"><span class=\"built_in\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = list.<span class=\"built_in\">get</span>(i+<span class=\"number\">1</span>) - list.<span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">if</span>(t &lt; <span class=\"built_in\">min</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">min</span> = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实放到list中是多余的，因为中序遍历的时候可以直接计算相邻两个节点的差值，所以直接把计算放到中序遍历的时候处理。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">Integer</span> <span class=\"keyword\">min</span> = <span class=\"built_in\">Integer</span>.MAX_VALUE;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">Integer</span> pre = <span class=\"built_in\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int minDiffInBST(TreeNode root) &#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(root == <span class=\"built_in\">null</span>) &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">min</span>;</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        minDiffInBST(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"built_in\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">min</span> = Math.<span class=\"keyword\">min</span>(<span class=\"keyword\">min</span>, root.val - pre);        \t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = root.val;  <span class=\"comment\">//保存节点值</span></span><br><span class=\"line\">        minDiffInBST(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">min</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BST定义\"><a href=\"#BST定义\" class=\"headerlink\" title=\"BST定义\"></a>BST定义</h2><blockquote>\n<p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：<br>1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>3.任意节点的左、右子树也分别为二叉查找树；<br>4.没有键值相等的节点。<br>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n) 。<br>二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</p>\n</blockquote>\n<h3 id=\"653-Two-Sum-IV-Input-is-a-BST\"><a href=\"#653-Two-Sum-IV-Input-is-a-BST\" class=\"headerlink\" title=\"653. Two Sum IV - Input is a BST\"></a>653. Two Sum IV - Input is a BST</h3><p>从这一题开始的原因是LeetCode第一题就是两数之和，以前做653这个题目的思路就是把遍历到的每一个节点的值放到set中，然后再判断当前节点值与目标值的差是否在set中，这样解题是可行的。但是第一题的两数之和有一个解法就是把数组排序然后两端逼近，然后就想到了BST也是可以通过中序遍历转成一个有序的数组，那么再两头逼近又可以求解了。所以我又提交了一遍新的解法，上面显示速度还比我一年前提交的快。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> findTarget(TreeNode root, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">List</span>&lt;Integer&gt; <span class=\"keyword\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        inorder(root, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"keyword\">list</span>.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, j=n; i&lt;j;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">list</span>.get(i) + <span class=\"keyword\">list</span>.get(j) &gt; k) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">list</span>.get(i) + <span class=\"keyword\">list</span>.get(j) &lt; k) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> void inorder(TreeNode root, <span class=\"keyword\">List</span>&lt;Integer&gt; <span class=\"keyword\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">list</span>.add(root.val);</span><br><span class=\"line\">        inorder(root.right, <span class=\"keyword\">list</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"783-Minimum-Distance-Between-BST-Nodes-amp-amp-530-Minimum-Absolute-Difference-in-BST\"><a href=\"#783-Minimum-Distance-Between-BST-Nodes-amp-amp-530-Minimum-Absolute-Difference-in-BST\" class=\"headerlink\" title=\"783. Minimum Distance Between BST Nodes &amp;&amp; 530. Minimum Absolute Difference in BST\"></a>783. Minimum Distance Between BST Nodes &amp;&amp; 530. Minimum Absolute Difference in BST</h3><p>在讨论区有人说这两题代码提交一样的，所以我也放到一起。题意是找出BST中任意两个节点相差最小的值。<br>很明显还是要用到BST中序遍历时是从小到大的性质，那么只需要比较任意相邻两个节点相减的值，第一遍提交我是直接把上面代码复制过去改了for循环的逻辑。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = list.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">min</span> = Integer.MAX_VALUE;</span><br><span class=\"line\"><span class=\"built_in\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = list.<span class=\"built_in\">get</span>(i+<span class=\"number\">1</span>) - list.<span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">if</span>(t &lt; <span class=\"built_in\">min</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">min</span> = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实放到list中是多余的，因为中序遍历的时候可以直接计算相邻两个节点的差值，所以直接把计算放到中序遍历的时候处理。<br><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">Integer</span> <span class=\"keyword\">min</span> = <span class=\"built_in\">Integer</span>.MAX_VALUE;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">Integer</span> pre = <span class=\"built_in\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int minDiffInBST(TreeNode root) &#123;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span>(root == <span class=\"built_in\">null</span>) &#123;</span><br><span class=\"line\">       \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">min</span>;</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        minDiffInBST(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"built_in\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">min</span> = Math.<span class=\"keyword\">min</span>(<span class=\"keyword\">min</span>, root.val - pre);        \t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = root.val;  <span class=\"comment\">//保存节点值</span></span><br><span class=\"line\">        minDiffInBST(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">min</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode BST系列（三）","date":"2019-03-20T02:19:22.000Z","description":"Leetcode BST 729/731/732","_content":"## 说明\nBST标签下面的是731.My Calendar II，但是为了完整，所以就把这三道题都放在一起了。\n### 729. My Calendar I\n题目大意是给定一个范围区间，判断新增的范围是否与之前的（左闭右开）区间有重叠，如果重叠则返回false，不重叠返回true并添加这个范围。\n我的理解就很简单，重叠的情况就如下4种，所以判断的逻辑就是两种情况：\n1. 起始位置（start）小于区间左边，要想重叠那么end也要大于区间左边；\n2. 起始位置（start）大于等于区间左边，要想重叠那么start同时也要小于区间右边；\n\n代码的话很简单，构造一个储存区间的list不重叠就往里add，每次判断都遍历这个list。时间复杂度是O(N²)，一次遍历是n，n次book。\n![](1.png)\n\n```\nclass MyCalendar {\n\n\tprivate List<Event> list;\n    \n    public MyCalendar() {\n    \tlist = new ArrayList<Event>();\n    }\n    \n    public boolean book(int start, int end) {\n        for(Event e : list) {\n        \tif(start<e.left && end > e.left) return false;\n        \tif(start>=e.left && start < e.right) return false;\n        }\n        Event t = new Event();\n        t.left = start;\n        t.right = end;\n        list.add(t);\n        return true;\n    }\n    class Event {\n    \tprivate int left;\n    \tprivate int right;\n    }\n}\n```\n\n网上还看到另一种用TreeMap的解法，时间复杂度为O(NlogN)，每次新加入区间的时候维护一定的顺序，然后通过起始点比较的时候直接找到比start大的最小值，比start小的最大值，通过TreeMap这样的数据结构效率比之前的好，代码如下\n```\nclass MyCalendar {\n    \n    private TreeMap<Integer, Integer> t;\n\n    public MyCalendar() {\n        t = new TreeMap<>();\n    }\n    \n    public boolean book(int start, int end) {\n        Integer a = t.floorKey(start);  //比start小的最大值\n\t\tif(a != null && start < t.get(a)) return false;\n\t\tInteger b = t.ceilingKey(start); // 比start大的最小值\n\t\tif(b != null && end > b) return false;\n        t.put(start, end);\n\t\treturn true;\n    }\n}\n```\n\n### 731. My Calendar II\n这道题是允许有两个区间重叠，但是不能有第三个，有了上一题的经验就不再用暴力破解，而是尝试一下TreeMap，既然在有重叠的区间上不能再允许重叠，那我们就可以把重叠的区间维护在一个TreeMap里，然后再用和上面一样的方法判断是否有重叠。那么现在的问题就是如何把重叠的区间放到TreeMap里，直接判断新来的区间是否和之前给的区间有重叠，有的话就放进去，然后发现把上面两个代码给结合了，竟然也过了。\n\n```\nclass MyCalendarTwo {\n    \n    private TreeMap<Integer, Integer> overlayMap;\n    private List<Event> list;\n\n    public MyCalendarTwo() {\n        overlayMap = new TreeMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public boolean book(int start, int end) {\n        Integer a = overlayMap.floorKey(start);  //比start小的最大值\n\t\tif(a != null && start < overlayMap.get(a)) return false;\n\t\tInteger b = overlayMap.ceilingKey(start); // 比start大的最小值\n\t\tif(b != null && end > b) return false;\n\n\t\tfor(Event e: list) {\n\t\t\tif((start<e.left && end > e.left) || (start>=e.left && start < e.right)) {  //判断是否有重叠\n\t\t\t\toverlayMap.put(Math.max(start, e.left), Math.min(end, e.right));\n\t\t\t}\n        \t\n\t\t}\n\t\tEvent t = new Event();\n\t\tt.left = start;\n\t\tt.right = end;\n\t\tlist.add(t);\n\t\treturn true;\n    }\n    class Event {\n    \tprivate int left;\n    \tprivate int right;\n    }\n}\n```\n\n以上代码能通过说明思路是没错的。可是这样的解法感觉有点简单粗暴，于是去看了看其他的题解。代码比较短的就是官方给出的边界统计的那个题解，代码如下：\n\n```\nclass MyCalendarTwo {\n    TreeMap<Integer, Integer> delta;\n\n    public MyCalendarTwo() {\n        delta = new TreeMap();\n    }\n\n    public boolean book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n\n        int active = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active >= 3) {\n                delta.put(start, delta.get(start) - 1);\n                delta.put(end, delta.get(end) + 1);\n                if (delta.get(start) == 0)\n                    delta.remove(start);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n上面维护的TreeMap，key是所有出现过的区间（起点、终点）的值，vlaue默认启示位置1，结束位置-1，可以看成从左到右滑动一样，当所有区间没重叠，每次开始位置+1，结束位置-1，当重叠一次时，肯定能累加到2，所以只要累加到3时，说明此时该起点位置的区间是不满足条件的，于是撤销它的+1和-1。最后那个判断起始点值为0时移除的操作是为了节省空间。虽然上面的代码简洁一点，但是理解起来确实有点难度。希望有更通俗易懂的解释。\n\n### 732. My Calendar III\n题意就是找出重叠的最大的区间个数，至多多少个区间重叠。直接改造上面的代码如下：\n\n```\nclass MyCalendarThree {\n\n\tTreeMap<Integer, Integer> delta;\n\tint max;\n    public MyCalendarThree() {\n         delta = new TreeMap();\n         max = 1;\n    }\n    public int book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n\n        int active = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active > max ) {\n                max = active;\n            }\n        }\n        return max;\n    }\n}\n```\n\n既然都是判断新来的区间和已有的是否有重叠，那么用第一题判断重叠的办法还是可以做的。\n\n## 总结\n上面三道题最核心部分就是理解重叠区域的判断，只要正确判断了这个，那么很容易就可以解出来。至于后面边界计数的方法确实很巧妙，巧妙的方法理解起来也不是那么容易，但又很通用，确实需要慢慢消化一下。通过这几题还顺便用了一下TreeMap的api，平时几乎没用过，它的底层数据结构是红黑树，红黑树也是二叉查找树，所以自然而然就要用到它的排序性质，有机会深入TreeMap源码理解一下。","source":"_posts/2019-03-19-BST系列（三）.md","raw":"---\ntitle: Leetcode BST系列（三）\ndate: 2019-03-20 10:19:22\ntags: [LeetCode,BST,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 729/731/732\n---\n## 说明\nBST标签下面的是731.My Calendar II，但是为了完整，所以就把这三道题都放在一起了。\n### 729. My Calendar I\n题目大意是给定一个范围区间，判断新增的范围是否与之前的（左闭右开）区间有重叠，如果重叠则返回false，不重叠返回true并添加这个范围。\n我的理解就很简单，重叠的情况就如下4种，所以判断的逻辑就是两种情况：\n1. 起始位置（start）小于区间左边，要想重叠那么end也要大于区间左边；\n2. 起始位置（start）大于等于区间左边，要想重叠那么start同时也要小于区间右边；\n\n代码的话很简单，构造一个储存区间的list不重叠就往里add，每次判断都遍历这个list。时间复杂度是O(N²)，一次遍历是n，n次book。\n![](1.png)\n\n```\nclass MyCalendar {\n\n\tprivate List<Event> list;\n    \n    public MyCalendar() {\n    \tlist = new ArrayList<Event>();\n    }\n    \n    public boolean book(int start, int end) {\n        for(Event e : list) {\n        \tif(start<e.left && end > e.left) return false;\n        \tif(start>=e.left && start < e.right) return false;\n        }\n        Event t = new Event();\n        t.left = start;\n        t.right = end;\n        list.add(t);\n        return true;\n    }\n    class Event {\n    \tprivate int left;\n    \tprivate int right;\n    }\n}\n```\n\n网上还看到另一种用TreeMap的解法，时间复杂度为O(NlogN)，每次新加入区间的时候维护一定的顺序，然后通过起始点比较的时候直接找到比start大的最小值，比start小的最大值，通过TreeMap这样的数据结构效率比之前的好，代码如下\n```\nclass MyCalendar {\n    \n    private TreeMap<Integer, Integer> t;\n\n    public MyCalendar() {\n        t = new TreeMap<>();\n    }\n    \n    public boolean book(int start, int end) {\n        Integer a = t.floorKey(start);  //比start小的最大值\n\t\tif(a != null && start < t.get(a)) return false;\n\t\tInteger b = t.ceilingKey(start); // 比start大的最小值\n\t\tif(b != null && end > b) return false;\n        t.put(start, end);\n\t\treturn true;\n    }\n}\n```\n\n### 731. My Calendar II\n这道题是允许有两个区间重叠，但是不能有第三个，有了上一题的经验就不再用暴力破解，而是尝试一下TreeMap，既然在有重叠的区间上不能再允许重叠，那我们就可以把重叠的区间维护在一个TreeMap里，然后再用和上面一样的方法判断是否有重叠。那么现在的问题就是如何把重叠的区间放到TreeMap里，直接判断新来的区间是否和之前给的区间有重叠，有的话就放进去，然后发现把上面两个代码给结合了，竟然也过了。\n\n```\nclass MyCalendarTwo {\n    \n    private TreeMap<Integer, Integer> overlayMap;\n    private List<Event> list;\n\n    public MyCalendarTwo() {\n        overlayMap = new TreeMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public boolean book(int start, int end) {\n        Integer a = overlayMap.floorKey(start);  //比start小的最大值\n\t\tif(a != null && start < overlayMap.get(a)) return false;\n\t\tInteger b = overlayMap.ceilingKey(start); // 比start大的最小值\n\t\tif(b != null && end > b) return false;\n\n\t\tfor(Event e: list) {\n\t\t\tif((start<e.left && end > e.left) || (start>=e.left && start < e.right)) {  //判断是否有重叠\n\t\t\t\toverlayMap.put(Math.max(start, e.left), Math.min(end, e.right));\n\t\t\t}\n        \t\n\t\t}\n\t\tEvent t = new Event();\n\t\tt.left = start;\n\t\tt.right = end;\n\t\tlist.add(t);\n\t\treturn true;\n    }\n    class Event {\n    \tprivate int left;\n    \tprivate int right;\n    }\n}\n```\n\n以上代码能通过说明思路是没错的。可是这样的解法感觉有点简单粗暴，于是去看了看其他的题解。代码比较短的就是官方给出的边界统计的那个题解，代码如下：\n\n```\nclass MyCalendarTwo {\n    TreeMap<Integer, Integer> delta;\n\n    public MyCalendarTwo() {\n        delta = new TreeMap();\n    }\n\n    public boolean book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n\n        int active = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active >= 3) {\n                delta.put(start, delta.get(start) - 1);\n                delta.put(end, delta.get(end) + 1);\n                if (delta.get(start) == 0)\n                    delta.remove(start);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n上面维护的TreeMap，key是所有出现过的区间（起点、终点）的值，vlaue默认启示位置1，结束位置-1，可以看成从左到右滑动一样，当所有区间没重叠，每次开始位置+1，结束位置-1，当重叠一次时，肯定能累加到2，所以只要累加到3时，说明此时该起点位置的区间是不满足条件的，于是撤销它的+1和-1。最后那个判断起始点值为0时移除的操作是为了节省空间。虽然上面的代码简洁一点，但是理解起来确实有点难度。希望有更通俗易懂的解释。\n\n### 732. My Calendar III\n题意就是找出重叠的最大的区间个数，至多多少个区间重叠。直接改造上面的代码如下：\n\n```\nclass MyCalendarThree {\n\n\tTreeMap<Integer, Integer> delta;\n\tint max;\n    public MyCalendarThree() {\n         delta = new TreeMap();\n         max = 1;\n    }\n    public int book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n\n        int active = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active > max ) {\n                max = active;\n            }\n        }\n        return max;\n    }\n}\n```\n\n既然都是判断新来的区间和已有的是否有重叠，那么用第一题判断重叠的办法还是可以做的。\n\n## 总结\n上面三道题最核心部分就是理解重叠区域的判断，只要正确判断了这个，那么很容易就可以解出来。至于后面边界计数的方法确实很巧妙，巧妙的方法理解起来也不是那么容易，但又很通用，确实需要慢慢消化一下。通过这几题还顺便用了一下TreeMap的api，平时几乎没用过，它的底层数据结构是红黑树，红黑树也是二叉查找树，所以自然而然就要用到它的排序性质，有机会深入TreeMap源码理解一下。","slug":"BST系列（三）","published":1,"updated":"2019-03-20T06:52:35.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewnw0003i0h6zyonbxip","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>BST标签下面的是731.My Calendar II，但是为了完整，所以就把这三道题都放在一起了。</p>\n<h3 id=\"729-My-Calendar-I\"><a href=\"#729-My-Calendar-I\" class=\"headerlink\" title=\"729. My Calendar I\"></a>729. My Calendar I</h3><p>题目大意是给定一个范围区间，判断新增的范围是否与之前的（左闭右开）区间有重叠，如果重叠则返回false，不重叠返回true并添加这个范围。<br>我的理解就很简单，重叠的情况就如下4种，所以判断的逻辑就是两种情况：</p>\n<ol>\n<li>起始位置（start）小于区间左边，要想重叠那么end也要大于区间左边；</li>\n<li>起始位置（start）大于等于区间左边，要想重叠那么start同时也要小于区间右边；</li>\n</ol>\n<p>代码的话很简单，构造一个储存区间的list不重叠就往里add，每次判断都遍历这个list。时间复杂度是O(N²)，一次遍历是n，n次book。<br><img src=\"1.png\" alt></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendar</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Event&gt; <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCalendar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;Event&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">book</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Event e : <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(start&lt;e.left &amp;&amp; end &gt; e.left) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(start&gt;=e.left &amp;&amp; start &lt; e.right) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Event t = <span class=\"keyword\">new</span> Event();</span><br><span class=\"line\">        t.left = start;</span><br><span class=\"line\">        t.right = end;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>.add(t);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> &#123;</span></span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上还看到另一种用TreeMap的解法，时间复杂度为O(NlogN)，每次新加入区间的时候维护一定的顺序，然后通过起始点比较的时候直接找到比start大的最小值，比start小的最大值，通过TreeMap这样的数据结构效率比之前的好，代码如下<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendar</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; t;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCalendar</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        t = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">book</span>(<span class=\"params\"><span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end</span>)</span> &#123;</span><br><span class=\"line\">        Integer a = t.floorKey(start);  <span class=\"comment\">//比start小的最大值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != <span class=\"literal\">null</span> &amp;&amp; start &lt; t.<span class=\"keyword\">get</span>(a)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tInteger b = t.ceilingKey(start); <span class=\"comment\">// 比start大的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b != <span class=\"literal\">null</span> &amp;&amp; end &gt; b) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        t.put(start, end);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"731-My-Calendar-II\"><a href=\"#731-My-Calendar-II\" class=\"headerlink\" title=\"731. My Calendar II\"></a>731. My Calendar II</h3><p>这道题是允许有两个区间重叠，但是不能有第三个，有了上一题的经验就不再用暴力破解，而是尝试一下TreeMap，既然在有重叠的区间上不能再允许重叠，那我们就可以把重叠的区间维护在一个TreeMap里，然后再用和上面一样的方法判断是否有重叠。那么现在的问题就是如何把重叠的区间放到TreeMap里，直接判断新来的区间是否和之前给的区间有重叠，有的话就放进去，然后发现把上面两个代码给结合了，竟然也过了。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendarTwo</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; overlayMap;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">List</span>&lt;Event&gt; <span class=\"keyword\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyCalendarTwo() &#123;</span><br><span class=\"line\">        overlayMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> book(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end) &#123;</span><br><span class=\"line\">        Integer a = overlayMap.floorKey(start);  <span class=\"comment\">//比start小的最大值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != <span class=\"keyword\">null</span> &amp;&amp; start &lt; overlayMap.get(a)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\tInteger b = overlayMap.ceilingKey(start); <span class=\"comment\">// 比start大的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b != <span class=\"keyword\">null</span> &amp;&amp; end &gt; b) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Event e: <span class=\"keyword\">list</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((start&lt;e.left &amp;&amp; end &gt; e.left) || (start&gt;=e.left &amp;&amp; start &lt; e.right)) &#123;  <span class=\"comment\">//判断是否有重叠</span></span><br><span class=\"line\">\t\t\t\toverlayMap.put(Math.max(start, e.left), Math.min(end, e.right));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">        \t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tEvent t = <span class=\"keyword\">new</span> Event();</span><br><span class=\"line\">\t\tt.left = start;</span><br><span class=\"line\">\t\tt.right = end;</span><br><span class=\"line\">\t\t<span class=\"keyword\">list</span>.add(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码能通过说明思路是没错的。可是这样的解法感觉有点简单粗暴，于是去看了看其他的题解。代码比较短的就是官方给出的边界统计的那个题解，代码如下：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyCalendarTwo &#123;</span><br><span class=\"line\">    TreeMap&lt;Integer, Integer&gt; <span class=\"built_in\">delta</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyCalendarTwo() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delta</span> = <span class=\"built_in\">new</span> TreeMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean book(int start, int end) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(start, <span class=\"built_in\">delta</span>.getOrDefault(start, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(end, <span class=\"built_in\">delta</span>.getOrDefault(end, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        int active = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int d: <span class=\"built_in\">delta</span>.<span class=\"built_in\">values</span>()) &#123;</span><br><span class=\"line\">            active += d;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (active &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(start, <span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(start) - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(end, <span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(end) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(start) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">delta</span>.<span class=\"built_in\">remove</span>(start);</span><br><span class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面维护的TreeMap，key是所有出现过的区间（起点、终点）的值，vlaue默认启示位置1，结束位置-1，可以看成从左到右滑动一样，当所有区间没重叠，每次开始位置+1，结束位置-1，当重叠一次时，肯定能累加到2，所以只要累加到3时，说明此时该起点位置的区间是不满足条件的，于是撤销它的+1和-1。最后那个判断起始点值为0时移除的操作是为了节省空间。虽然上面的代码简洁一点，但是理解起来确实有点难度。希望有更通俗易懂的解释。</p>\n<h3 id=\"732-My-Calendar-III\"><a href=\"#732-My-Calendar-III\" class=\"headerlink\" title=\"732. My Calendar III\"></a>732. My Calendar III</h3><p>题意就是找出重叠的最大的区间个数，至多多少个区间重叠。直接改造上面的代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyCalendarThree &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTreeMap&lt;Integer, Integer&gt; delta;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyCalendarThree() &#123;</span><br><span class=\"line\">         delta = <span class=\"keyword\">new</span> TreeMap();</span><br><span class=\"line\">         <span class=\"built_in\">max</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> book(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> <span class=\"built_in\">end</span>) &#123;</span><br><span class=\"line\">        delta.<span class=\"built_in\">put</span>(start, delta.getOrDefault(start, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        delta.<span class=\"built_in\">put</span>(<span class=\"built_in\">end</span>, delta.getOrDefault(<span class=\"built_in\">end</span>, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> active = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> d: delta.values()) &#123;</span><br><span class=\"line\">            active += d;</span><br><span class=\"line\">            <span class=\"built_in\">if</span> (active &gt; <span class=\"built_in\">max</span> ) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">max</span> = active;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>既然都是判断新来的区间和已有的是否有重叠，那么用第一题判断重叠的办法还是可以做的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面三道题最核心部分就是理解重叠区域的判断，只要正确判断了这个，那么很容易就可以解出来。至于后面边界计数的方法确实很巧妙，巧妙的方法理解起来也不是那么容易，但又很通用，确实需要慢慢消化一下。通过这几题还顺便用了一下TreeMap的api，平时几乎没用过，它的底层数据结构是红黑树，红黑树也是二叉查找树，所以自然而然就要用到它的排序性质，有机会深入TreeMap源码理解一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>BST标签下面的是731.My Calendar II，但是为了完整，所以就把这三道题都放在一起了。</p>\n<h3 id=\"729-My-Calendar-I\"><a href=\"#729-My-Calendar-I\" class=\"headerlink\" title=\"729. My Calendar I\"></a>729. My Calendar I</h3><p>题目大意是给定一个范围区间，判断新增的范围是否与之前的（左闭右开）区间有重叠，如果重叠则返回false，不重叠返回true并添加这个范围。<br>我的理解就很简单，重叠的情况就如下4种，所以判断的逻辑就是两种情况：</p>\n<ol>\n<li>起始位置（start）小于区间左边，要想重叠那么end也要大于区间左边；</li>\n<li>起始位置（start）大于等于区间左边，要想重叠那么start同时也要小于区间右边；</li>\n</ol>\n<p>代码的话很简单，构造一个储存区间的list不重叠就往里add，每次判断都遍历这个list。时间复杂度是O(N²)，一次遍历是n，n次book。<br><img src=\"1.png\" alt></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendar</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Event&gt; <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCalendar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;Event&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">book</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Event e : <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(start&lt;e.left &amp;&amp; end &gt; e.left) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(start&gt;=e.left &amp;&amp; start &lt; e.right) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Event t = <span class=\"keyword\">new</span> Event();</span><br><span class=\"line\">        t.left = start;</span><br><span class=\"line\">        t.right = end;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>.add(t);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> &#123;</span></span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上还看到另一种用TreeMap的解法，时间复杂度为O(NlogN)，每次新加入区间的时候维护一定的顺序，然后通过起始点比较的时候直接找到比start大的最小值，比start小的最大值，通过TreeMap这样的数据结构效率比之前的好，代码如下<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendar</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; t;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCalendar</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        t = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">book</span>(<span class=\"params\"><span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end</span>)</span> &#123;</span><br><span class=\"line\">        Integer a = t.floorKey(start);  <span class=\"comment\">//比start小的最大值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != <span class=\"literal\">null</span> &amp;&amp; start &lt; t.<span class=\"keyword\">get</span>(a)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tInteger b = t.ceilingKey(start); <span class=\"comment\">// 比start大的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b != <span class=\"literal\">null</span> &amp;&amp; end &gt; b) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        t.put(start, end);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"731-My-Calendar-II\"><a href=\"#731-My-Calendar-II\" class=\"headerlink\" title=\"731. My Calendar II\"></a>731. My Calendar II</h3><p>这道题是允许有两个区间重叠，但是不能有第三个，有了上一题的经验就不再用暴力破解，而是尝试一下TreeMap，既然在有重叠的区间上不能再允许重叠，那我们就可以把重叠的区间维护在一个TreeMap里，然后再用和上面一样的方法判断是否有重叠。那么现在的问题就是如何把重叠的区间放到TreeMap里，直接判断新来的区间是否和之前给的区间有重叠，有的话就放进去，然后发现把上面两个代码给结合了，竟然也过了。</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCalendarTwo</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; overlayMap;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">List</span>&lt;Event&gt; <span class=\"keyword\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyCalendarTwo() &#123;</span><br><span class=\"line\">        overlayMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> book(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end) &#123;</span><br><span class=\"line\">        Integer a = overlayMap.floorKey(start);  <span class=\"comment\">//比start小的最大值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != <span class=\"keyword\">null</span> &amp;&amp; start &lt; overlayMap.get(a)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\tInteger b = overlayMap.ceilingKey(start); <span class=\"comment\">// 比start大的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b != <span class=\"keyword\">null</span> &amp;&amp; end &gt; b) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Event e: <span class=\"keyword\">list</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((start&lt;e.left &amp;&amp; end &gt; e.left) || (start&gt;=e.left &amp;&amp; start &lt; e.right)) &#123;  <span class=\"comment\">//判断是否有重叠</span></span><br><span class=\"line\">\t\t\t\toverlayMap.put(Math.max(start, e.left), Math.min(end, e.right));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">        \t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tEvent t = <span class=\"keyword\">new</span> Event();</span><br><span class=\"line\">\t\tt.left = start;</span><br><span class=\"line\">\t\tt.right = end;</span><br><span class=\"line\">\t\t<span class=\"keyword\">list</span>.add(t);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码能通过说明思路是没错的。可是这样的解法感觉有点简单粗暴，于是去看了看其他的题解。代码比较短的就是官方给出的边界统计的那个题解，代码如下：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyCalendarTwo &#123;</span><br><span class=\"line\">    TreeMap&lt;Integer, Integer&gt; <span class=\"built_in\">delta</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyCalendarTwo() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delta</span> = <span class=\"built_in\">new</span> TreeMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean book(int start, int end) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(start, <span class=\"built_in\">delta</span>.getOrDefault(start, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(end, <span class=\"built_in\">delta</span>.getOrDefault(end, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        int active = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int d: <span class=\"built_in\">delta</span>.<span class=\"built_in\">values</span>()) &#123;</span><br><span class=\"line\">            active += d;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (active &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(start, <span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(start) - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"built_in\">delta</span>.<span class=\"built_in\">put</span>(end, <span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(end) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">delta</span>.<span class=\"built_in\">get</span>(start) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"built_in\">delta</span>.<span class=\"built_in\">remove</span>(start);</span><br><span class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面维护的TreeMap，key是所有出现过的区间（起点、终点）的值，vlaue默认启示位置1，结束位置-1，可以看成从左到右滑动一样，当所有区间没重叠，每次开始位置+1，结束位置-1，当重叠一次时，肯定能累加到2，所以只要累加到3时，说明此时该起点位置的区间是不满足条件的，于是撤销它的+1和-1。最后那个判断起始点值为0时移除的操作是为了节省空间。虽然上面的代码简洁一点，但是理解起来确实有点难度。希望有更通俗易懂的解释。</p>\n<h3 id=\"732-My-Calendar-III\"><a href=\"#732-My-Calendar-III\" class=\"headerlink\" title=\"732. My Calendar III\"></a>732. My Calendar III</h3><p>题意就是找出重叠的最大的区间个数，至多多少个区间重叠。直接改造上面的代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyCalendarThree &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTreeMap&lt;Integer, Integer&gt; delta;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyCalendarThree() &#123;</span><br><span class=\"line\">         delta = <span class=\"keyword\">new</span> TreeMap();</span><br><span class=\"line\">         <span class=\"built_in\">max</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> book(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> <span class=\"built_in\">end</span>) &#123;</span><br><span class=\"line\">        delta.<span class=\"built_in\">put</span>(start, delta.getOrDefault(start, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        delta.<span class=\"built_in\">put</span>(<span class=\"built_in\">end</span>, delta.getOrDefault(<span class=\"built_in\">end</span>, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> active = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> d: delta.values()) &#123;</span><br><span class=\"line\">            active += d;</span><br><span class=\"line\">            <span class=\"built_in\">if</span> (active &gt; <span class=\"built_in\">max</span> ) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">max</span> = active;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>既然都是判断新来的区间和已有的是否有重叠，那么用第一题判断重叠的办法还是可以做的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>上面三道题最核心部分就是理解重叠区域的判断，只要正确判断了这个，那么很容易就可以解出来。至于后面边界计数的方法确实很巧妙，巧妙的方法理解起来也不是那么容易，但又很通用，确实需要慢慢消化一下。通过这几题还顺便用了一下TreeMap的api，平时几乎没用过，它的底层数据结构是红黑树，红黑树也是二叉查找树，所以自然而然就要用到它的排序性质，有机会深入TreeMap源码理解一下。</p>\n"},{"title":"Leetcode BST系列（二）","date":"2019-03-15T02:20:50.000Z","description":"Leetcode BST 938","_content":"\n### 938. Range Sum of BST\n题目大意是给定一个BST以及一个包括边界的范围，求在这个范围内所有节点值的和。继续中序遍历拿这个模板代码练习一遍，从小到大判断当前值是否在这个范围内，是的话就加，一次Accept。\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private int res = 0;\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        if(root == null) {\n            return res;\n        }\n        rangeSumBST(root.left, L, R);\n        if(root.val >= L && root.val <= R) {\n            res += root.val;\n        }\n        rangeSumBST(root.right, L, R);\n        return res;\n    }\n}\n```\n","source":"_posts/2019-03-15-BST系列（二）.md","raw":"---\ntitle: Leetcode BST系列（二）\ndate: 2019-03-15 10:20:50\ntags: [LeetCode,BST,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 938\n---\n\n### 938. Range Sum of BST\n题目大意是给定一个BST以及一个包括边界的范围，求在这个范围内所有节点值的和。继续中序遍历拿这个模板代码练习一遍，从小到大判断当前值是否在这个范围内，是的话就加，一次Accept。\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private int res = 0;\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        if(root == null) {\n            return res;\n        }\n        rangeSumBST(root.left, L, R);\n        if(root.val >= L && root.val <= R) {\n            res += root.val;\n        }\n        rangeSumBST(root.right, L, R);\n        return res;\n    }\n}\n```\n","slug":"BST系列（二）","published":1,"updated":"2019-03-18T02:11:03.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewo20006i0h6uzmxgtqn","content":"<h3 id=\"938-Range-Sum-of-BST\"><a href=\"#938-Range-Sum-of-BST\" class=\"headerlink\" title=\"938. Range Sum of BST\"></a>938. Range Sum of BST</h3><p>题目大意是给定一个BST以及一个包括边界的范围，求在这个范围内所有节点值的和。继续中序遍历拿这个模板代码练习一遍，从小到大判断当前值是否在这个范围内，是的话就加，一次Accept。<br><figure class=\"highlight vbscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition <span class=\"keyword\">for</span> a binary tree node.</span><br><span class=\"line\"> * <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TreeNode &#123;</span><br><span class=\"line\"> *     <span class=\"built_in\">int</span> val;</span><br><span class=\"line\"> *     TreeNode <span class=\"built_in\">left</span>;</span><br><span class=\"line\"> *     TreeNode <span class=\"built_in\">right</span>;</span><br><span class=\"line\"> *     TreeNode(<span class=\"built_in\">int</span> x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> rangeSumBST(TreeNode root, <span class=\"built_in\">int</span> L, <span class=\"built_in\">int</span> R) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            return res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rangeSumBST(root.<span class=\"built_in\">left</span>, L, R);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt;= L &amp;&amp; root.val &lt;= R) &#123;</span><br><span class=\"line\">            res += root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rangeSumBST(root.<span class=\"built_in\">right</span>, L, R);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"938-Range-Sum-of-BST\"><a href=\"#938-Range-Sum-of-BST\" class=\"headerlink\" title=\"938. Range Sum of BST\"></a>938. Range Sum of BST</h3><p>题目大意是给定一个BST以及一个包括边界的范围，求在这个范围内所有节点值的和。继续中序遍历拿这个模板代码练习一遍，从小到大判断当前值是否在这个范围内，是的话就加，一次Accept。<br><figure class=\"highlight vbscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition <span class=\"keyword\">for</span> a binary tree node.</span><br><span class=\"line\"> * <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> TreeNode &#123;</span><br><span class=\"line\"> *     <span class=\"built_in\">int</span> val;</span><br><span class=\"line\"> *     TreeNode <span class=\"built_in\">left</span>;</span><br><span class=\"line\"> *     TreeNode <span class=\"built_in\">right</span>;</span><br><span class=\"line\"> *     TreeNode(<span class=\"built_in\">int</span> x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> rangeSumBST(TreeNode root, <span class=\"built_in\">int</span> L, <span class=\"built_in\">int</span> R) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            return res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rangeSumBST(root.<span class=\"built_in\">left</span>, L, R);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt;= L &amp;&amp; root.val &lt;= R) &#123;</span><br><span class=\"line\">            res += root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rangeSumBST(root.<span class=\"built_in\">right</span>, L, R);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"LeetCode BST系列（四）","date":"2019-03-20T07:12:21.000Z","description":"Leetcode BST 217/219/220","_content":"\n### 217. Contains Duplicate\n题目大意是判读数组里是否有重复的数，有就返回true，没有返回false。题目很简单就用了O(N)时间的解法，HashSet的查找插入的平均时间复杂度都是O(1)，而BST查找插入的平均时间复杂度都是O(logN)，所以选择用了HashSet，其他解法就是先排序再比较也是ok的。\n```\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<>(n);\n        for(int t : nums) {\n            if (set.contains(t)) return true;\n            set.add(t);\n        } \n        return false;\n    }\n}\n```\n\n### 219. Contains Duplicate II\n题目大意是给定一个数组和一个整数k，判断数组中是否存在两个相等的数，且他们下标差值不大于k，存在返回true，不存在返回false。\n暴力解法直接两个for循环比较，时间复杂度O(N²)，能通过需要325ms，所以可以根据上一题的思路利用HashMap，key存放数组中的值，value存放下标。代码如下：\n\n```\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            if(map.containsKey(nums[i])) {\n                if(Math.abs(map.get(nums[i]) - i) <= k) {\n                    return true;\n                }\n            }\n            map.put(nums[i], i);\n        }\n        return false;\n    }\n}\n```\n\n时间复杂度为O(N), 通过只用了8ms，效率提升很明显。\n\n220. Contains Duplicate III\n上一题是数组两个值相等，这一题变成数组两个值相差最大不超过t，下标差不超过k，网上说暴力破解不行，我试了一下发现还是能通过的，唯一坑的地方在于int必须要转成long，不然好几个测试用例都会溢出通不过。\n\n```\n public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    int n = nums.length;\n    for(int i=0; i<n; i++) {\n        for(int j=i+1; j<n; j++) {\n            //System.out.println();\n            if(Math.abs(((long)nums[i] - (long)nums[j])) <= t && Math.abs(i - j) <= k) {\n                return true;\n            }\n        }\n        \n    }\n    return false;\n}\n```\n\n下面来看看利用平衡树时间复杂度为O(NlogN)的解法，这个解法利用了滑动窗口+TreeSet，我觉得很巧妙，首先TreeSet里面保证存放的是下标差值满足条件的数值，这就利用了滑动窗口每次新加入一个值的时候再剔除掉最边界的值，这样只需判断TreeSet中两个值的差值。在判断数值差值的时候用了数学的方式，|a-b| <= t，那么 b-t<= a <= b+t，于是可以先在TreeSet里找到一个满足大于等于nums[i]-t的最小值，然后再判断这个最小值是否小于等于nums[i]+t就可以了。\n\n```\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if(k<=0) return false;\n    TreeSet<Long> set = new TreeSet<Long>();\n    int n = nums.length;\n    for(int i=0; i<n; i++) {\n        Long x = set.ceiling((long)nums[i]-(long)t);\n       if(x != null && x <= (long)nums[i] + (long)t) return true;\n        if(i>=k) {\n            set.remove((long)nums[i-k]);\n        }\n        set.add((long)nums[i]);\n    }\n    return false;\n}\n```\n\n这里面每次要注意溢出的情况，所以都把int转成long。这题还有一个利用bucket（桶）时间复杂度只有O(N)的解法，理解起来还有点困难，暂时先把解法贴出来，希望可以有人讨论。\n\n```\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if(k <= 0 || t < 0) return false;\n    HashMap<Long, Long> keyToNum = new HashMap<>();\n    long div = (long)t + 1;\n    for (int i = 0; i < nums.length; i++) {\n        long num = (long)nums[i];\n        long key = num / div;\n        if(num < 0) key--;\n        if (keyToNum.containsKey(key)\n                || keyToNum.containsKey(key + 1) && keyToNum.get(key + 1) - num <= t\n                || keyToNum.containsKey(key - 1) && num - keyToNum.get(key - 1) <= t)\n            return true;\n        if (i >= k) keyToNum.remove(((long)nums[i - k]) / div);\n        keyToNum.put(key, num);\n    }\n    return false;\n}\n```","source":"_posts/2019-03-20-BST系列（四）.md","raw":"---\ntitle: LeetCode BST系列（四）\ndate: 2019-03-20 15:12:21\ntags: [LeetCode,BST,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 217/219/220\n---\n\n### 217. Contains Duplicate\n题目大意是判读数组里是否有重复的数，有就返回true，没有返回false。题目很简单就用了O(N)时间的解法，HashSet的查找插入的平均时间复杂度都是O(1)，而BST查找插入的平均时间复杂度都是O(logN)，所以选择用了HashSet，其他解法就是先排序再比较也是ok的。\n```\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<>(n);\n        for(int t : nums) {\n            if (set.contains(t)) return true;\n            set.add(t);\n        } \n        return false;\n    }\n}\n```\n\n### 219. Contains Duplicate II\n题目大意是给定一个数组和一个整数k，判断数组中是否存在两个相等的数，且他们下标差值不大于k，存在返回true，不存在返回false。\n暴力解法直接两个for循环比较，时间复杂度O(N²)，能通过需要325ms，所以可以根据上一题的思路利用HashMap，key存放数组中的值，value存放下标。代码如下：\n\n```\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            if(map.containsKey(nums[i])) {\n                if(Math.abs(map.get(nums[i]) - i) <= k) {\n                    return true;\n                }\n            }\n            map.put(nums[i], i);\n        }\n        return false;\n    }\n}\n```\n\n时间复杂度为O(N), 通过只用了8ms，效率提升很明显。\n\n220. Contains Duplicate III\n上一题是数组两个值相等，这一题变成数组两个值相差最大不超过t，下标差不超过k，网上说暴力破解不行，我试了一下发现还是能通过的，唯一坑的地方在于int必须要转成long，不然好几个测试用例都会溢出通不过。\n\n```\n public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    int n = nums.length;\n    for(int i=0; i<n; i++) {\n        for(int j=i+1; j<n; j++) {\n            //System.out.println();\n            if(Math.abs(((long)nums[i] - (long)nums[j])) <= t && Math.abs(i - j) <= k) {\n                return true;\n            }\n        }\n        \n    }\n    return false;\n}\n```\n\n下面来看看利用平衡树时间复杂度为O(NlogN)的解法，这个解法利用了滑动窗口+TreeSet，我觉得很巧妙，首先TreeSet里面保证存放的是下标差值满足条件的数值，这就利用了滑动窗口每次新加入一个值的时候再剔除掉最边界的值，这样只需判断TreeSet中两个值的差值。在判断数值差值的时候用了数学的方式，|a-b| <= t，那么 b-t<= a <= b+t，于是可以先在TreeSet里找到一个满足大于等于nums[i]-t的最小值，然后再判断这个最小值是否小于等于nums[i]+t就可以了。\n\n```\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if(k<=0) return false;\n    TreeSet<Long> set = new TreeSet<Long>();\n    int n = nums.length;\n    for(int i=0; i<n; i++) {\n        Long x = set.ceiling((long)nums[i]-(long)t);\n       if(x != null && x <= (long)nums[i] + (long)t) return true;\n        if(i>=k) {\n            set.remove((long)nums[i-k]);\n        }\n        set.add((long)nums[i]);\n    }\n    return false;\n}\n```\n\n这里面每次要注意溢出的情况，所以都把int转成long。这题还有一个利用bucket（桶）时间复杂度只有O(N)的解法，理解起来还有点困难，暂时先把解法贴出来，希望可以有人讨论。\n\n```\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if(k <= 0 || t < 0) return false;\n    HashMap<Long, Long> keyToNum = new HashMap<>();\n    long div = (long)t + 1;\n    for (int i = 0; i < nums.length; i++) {\n        long num = (long)nums[i];\n        long key = num / div;\n        if(num < 0) key--;\n        if (keyToNum.containsKey(key)\n                || keyToNum.containsKey(key + 1) && keyToNum.get(key + 1) - num <= t\n                || keyToNum.containsKey(key - 1) && num - keyToNum.get(key - 1) <= t)\n            return true;\n        if (i >= k) keyToNum.remove(((long)nums[i - k]) / div);\n        keyToNum.put(key, num);\n    }\n    return false;\n}\n```","slug":"BST系列（四）","published":1,"updated":"2019-03-25T02:32:28.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewo40007i0h6qbru1mjs","content":"<h3 id=\"217-Contains-Duplicate\"><a href=\"#217-Contains-Duplicate\" class=\"headerlink\" title=\"217. Contains Duplicate\"></a>217. Contains Duplicate</h3><p>题目大意是判读数组里是否有重复的数，有就返回true，没有返回false。题目很简单就用了O(N)时间的解法，HashSet的查找插入的平均时间复杂度都是O(1)，而BST查找插入的平均时间复杂度都是O(logN)，所以选择用了HashSet，其他解法就是先排序再比较也是ok的。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsDuplicate</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Set&lt;Integer&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> HashSet&lt;&gt;(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">set</span>.contains(t)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>(t);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"219-Contains-Duplicate-II\"><a href=\"#219-Contains-Duplicate-II\" class=\"headerlink\" title=\"219. Contains Duplicate II\"></a>219. Contains Duplicate II</h3><p>题目大意是给定一个数组和一个整数k，判断数组中是否存在两个相等的数，且他们下标差值不大于k，存在返回true，不存在返回false。<br>暴力解法直接两个for循环比较，时间复杂度O(N²)，能通过需要325ms，所以可以根据上一题的思路利用HashMap，key存放数组中的值，value存放下标。代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Math.<span class=\"built_in\">abs</span>(<span class=\"built_in\">map</span>.get(nums[i]) - i) &lt;= k) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为O(N), 通过只用了8ms，效率提升很明显。</p>\n<ol start=\"220\">\n<li>Contains Duplicate III<br>上一题是数组两个值相等，这一题变成数组两个值相差最大不超过t，下标差不超过k，网上说暴力破解不行，我试了一下发现还是能通过的，唯一坑的地方在于int必须要转成long，不然好几个测试用例都会溢出通不过。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyAlmostDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//System.out.println();</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Math.<span class=\"built_in\">abs</span>(((<span class=\"keyword\">long</span>)nums[i] - (<span class=\"keyword\">long</span>)nums[j])) &lt;= t &amp;&amp; Math.<span class=\"built_in\">abs</span>(i - j) &lt;= k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面来看看利用平衡树时间复杂度为O(NlogN)的解法，这个解法利用了滑动窗口+TreeSet，我觉得很巧妙，首先TreeSet里面保证存放的是下标差值满足条件的数值，这就利用了滑动窗口每次新加入一个值的时候再剔除掉最边界的值，这样只需判断TreeSet中两个值的差值。在判断数值差值的时候用了数学的方式，|a-b| &lt;= t，那么 b-t&lt;= a &lt;= b+t，于是可以先在TreeSet里找到一个满足大于等于nums[i]-t的最小值，然后再判断这个最小值是否小于等于nums[i]+t就可以了。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyAlmostDuplicate</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> t</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    TreeSet&lt;Long&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> TreeSet&lt;Long&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        Long x = <span class=\"keyword\">set</span>.ceiling((<span class=\"keyword\">long</span>)nums[i]-(<span class=\"keyword\">long</span>)t);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(x != <span class=\"literal\">null</span> &amp;&amp; x &lt;= (<span class=\"keyword\">long</span>)nums[i] + (<span class=\"keyword\">long</span>)t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.<span class=\"keyword\">remove</span>((<span class=\"keyword\">long</span>)nums[i-k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>((<span class=\"keyword\">long</span>)nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面每次要注意溢出的情况，所以都把int转成long。这题还有一个利用bucket（桶）时间复杂度只有O(N)的解法，理解起来还有点困难，暂时先把解法贴出来，希望可以有人讨论。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> containsNearbyAlmostDuplicate(<span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> k, <span class=\"built_in\">int</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k &lt;= <span class=\"number\">0</span> || t &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">HashMap</span>&lt;Long, Long&gt; keyToNum = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> div = (<span class=\"keyword\">long</span>)t + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> num = (<span class=\"keyword\">long</span>)nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">key</span> = num / div;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num &lt; <span class=\"number\">0</span>) <span class=\"built_in\">key</span>--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyToNum.containsKey(<span class=\"built_in\">key</span>)</span><br><span class=\"line\">                || keyToNum.containsKey(<span class=\"built_in\">key</span> + <span class=\"number\">1</span>) &amp;&amp; keyToNum.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span> + <span class=\"number\">1</span>) - num &lt;= t</span><br><span class=\"line\">                || keyToNum.containsKey(<span class=\"built_in\">key</span> - <span class=\"number\">1</span>) &amp;&amp; num - keyToNum.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span> - <span class=\"number\">1</span>) &lt;= t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= k) keyToNum.remove(((<span class=\"keyword\">long</span>)nums[i - k]) / div);</span><br><span class=\"line\">        keyToNum.put(<span class=\"built_in\">key</span>, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"217-Contains-Duplicate\"><a href=\"#217-Contains-Duplicate\" class=\"headerlink\" title=\"217. Contains Duplicate\"></a>217. Contains Duplicate</h3><p>题目大意是判读数组里是否有重复的数，有就返回true，没有返回false。题目很简单就用了O(N)时间的解法，HashSet的查找插入的平均时间复杂度都是O(1)，而BST查找插入的平均时间复杂度都是O(logN)，所以选择用了HashSet，其他解法就是先排序再比较也是ok的。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsDuplicate</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Set&lt;Integer&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> HashSet&lt;&gt;(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">set</span>.contains(t)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>(t);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"219-Contains-Duplicate-II\"><a href=\"#219-Contains-Duplicate-II\" class=\"headerlink\" title=\"219. Contains Duplicate II\"></a>219. Contains Duplicate II</h3><p>题目大意是给定一个数组和一个整数k，判断数组中是否存在两个相等的数，且他们下标差值不大于k，存在返回true，不存在返回false。<br>暴力解法直接两个for循环比较，时间复杂度O(N²)，能通过需要325ms，所以可以根据上一题的思路利用HashMap，key存放数组中的值，value存放下标。代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Math.<span class=\"built_in\">abs</span>(<span class=\"built_in\">map</span>.get(nums[i]) - i) &lt;= k) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为O(N), 通过只用了8ms，效率提升很明显。</p>\n<ol start=\"220\">\n<li>Contains Duplicate III<br>上一题是数组两个值相等，这一题变成数组两个值相差最大不超过t，下标差不超过k，网上说暴力破解不行，我试了一下发现还是能通过的，唯一坑的地方在于int必须要转成long，不然好几个测试用例都会溢出通不过。</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyAlmostDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//System.out.println();</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Math.<span class=\"built_in\">abs</span>(((<span class=\"keyword\">long</span>)nums[i] - (<span class=\"keyword\">long</span>)nums[j])) &lt;= t &amp;&amp; Math.<span class=\"built_in\">abs</span>(i - j) &lt;= k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面来看看利用平衡树时间复杂度为O(NlogN)的解法，这个解法利用了滑动窗口+TreeSet，我觉得很巧妙，首先TreeSet里面保证存放的是下标差值满足条件的数值，这就利用了滑动窗口每次新加入一个值的时候再剔除掉最边界的值，这样只需判断TreeSet中两个值的差值。在判断数值差值的时候用了数学的方式，|a-b| &lt;= t，那么 b-t&lt;= a &lt;= b+t，于是可以先在TreeSet里找到一个满足大于等于nums[i]-t的最小值，然后再判断这个最小值是否小于等于nums[i]+t就可以了。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> boolean <span class=\"title\">containsNearbyAlmostDuplicate</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> t</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    TreeSet&lt;Long&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> TreeSet&lt;Long&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">        Long x = <span class=\"keyword\">set</span>.ceiling((<span class=\"keyword\">long</span>)nums[i]-(<span class=\"keyword\">long</span>)t);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(x != <span class=\"literal\">null</span> &amp;&amp; x &lt;= (<span class=\"keyword\">long</span>)nums[i] + (<span class=\"keyword\">long</span>)t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">set</span>.<span class=\"keyword\">remove</span>((<span class=\"keyword\">long</span>)nums[i-k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>((<span class=\"keyword\">long</span>)nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面每次要注意溢出的情况，所以都把int转成long。这题还有一个利用bucket（桶）时间复杂度只有O(N)的解法，理解起来还有点困难，暂时先把解法贴出来，希望可以有人讨论。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> containsNearbyAlmostDuplicate(<span class=\"built_in\">int</span>[] nums, <span class=\"built_in\">int</span> k, <span class=\"built_in\">int</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k &lt;= <span class=\"number\">0</span> || t &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">HashMap</span>&lt;Long, Long&gt; keyToNum = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> div = (<span class=\"keyword\">long</span>)t + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> num = (<span class=\"keyword\">long</span>)nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"built_in\">key</span> = num / div;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num &lt; <span class=\"number\">0</span>) <span class=\"built_in\">key</span>--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyToNum.containsKey(<span class=\"built_in\">key</span>)</span><br><span class=\"line\">                || keyToNum.containsKey(<span class=\"built_in\">key</span> + <span class=\"number\">1</span>) &amp;&amp; keyToNum.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span> + <span class=\"number\">1</span>) - num &lt;= t</span><br><span class=\"line\">                || keyToNum.containsKey(<span class=\"built_in\">key</span> - <span class=\"number\">1</span>) &amp;&amp; num - keyToNum.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span> - <span class=\"number\">1</span>) &lt;= t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= k) keyToNum.remove(((<span class=\"keyword\">long</span>)nums[i - k]) / div);</span><br><span class=\"line\">        keyToNum.put(<span class=\"built_in\">key</span>, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java线程基础","date":"2019-03-18T02:11:45.000Z","description":"Java线程定义、创建、状态、各状态转换","_content":"\n## 定义\n> A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.\n\n一条线程指的是一个程序（进程）中执行的控制流，Java虚拟机允许一个应用程序并发执行多个线程。\n每一个线程都有一个优先级，优先级高的比低的先执行。每一个线程都有可能标记为守护线程，守护线程随主线程退出而退出。在线程中新建的线程与它创建时所在的线程有着同样的优先级，线程A中创建了一个线程B，那么B优先级等价于A，如果A是守护线程，那么B也是。\n## 线程状态\n> A thread can be in one of the following states:\n RUNNABLE: A thread executing in the Java virtual machine is in this state.\n  BLOCKED: A thread that is blocked waiting for a monitor lock is in this state.\n  WAITING: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.\nTIMED_WAITING: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.\nTERMINATED: A thread that has exited is in this state.\nA thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.\n\n这里面比较重要的就是阻塞和等待状态，当等待一个监视器锁的时候线程是处于阻塞状态的。下面是一个打印线程A状态的代码\n```\npublic class TestThread {\n\tfinal Object lock = new Object();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tTestThread t = new TestThread();\n\t\tThread b = new Thread(t.new ThreadB(), \"B\");\n\t\tb.start();\n\t\tThreadA a = t.new ThreadA();\n\t\ta.setName(\"A\");\n\t\tSystem.out.println(a.getState());  //NEW\n\t\ta.start();\n\t\tSystem.out.println(a.getState()); //RUNNABLE\n\t\tThread.sleep(1000);\n\t\tSystem.out.println(a.getState()); //BLOCKED\n\t\t\n\t}\n\n\tclass ThreadB implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tsynchronized (lock) {\n\t\t\t\t  System.out.println(Thread.currentThread().getName() + \" invoke\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(150000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tclass ThreadA extends Thread {\n\t\tpublic void run() {\n\t\t\tsynchronized (lock) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" invoke\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1500);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(200);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n```\n处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。处于等待状态的线程会等待另外一个线程处理特殊的行为。 \n有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间\n\n## 线程创建\n上面代码块的两个线程创建的方式就是不同的，两者最大区别的区别就是一个继承Thread，一个实现Runnable接口，Thread类本身也实现了Runnable接口，Java中没有多继承，所以能实现接口就实现接口，除非当你的线程需要Thread类中除了run方法以外的其它方法时，可以采用继承的方式创建。\n## 线程中断\n当线程对象调用interrupt()方法时中断，为线程设置一个中断标志。\n需要用isInterrupted()时刻判断线程中断的条件。\n当线程处于阻塞等待状态时中断，会抛出InterruptedException异常。\n","source":"_posts/2019-03-18-Java线程基础.md","raw":"---\ntitle: Java线程基础\ndate: 2019-03-18 10:11:45\ntags: [Java, Thread, 基础]\ncategory: Java\ndescription: Java线程定义、创建、状态、各状态转换\n---\n\n## 定义\n> A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.\n\n一条线程指的是一个程序（进程）中执行的控制流，Java虚拟机允许一个应用程序并发执行多个线程。\n每一个线程都有一个优先级，优先级高的比低的先执行。每一个线程都有可能标记为守护线程，守护线程随主线程退出而退出。在线程中新建的线程与它创建时所在的线程有着同样的优先级，线程A中创建了一个线程B，那么B优先级等价于A，如果A是守护线程，那么B也是。\n## 线程状态\n> A thread can be in one of the following states:\n RUNNABLE: A thread executing in the Java virtual machine is in this state.\n  BLOCKED: A thread that is blocked waiting for a monitor lock is in this state.\n  WAITING: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.\nTIMED_WAITING: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.\nTERMINATED: A thread that has exited is in this state.\nA thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.\n\n这里面比较重要的就是阻塞和等待状态，当等待一个监视器锁的时候线程是处于阻塞状态的。下面是一个打印线程A状态的代码\n```\npublic class TestThread {\n\tfinal Object lock = new Object();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tTestThread t = new TestThread();\n\t\tThread b = new Thread(t.new ThreadB(), \"B\");\n\t\tb.start();\n\t\tThreadA a = t.new ThreadA();\n\t\ta.setName(\"A\");\n\t\tSystem.out.println(a.getState());  //NEW\n\t\ta.start();\n\t\tSystem.out.println(a.getState()); //RUNNABLE\n\t\tThread.sleep(1000);\n\t\tSystem.out.println(a.getState()); //BLOCKED\n\t\t\n\t}\n\n\tclass ThreadB implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tsynchronized (lock) {\n\t\t\t\t  System.out.println(Thread.currentThread().getName() + \" invoke\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(150000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tclass ThreadA extends Thread {\n\t\tpublic void run() {\n\t\t\tsynchronized (lock) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \" invoke\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1500);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(200);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n```\n处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。处于等待状态的线程会等待另外一个线程处理特殊的行为。 \n有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间\n\n## 线程创建\n上面代码块的两个线程创建的方式就是不同的，两者最大区别的区别就是一个继承Thread，一个实现Runnable接口，Thread类本身也实现了Runnable接口，Java中没有多继承，所以能实现接口就实现接口，除非当你的线程需要Thread类中除了run方法以外的其它方法时，可以采用继承的方式创建。\n## 线程中断\n当线程对象调用interrupt()方法时中断，为线程设置一个中断标志。\n需要用isInterrupted()时刻判断线程中断的条件。\n当线程处于阻塞等待状态时中断，会抛出InterruptedException异常。\n","slug":"Java线程基础","published":1,"updated":"2019-08-14T06:55:17.503Z","_id":"cjzawewo60008i0h60sxaqyqf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p>\n</blockquote>\n<p>一条线程指的是一个程序（进程）中执行的控制流，Java虚拟机允许一个应用程序并发执行多个线程。<br>每一个线程都有一个优先级，优先级高的比低的先执行。每一个线程都有可能标记为守护线程，守护线程随主线程退出而退出。在线程中新建的线程与它创建时所在的线程有着同样的优先级，线程A中创建了一个线程B，那么B优先级等价于A，如果A是守护线程，那么B也是。</p>\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><blockquote>\n<p>A thread can be in one of the following states:<br> RUNNABLE: A thread executing in the Java virtual machine is in this state.<br>  BLOCKED: A thread that is blocked waiting for a monitor lock is in this state.<br>  WAITING: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.<br>TIMED_WAITING: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.<br>TERMINATED: A thread that has exited is in this state.<br>A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</p>\n</blockquote>\n<p>这里面比较重要的就是阻塞和等待状态，当等待一个监视器锁的时候线程是处于阻塞状态的。下面是一个打印线程A状态的代码<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestThread</span> &#123;</span><br><span class=\"line\">\tfinal Object <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class=\"line\">\t\tTestThread t = <span class=\"keyword\">new</span> TestThread();</span><br><span class=\"line\">\t\tThread b = <span class=\"keyword\">new</span> Thread(t.new ThreadB(), <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">\t\tb.start();</span><br><span class=\"line\">\t\tThreadA a = t.new ThreadA();</span><br><span class=\"line\">\t\ta.setName(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState());  <span class=\"comment\">//NEW</span></span><br><span class=\"line\">\t\ta.start();</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState()); <span class=\"comment\">//RUNNABLE</span></span><br><span class=\"line\">\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState()); <span class=\"comment\">//BLOCKED</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title\">ThreadB</span> <span class=\"title\">implements</span> <span class=\"title\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t\tsynchronized (<span class=\"keyword\">lock</span>) &#123;</span><br><span class=\"line\">\t\t\t\t  System.<span class=\"keyword\">out</span>.println(Thread.currentThread().getName() + <span class=\"string\">\" invoke\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">150000</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title\">ThreadA</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t\tsynchronized (<span class=\"keyword\">lock</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.<span class=\"keyword\">out</span>.println(Thread.currentThread().getName() + <span class=\"string\">\" invoke\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">1500</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。处于等待状态的线程会等待另外一个线程处理特殊的行为。<br>有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</p>\n<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p>上面代码块的两个线程创建的方式就是不同的，两者最大区别的区别就是一个继承Thread，一个实现Runnable接口，Thread类本身也实现了Runnable接口，Java中没有多继承，所以能实现接口就实现接口，除非当你的线程需要Thread类中除了run方法以外的其它方法时，可以采用继承的方式创建。</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>当线程对象调用interrupt()方法时中断，为线程设置一个中断标志。<br>需要用isInterrupted()时刻判断线程中断的条件。<br>当线程处于阻塞等待状态时中断，会抛出InterruptedException异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p>\n</blockquote>\n<p>一条线程指的是一个程序（进程）中执行的控制流，Java虚拟机允许一个应用程序并发执行多个线程。<br>每一个线程都有一个优先级，优先级高的比低的先执行。每一个线程都有可能标记为守护线程，守护线程随主线程退出而退出。在线程中新建的线程与它创建时所在的线程有着同样的优先级，线程A中创建了一个线程B，那么B优先级等价于A，如果A是守护线程，那么B也是。</p>\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><blockquote>\n<p>A thread can be in one of the following states:<br> RUNNABLE: A thread executing in the Java virtual machine is in this state.<br>  BLOCKED: A thread that is blocked waiting for a monitor lock is in this state.<br>  WAITING: A thread that is waiting indefinitely for another thread to perform a particular action is in this state.<br>TIMED_WAITING: A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.<br>TERMINATED: A thread that has exited is in this state.<br>A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</p>\n</blockquote>\n<p>这里面比较重要的就是阻塞和等待状态，当等待一个监视器锁的时候线程是处于阻塞状态的。下面是一个打印线程A状态的代码<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TestThread</span> &#123;</span><br><span class=\"line\">\tfinal Object <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class=\"line\">\t\tTestThread t = <span class=\"keyword\">new</span> TestThread();</span><br><span class=\"line\">\t\tThread b = <span class=\"keyword\">new</span> Thread(t.new ThreadB(), <span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">\t\tb.start();</span><br><span class=\"line\">\t\tThreadA a = t.new ThreadA();</span><br><span class=\"line\">\t\ta.setName(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState());  <span class=\"comment\">//NEW</span></span><br><span class=\"line\">\t\ta.start();</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState()); <span class=\"comment\">//RUNNABLE</span></span><br><span class=\"line\">\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\tSystem.<span class=\"keyword\">out</span>.println(a.getState()); <span class=\"comment\">//BLOCKED</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title\">ThreadB</span> <span class=\"title\">implements</span> <span class=\"title\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t\tsynchronized (<span class=\"keyword\">lock</span>) &#123;</span><br><span class=\"line\">\t\t\t\t  System.<span class=\"keyword\">out</span>.println(Thread.currentThread().getName() + <span class=\"string\">\" invoke\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">150000</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title\">ThreadA</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t\tsynchronized (<span class=\"keyword\">lock</span>) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.<span class=\"keyword\">out</span>.println(Thread.currentThread().getName() + <span class=\"string\">\" invoke\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">1500</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>处于等待状态的线程是由于执行了3个方法中的任意方法。 1. Object的wait方法，并且没有使用timeout参数; 2. Thread的join方法，没有使用timeout参数 3. LockSupport的park方法。处于等待状态的线程会等待另外一个线程处理特殊的行为。<br>有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 1. Thread.sleep方法 2. Object的wait方法，带有时间 3. Thread.join方法，带有时间 4. LockSupport的parkNanos方法，带有时间 5. LockSupport的parkUntil方法，带有时间</p>\n<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p>上面代码块的两个线程创建的方式就是不同的，两者最大区别的区别就是一个继承Thread，一个实现Runnable接口，Thread类本身也实现了Runnable接口，Java中没有多继承，所以能实现接口就实现接口，除非当你的线程需要Thread类中除了run方法以外的其它方法时，可以采用继承的方式创建。</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>当线程对象调用interrupt()方法时中断，为线程设置一个中断标志。<br>需要用isInterrupted()时刻判断线程中断的条件。<br>当线程处于阻塞等待状态时中断，会抛出InterruptedException异常。</p>\n"},{"title":"LeetCode BST系列（五）","date":"2019-03-25T02:31:40.000Z","description":"Leetcode BST 315","_content":"\n### 315. Count of Smaller Numbers After Self\n题目大意是给定一个数组，要求输出一个数组，输出的数组要求是：统计原数组每个数值右边比它小的个数，然后记录到输出的数组中。\n>Input: [5,2,6,1]\nOutput: [2,1,1,0] \nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n\n首先尝试了暴力解法，这是最容易想到的解法了，竟然能过，可见测试的数组长度还不是很大。\n\n```\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            int k = 0;\n            for(int j = i+1; j<n; j++) {\n                if(nums[j] < nums[i]) {\n                    k++;\n                }\n            }\n            res.add(k);\n        }\n        return res;        \n    }\n}\n```\n\nO(n²)的解法显然不是最好的，于是看了一下Discuss，选了下面这个符合BST系列的解法。首先一定要倒序遍历原数组开始构造BST，这样构造树的时候能记录所有比它小的节点的个数。至于如何记录的，就是维护两个数值，一个值是当前节点的个数（selfCount），当节点重复时，这个值便递增+1，默认是1。另一个值是所有比当前节点小的节点的个数（leftCount）。这样每次新来一个节点，当需要往右分支插入的时候，那说明比当前节点大，于是新的节点需要加上当前节点的leftCount和selfCount，而往左分支插入的时候是比当前节点小，那么当前节点需要增加一下自身的leftCount。\n\n```\nclass Solution {\n    class Node {\n        Node left;\n        Node right;\n        int val;\n        int selfCount = 1;  //自身重复节点个数\n        int leftCount;      //所有比自己小的节点个数\n        public Node(int val, int left) {\n            this.leftCount = left;\n            this.val = val;\n        }\n    }\n    \n    public List<Integer> countSmaller(int[] nums) {\n        Integer[] res = new Integer[nums.length];\n        Node node = null;  //返回的永远是根节点\n        for(int i=nums.length - 1; i>=0; i--) {\n            node = insert(nums[i], res, i, node, 0);\n        }\n        return Arrays.asList(res);\n    }\n    public Node insert(int val, Integer[] res, int i, Node t, int leftCount) {\n        if(t == null) {\n             t = new Node(val, 0);\n            res[i] = leftCount;\n        } else if(t.val == val) {\n            t.selfCount++; \n            res[i] = t.leftCount + leftCount;\n        } else if(t.val > val) {\n            t.leftCount++;\n            t.left = insert(val, res, i, t.left, leftCount);\n        } else {\n            t.right = insert(val, res, i, t.right, t.leftCount + t.selfCount + leftCount);  \n            \t\t\t\t\t//t.leftCount 当前节点所有比它小的节点个数\n            \t\t\t\t\t//t.selfCount 自身节点个数， \n            \t\t\t\t\t//leftCount在t节点之前所有满足条件的节点个数\n        }\n        return t;\n    }\n    \n}\n```\n\n通过这道题主要是练习了一下构造BST的方法，通过记录节点状态来很好的避免之前暴力解法时重复性的比较工作，所以还是要牢记并利用好BST的性质。当然这道题还有个很巧妙的利用Fenwick Tree（Binary Indexed Tree）的解法，思路令人惊叹，我看的是花花酱的讲解。\n<https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/>。","source":"_posts/2019-03-25-BST系列（五）.md","raw":"---\ntitle: LeetCode BST系列（五）\ndate: 2019-03-25 10:31:40\ntags: [LeetCode,BST,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 315\n---\n\n### 315. Count of Smaller Numbers After Self\n题目大意是给定一个数组，要求输出一个数组，输出的数组要求是：统计原数组每个数值右边比它小的个数，然后记录到输出的数组中。\n>Input: [5,2,6,1]\nOutput: [2,1,1,0] \nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n\n首先尝试了暴力解法，这是最容易想到的解法了，竟然能过，可见测试的数组长度还不是很大。\n\n```\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            int k = 0;\n            for(int j = i+1; j<n; j++) {\n                if(nums[j] < nums[i]) {\n                    k++;\n                }\n            }\n            res.add(k);\n        }\n        return res;        \n    }\n}\n```\n\nO(n²)的解法显然不是最好的，于是看了一下Discuss，选了下面这个符合BST系列的解法。首先一定要倒序遍历原数组开始构造BST，这样构造树的时候能记录所有比它小的节点的个数。至于如何记录的，就是维护两个数值，一个值是当前节点的个数（selfCount），当节点重复时，这个值便递增+1，默认是1。另一个值是所有比当前节点小的节点的个数（leftCount）。这样每次新来一个节点，当需要往右分支插入的时候，那说明比当前节点大，于是新的节点需要加上当前节点的leftCount和selfCount，而往左分支插入的时候是比当前节点小，那么当前节点需要增加一下自身的leftCount。\n\n```\nclass Solution {\n    class Node {\n        Node left;\n        Node right;\n        int val;\n        int selfCount = 1;  //自身重复节点个数\n        int leftCount;      //所有比自己小的节点个数\n        public Node(int val, int left) {\n            this.leftCount = left;\n            this.val = val;\n        }\n    }\n    \n    public List<Integer> countSmaller(int[] nums) {\n        Integer[] res = new Integer[nums.length];\n        Node node = null;  //返回的永远是根节点\n        for(int i=nums.length - 1; i>=0; i--) {\n            node = insert(nums[i], res, i, node, 0);\n        }\n        return Arrays.asList(res);\n    }\n    public Node insert(int val, Integer[] res, int i, Node t, int leftCount) {\n        if(t == null) {\n             t = new Node(val, 0);\n            res[i] = leftCount;\n        } else if(t.val == val) {\n            t.selfCount++; \n            res[i] = t.leftCount + leftCount;\n        } else if(t.val > val) {\n            t.leftCount++;\n            t.left = insert(val, res, i, t.left, leftCount);\n        } else {\n            t.right = insert(val, res, i, t.right, t.leftCount + t.selfCount + leftCount);  \n            \t\t\t\t\t//t.leftCount 当前节点所有比它小的节点个数\n            \t\t\t\t\t//t.selfCount 自身节点个数， \n            \t\t\t\t\t//leftCount在t节点之前所有满足条件的节点个数\n        }\n        return t;\n    }\n    \n}\n```\n\n通过这道题主要是练习了一下构造BST的方法，通过记录节点状态来很好的避免之前暴力解法时重复性的比较工作，所以还是要牢记并利用好BST的性质。当然这道题还有个很巧妙的利用Fenwick Tree（Binary Indexed Tree）的解法，思路令人惊叹，我看的是花花酱的讲解。\n<https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/>。","slug":"BST系列（五）","published":1,"updated":"2019-03-25T04:13:39.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewob000bi0h6y6tztua4","content":"<h3 id=\"315-Count-of-Smaller-Numbers-After-Self\"><a href=\"#315-Count-of-Smaller-Numbers-After-Self\" class=\"headerlink\" title=\"315. Count of Smaller Numbers After Self\"></a>315. Count of Smaller Numbers After Self</h3><p>题目大意是给定一个数组，要求输出一个数组，输出的数组要求是：统计原数组每个数值右边比它小的个数，然后记录到输出的数组中。</p>\n<blockquote>\n<p>Input: [5,2,6,1]<br>Output: [2,1,1,0]<br>Explanation:<br>To the right of 5 there are 2 smaller elements (2 and 1).<br>To the right of 2 there is only 1 smaller element (1).<br>To the right of 6 there is 1 smaller element (1).<br>To the right of 1 there is 0 smaller element.</p>\n</blockquote>\n<p>首先尝试了暴力解法，这是最容易想到的解法了，竟然能过，可见测试的数组长度还不是很大。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">countSmaller</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.<span class=\"keyword\">add</span>(k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>O(n²)的解法显然不是最好的，于是看了一下Discuss，选了下面这个符合BST系列的解法。首先一定要倒序遍历原数组开始构造BST，这样构造树的时候能记录所有比它小的节点的个数。至于如何记录的，就是维护两个数值，一个值是当前节点的个数（selfCount），当节点重复时，这个值便递增+1，默认是1。另一个值是所有比当前节点小的节点的个数（leftCount）。这样每次新来一个节点，当需要往右分支插入的时候，那说明比当前节点大，于是新的节点需要加上当前节点的leftCount和selfCount，而往左分支插入的时候是比当前节点小，那么当前节点需要增加一下自身的leftCount。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        Node left;</span><br><span class=\"line\">        Node right;</span><br><span class=\"line\">        int <span class=\"keyword\">val</span>;</span><br><span class=\"line\">        int selfCount = <span class=\"number\">1</span>;  <span class=\"comment\">//自身重复节点个数</span></span><br><span class=\"line\">        int leftCount;      <span class=\"comment\">//所有比自己小的节点个数</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node(int <span class=\"keyword\">val</span>, int left) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.leftCount = left;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.<span class=\"keyword\">val</span> = <span class=\"keyword\">val</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class=\"line\">        Integer[] res = new Integer[nums.length];</span><br><span class=\"line\">        Node node = <span class=\"literal\">null</span>;  <span class=\"comment\">//返回的永远是根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=nums.length - <span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            node = insert(nums[i], res, i, node, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.asList(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node insert(int <span class=\"keyword\">val</span>, Integer[] res, int i, Node t, int leftCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             t = new Node(<span class=\"keyword\">val</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            res[i] = leftCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t.<span class=\"keyword\">val</span> == <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">            t.selfCount++; </span><br><span class=\"line\">            res[i] = t.leftCount + leftCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t.<span class=\"keyword\">val</span> &gt; <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">            t.leftCount++;</span><br><span class=\"line\">            t.left = insert(<span class=\"keyword\">val</span>, res, i, t.left, leftCount);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            t.right = insert(<span class=\"keyword\">val</span>, res, i, t.right, t.leftCount + t.selfCount + leftCount);  </span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//t.leftCount 当前节点所有比它小的节点个数</span></span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//t.selfCount 自身节点个数， </span></span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//leftCount在t节点之前所有满足条件的节点个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这道题主要是练习了一下构造BST的方法，通过记录节点状态来很好的避免之前暴力解法时重复性的比较工作，所以还是要牢记并利用好BST的性质。当然这道题还有个很巧妙的利用Fenwick Tree（Binary Indexed Tree）的解法，思路令人惊叹，我看的是花花酱的讲解。<br><a href=\"https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"315-Count-of-Smaller-Numbers-After-Self\"><a href=\"#315-Count-of-Smaller-Numbers-After-Self\" class=\"headerlink\" title=\"315. Count of Smaller Numbers After Self\"></a>315. Count of Smaller Numbers After Self</h3><p>题目大意是给定一个数组，要求输出一个数组，输出的数组要求是：统计原数组每个数值右边比它小的个数，然后记录到输出的数组中。</p>\n<blockquote>\n<p>Input: [5,2,6,1]<br>Output: [2,1,1,0]<br>Explanation:<br>To the right of 5 there are 2 smaller elements (2 and 1).<br>To the right of 2 there is only 1 smaller element (1).<br>To the right of 6 there is 1 smaller element (1).<br>To the right of 1 there is 0 smaller element.</p>\n</blockquote>\n<p>首先尝试了暴力解法，这是最容易想到的解法了，竟然能过，可见测试的数组长度还不是很大。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">countSmaller</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class=\"line\">                    k++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.<span class=\"keyword\">add</span>(k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>O(n²)的解法显然不是最好的，于是看了一下Discuss，选了下面这个符合BST系列的解法。首先一定要倒序遍历原数组开始构造BST，这样构造树的时候能记录所有比它小的节点的个数。至于如何记录的，就是维护两个数值，一个值是当前节点的个数（selfCount），当节点重复时，这个值便递增+1，默认是1。另一个值是所有比当前节点小的节点的个数（leftCount）。这样每次新来一个节点，当需要往右分支插入的时候，那说明比当前节点大，于是新的节点需要加上当前节点的leftCount和selfCount，而往左分支插入的时候是比当前节点小，那么当前节点需要增加一下自身的leftCount。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        Node left;</span><br><span class=\"line\">        Node right;</span><br><span class=\"line\">        int <span class=\"keyword\">val</span>;</span><br><span class=\"line\">        int selfCount = <span class=\"number\">1</span>;  <span class=\"comment\">//自身重复节点个数</span></span><br><span class=\"line\">        int leftCount;      <span class=\"comment\">//所有比自己小的节点个数</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node(int <span class=\"keyword\">val</span>, int left) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.leftCount = left;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.<span class=\"keyword\">val</span> = <span class=\"keyword\">val</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; countSmaller(int[] nums) &#123;</span><br><span class=\"line\">        Integer[] res = new Integer[nums.length];</span><br><span class=\"line\">        Node node = <span class=\"literal\">null</span>;  <span class=\"comment\">//返回的永远是根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=nums.length - <span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            node = insert(nums[i], res, i, node, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.asList(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node insert(int <span class=\"keyword\">val</span>, Integer[] res, int i, Node t, int leftCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             t = new Node(<span class=\"keyword\">val</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            res[i] = leftCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t.<span class=\"keyword\">val</span> == <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">            t.selfCount++; </span><br><span class=\"line\">            res[i] = t.leftCount + leftCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t.<span class=\"keyword\">val</span> &gt; <span class=\"keyword\">val</span>) &#123;</span><br><span class=\"line\">            t.leftCount++;</span><br><span class=\"line\">            t.left = insert(<span class=\"keyword\">val</span>, res, i, t.left, leftCount);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            t.right = insert(<span class=\"keyword\">val</span>, res, i, t.right, t.leftCount + t.selfCount + leftCount);  </span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//t.leftCount 当前节点所有比它小的节点个数</span></span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//t.selfCount 自身节点个数， </span></span><br><span class=\"line\">            \t\t\t\t\t<span class=\"comment\">//leftCount在t节点之前所有满足条件的节点个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这道题主要是练习了一下构造BST的方法，通过记录节点状态来很好的避免之前暴力解法时重复性的比较工作，所以还是要牢记并利用好BST的性质。当然这道题还有个很巧妙的利用Fenwick Tree（Binary Indexed Tree）的解法，思路令人惊叹，我看的是花花酱的讲解。<br><a href=\"https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/\" target=\"_blank\" rel=\"noopener\">https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/</a>。</p>\n"},{"title":"LeetCode Heap系列（二）","date":"2019-04-01T02:29:07.000Z","description":"Leetcode BST 378/215/692","_content":"\n### 378. Kth Smallest Element in a Sorted Matrix\n题目大意是给定一个n×n的矩阵，每行每列都是从小到大的顺序，找出矩阵中第k小的元素。\n利用优先队列的性质，将每个矩阵中的元素放入，第k小就是第n×n-k+1大，模板代码来一遍，然后就是O(n²)的时间复杂度。\n```\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                q.add(matrix[i][j]);\n                if(q.size() > n*n - k + 1) {\n                    q.poll();\n                }\n            }\n        }\n        return  q.peek();\n           \n    }\n}\n```\n\n这种解法很明显漏掉了每行每列排序的性质，所以即便没排序的矩阵都是ok的。那么这两个关键性质该怎么用，discuss里有人找到了论文\n<https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).>\n只能先做个笔记，希望有人讨论讨论。\n\n### 215. Kth Largest Element in an Array\n题目大意是找到数组中第k大的元素，几乎和703的题目一样，还是模板代码。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for(int i=0; i<n; i++) {\n            q.add(nums[i]);\n            if(q.size() > k) {\n                q.poll();\n            }\n        }\n        return q.peek();\n    }\n}\n```\n\n但是这一题是一个数组，那么在一个有序的数组中找第几大不是很容易的事吗？那么我们就可以排序再找。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        return nums[n-k];\n    }\n}\n```\n\n最后看到一个根据快速排序思路的解法，觉得也挺好的，顺路再理解一遍快排的算法。在快排中，第一步是先选取一个基准数，一般都以第一个作为基准数，然后从两头开始都和这个基准数比较。因为是找第几大，那么就从大到小排序，把所有比基准数大的放其左侧，比基准数小的放其右边，当这一步操作完成后，基准数就该被排序好了，那么此时只要比较它的下标和k-1（第k大在数组中就是第k-1）是否一致，如果一致那么就是要找的，说明最好的情况只需要O(n)的时间复杂度。如果不一致那么只需要在一侧再去找，这就又有了二分的思想。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n\t\tint low = 0;\n\t\tint high = nums.length - 1;\n\t\twhile (low < high) {\n\t\t\tint j = partition(nums, low, high);\n        \n\t\t\tif (j < k-1) {   //从右侧找\n\t\t\t\tlow = j + 1;\n\t\t\t} else if (j > k-1) {  //从左侧找\n\t\t\t\thigh = j - 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn nums[k-1];\n\t}\n\n\tpublic int partition(int[] a, int low, int high) {\n\t\tint i = low;\n\t\tint j = high+1;\n\t\twhile(i < j) {\n\t\t\twhile(a[++i]>a[low] && i < high);   //从左开始找比基准数小的\n\t\t\twhile(a[--j]<a[low] && j > 0);      //从右开始找比基准数大的\n\t\t\tif(i<j) swap(a, i, j);\n\t\t}\n      swap(a, low, j);\n\t\treturn j;\n\t}\n\n\tpublic void swap(int[] a, int i, int j) {\n\t\tint temp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n}\n```\n\n### 692. Top K Frequent Words\n题目大意是找到前k个出现频率最高的单词，按照频率从大到小排，如果频率相同就按单词字母从小到大的顺序，小字母开头的在前。\n继续利用HashMap+优先队列，继续模板代码。\n```\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> map = new HashMap<>();\n        for(String w : words) {\n            map.put(w, map.getOrDefault(w, 0) + 1);    \n        }\n        PriorityQueue<String> q = new PriorityQueue<>(\n            (a, b)-> {if(map.get(a) == map.get(b)) return b.compareTo(a); //字母大的排前面\n\t        else return map.get(a) - map.get(b);}); //频次小的排前面\n        for(String w : map.keySet()) {\n            q.add(w);\n            if(q.size() > k) {\n                q.poll();\n            }\n        }\n        List<String> res = new ArrayList<>();\n        while(!q.isEmpty()) {\n            res.add(q.poll());\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 总结\n做了这么多前k个问题的题目，对最小堆（优先队列）有了一定的认识，其实前k个题目都可以转成排序的问题来做，我个人的理解是转成排序的话就是完全排序，每个元素都是排好的，那么问题都好解决，就比如前k个的问题其实并不需要完全排序，只需要粗略排，比如优先队列中头部元素永远是最大或者最小的，那么可能多余的操作就不必要了。堆的本质还是一个二叉树，父节点永远比子节点大（小）。","source":"_posts/2019-04-01-Heap系列（二）.md","raw":"---\ntitle: LeetCode Heap系列（二）\ndate: 2019-04-01 10:29:07\ntags: [LeetCode,Heap,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 378/215/692\n---\n\n### 378. Kth Smallest Element in a Sorted Matrix\n题目大意是给定一个n×n的矩阵，每行每列都是从小到大的顺序，找出矩阵中第k小的元素。\n利用优先队列的性质，将每个矩阵中的元素放入，第k小就是第n×n-k+1大，模板代码来一遍，然后就是O(n²)的时间复杂度。\n```\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                q.add(matrix[i][j]);\n                if(q.size() > n*n - k + 1) {\n                    q.poll();\n                }\n            }\n        }\n        return  q.peek();\n           \n    }\n}\n```\n\n这种解法很明显漏掉了每行每列排序的性质，所以即便没排序的矩阵都是ok的。那么这两个关键性质该怎么用，discuss里有人找到了论文\n<https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).>\n只能先做个笔记，希望有人讨论讨论。\n\n### 215. Kth Largest Element in an Array\n题目大意是找到数组中第k大的元素，几乎和703的题目一样，还是模板代码。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for(int i=0; i<n; i++) {\n            q.add(nums[i]);\n            if(q.size() > k) {\n                q.poll();\n            }\n        }\n        return q.peek();\n    }\n}\n```\n\n但是这一题是一个数组，那么在一个有序的数组中找第几大不是很容易的事吗？那么我们就可以排序再找。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        return nums[n-k];\n    }\n}\n```\n\n最后看到一个根据快速排序思路的解法，觉得也挺好的，顺路再理解一遍快排的算法。在快排中，第一步是先选取一个基准数，一般都以第一个作为基准数，然后从两头开始都和这个基准数比较。因为是找第几大，那么就从大到小排序，把所有比基准数大的放其左侧，比基准数小的放其右边，当这一步操作完成后，基准数就该被排序好了，那么此时只要比较它的下标和k-1（第k大在数组中就是第k-1）是否一致，如果一致那么就是要找的，说明最好的情况只需要O(n)的时间复杂度。如果不一致那么只需要在一侧再去找，这就又有了二分的思想。\n```\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n\t\tint low = 0;\n\t\tint high = nums.length - 1;\n\t\twhile (low < high) {\n\t\t\tint j = partition(nums, low, high);\n        \n\t\t\tif (j < k-1) {   //从右侧找\n\t\t\t\tlow = j + 1;\n\t\t\t} else if (j > k-1) {  //从左侧找\n\t\t\t\thigh = j - 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn nums[k-1];\n\t}\n\n\tpublic int partition(int[] a, int low, int high) {\n\t\tint i = low;\n\t\tint j = high+1;\n\t\twhile(i < j) {\n\t\t\twhile(a[++i]>a[low] && i < high);   //从左开始找比基准数小的\n\t\t\twhile(a[--j]<a[low] && j > 0);      //从右开始找比基准数大的\n\t\t\tif(i<j) swap(a, i, j);\n\t\t}\n      swap(a, low, j);\n\t\treturn j;\n\t}\n\n\tpublic void swap(int[] a, int i, int j) {\n\t\tint temp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n}\n```\n\n### 692. Top K Frequent Words\n题目大意是找到前k个出现频率最高的单词，按照频率从大到小排，如果频率相同就按单词字母从小到大的顺序，小字母开头的在前。\n继续利用HashMap+优先队列，继续模板代码。\n```\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> map = new HashMap<>();\n        for(String w : words) {\n            map.put(w, map.getOrDefault(w, 0) + 1);    \n        }\n        PriorityQueue<String> q = new PriorityQueue<>(\n            (a, b)-> {if(map.get(a) == map.get(b)) return b.compareTo(a); //字母大的排前面\n\t        else return map.get(a) - map.get(b);}); //频次小的排前面\n        for(String w : map.keySet()) {\n            q.add(w);\n            if(q.size() > k) {\n                q.poll();\n            }\n        }\n        List<String> res = new ArrayList<>();\n        while(!q.isEmpty()) {\n            res.add(q.poll());\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 总结\n做了这么多前k个问题的题目，对最小堆（优先队列）有了一定的认识，其实前k个题目都可以转成排序的问题来做，我个人的理解是转成排序的话就是完全排序，每个元素都是排好的，那么问题都好解决，就比如前k个的问题其实并不需要完全排序，只需要粗略排，比如优先队列中头部元素永远是最大或者最小的，那么可能多余的操作就不必要了。堆的本质还是一个二叉树，父节点永远比子节点大（小）。","slug":"Heap系列（二）","published":1,"updated":"2019-04-02T09:01:20.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewod000ci0h6m8oed4xo","content":"<h3 id=\"378-Kth-Smallest-Element-in-a-Sorted-Matrix\"><a href=\"#378-Kth-Smallest-Element-in-a-Sorted-Matrix\" class=\"headerlink\" title=\"378. Kth Smallest Element in a Sorted Matrix\"></a>378. Kth Smallest Element in a Sorted Matrix</h3><p>题目大意是给定一个n×n的矩阵，每行每列都是从小到大的顺序，找出矩阵中第k小的元素。<br>利用优先队列的性质，将每个矩阵中的元素放入，第k小就是第n×n-k+1大，模板代码来一遍，然后就是O(n²)的时间复杂度。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span>(<span class=\"params\"><span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.length;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">                q.<span class=\"keyword\">add</span>(matrix[i][j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.size() &gt; n*n - k + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    q.poll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  q.peek();</span><br><span class=\"line\">           </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种解法很明显漏掉了每行每列排序的性质，所以即便没排序的矩阵都是ok的。那么这两个关键性质该怎么用，discuss里有人找到了论文<br><a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).</a><br>只能先做个笔记，希望有人讨论讨论。</p>\n<h3 id=\"215-Kth-Largest-Element-in-an-Array\"><a href=\"#215-Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"215. Kth Largest Element in an Array\"></a>215. Kth Largest Element in an Array</h3><p>题目大意是找到数组中第k大的元素，几乎和703的题目一样，还是模板代码。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            q.<span class=\"keyword\">add</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.size() &gt; k) &#123;</span><br><span class=\"line\">                q.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这一题是一个数组，那么在一个有序的数组中找第几大不是很容易的事吗？那么我们就可以排序再找。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[n-k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后看到一个根据快速排序思路的解法，觉得也挺好的，顺路再理解一遍快排的算法。在快排中，第一步是先选取一个基准数，一般都以第一个作为基准数，然后从两头开始都和这个基准数比较。因为是找第几大，那么就从大到小排序，把所有比基准数大的放其左侧，比基准数小的放其右边，当这一步操作完成后，基准数就该被排序好了，那么此时只要比较它的下标和k-1（第k大在数组中就是第k-1）是否一致，如果一致那么就是要找的，说明最好的情况只需要O(n)的时间复杂度。如果不一致那么只需要在一侧再去找，这就又有了二分的思想。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> high = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> j = partition(nums, low, high);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j &lt; k<span class=\"number\">-1</span>) &#123;   <span class=\"comment\">//从右侧找</span></span><br><span class=\"line\">\t\t\t\tlow = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt; k<span class=\"number\">-1</span>) &#123;  <span class=\"comment\">//从左侧找</span></span><br><span class=\"line\">\t\t\t\thigh = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = high+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(a[++i]&gt;a[low] &amp;&amp; i &lt; high);   <span class=\"comment\">//从左开始找比基准数小的</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(a[--j]&lt;a[low] &amp;&amp; j &gt; <span class=\"number\">0</span>);      <span class=\"comment\">//从右开始找比基准数大的</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&lt;j) swap(a, i, j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      swap(a, low, j);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">\t\ta[j] = a[i];</span><br><span class=\"line\">\t\ta[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"692-Top-K-Frequent-Words\"><a href=\"#692-Top-K-Frequent-Words\" class=\"headerlink\" title=\"692. Top K Frequent Words\"></a>692. Top K Frequent Words</h3><p>题目大意是找到前k个出现频率最高的单词，按照频率从大到小排，如果频率相同就按单词字母从小到大的顺序，小字母开头的在前。<br>继续利用HashMap+优先队列，继续模板代码。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">String</span>&gt; topKFrequent(<span class=\"keyword\">String</span>[] words, <span class=\"built_in\">int</span> k) &#123;</span><br><span class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, Integer&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> w : words) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.put(w, <span class=\"built_in\">map</span>.getOrDefault(w, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PriorityQueue&lt;<span class=\"keyword\">String</span>&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(</span><br><span class=\"line\">            (a, b)-&gt; &#123;<span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(a) == <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(b)) <span class=\"keyword\">return</span> b.compareTo(a); <span class=\"comment\">//字母大的排前面</span></span><br><span class=\"line\">\t        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(a) - <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(b);&#125;); <span class=\"comment\">//频次小的排前面</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> w : <span class=\"built_in\">map</span>.keySet()) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">add</span>(w);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">size</span>() &gt; k) &#123;</span><br><span class=\"line\">                q.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">String</span>&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">add</span>(q.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.<span class=\"built_in\">reverse</span>(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>做了这么多前k个问题的题目，对最小堆（优先队列）有了一定的认识，其实前k个题目都可以转成排序的问题来做，我个人的理解是转成排序的话就是完全排序，每个元素都是排好的，那么问题都好解决，就比如前k个的问题其实并不需要完全排序，只需要粗略排，比如优先队列中头部元素永远是最大或者最小的，那么可能多余的操作就不必要了。堆的本质还是一个二叉树，父节点永远比子节点大（小）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"378-Kth-Smallest-Element-in-a-Sorted-Matrix\"><a href=\"#378-Kth-Smallest-Element-in-a-Sorted-Matrix\" class=\"headerlink\" title=\"378. Kth Smallest Element in a Sorted Matrix\"></a>378. Kth Smallest Element in a Sorted Matrix</h3><p>题目大意是给定一个n×n的矩阵，每行每列都是从小到大的顺序，找出矩阵中第k小的元素。<br>利用优先队列的性质，将每个矩阵中的元素放入，第k小就是第n×n-k+1大，模板代码来一遍，然后就是O(n²)的时间复杂度。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span>(<span class=\"params\"><span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.length;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++) &#123;</span><br><span class=\"line\">                q.<span class=\"keyword\">add</span>(matrix[i][j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q.size() &gt; n*n - k + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    q.poll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  q.peek();</span><br><span class=\"line\">           </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种解法很明显漏掉了每行每列排序的性质，所以即便没排序的矩阵都是ok的。那么这两个关键性质该怎么用，discuss里有人找到了论文<br><a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).</a><br>只能先做个笔记，希望有人讨论讨论。</p>\n<h3 id=\"215-Kth-Largest-Element-in-an-Array\"><a href=\"#215-Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"215. Kth Largest Element in an Array\"></a>215. Kth Largest Element in an Array</h3><p>题目大意是找到数组中第k大的元素，几乎和703的题目一样，还是模板代码。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span>(<span class=\"params\"><span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            q.<span class=\"keyword\">add</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.size() &gt; k) &#123;</span><br><span class=\"line\">                q.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这一题是一个数组，那么在一个有序的数组中找第几大不是很容易的事吗？那么我们就可以排序再找。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[n-k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后看到一个根据快速排序思路的解法，觉得也挺好的，顺路再理解一遍快排的算法。在快排中，第一步是先选取一个基准数，一般都以第一个作为基准数，然后从两头开始都和这个基准数比较。因为是找第几大，那么就从大到小排序，把所有比基准数大的放其左侧，比基准数小的放其右边，当这一步操作完成后，基准数就该被排序好了，那么此时只要比较它的下标和k-1（第k大在数组中就是第k-1）是否一致，如果一致那么就是要找的，说明最好的情况只需要O(n)的时间复杂度。如果不一致那么只需要在一侧再去找，这就又有了二分的思想。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> high = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> j = partition(nums, low, high);</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j &lt; k<span class=\"number\">-1</span>) &#123;   <span class=\"comment\">//从右侧找</span></span><br><span class=\"line\">\t\t\t\tlow = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt; k<span class=\"number\">-1</span>) &#123;  <span class=\"comment\">//从左侧找</span></span><br><span class=\"line\">\t\t\t\thigh = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = high+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i &lt; j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(a[++i]&gt;a[low] &amp;&amp; i &lt; high);   <span class=\"comment\">//从左开始找比基准数小的</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(a[--j]&lt;a[low] &amp;&amp; j &gt; <span class=\"number\">0</span>);      <span class=\"comment\">//从右开始找比基准数大的</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&lt;j) swap(a, i, j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      swap(a, low, j);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> temp = a[j];</span><br><span class=\"line\">\t\ta[j] = a[i];</span><br><span class=\"line\">\t\ta[i] = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"692-Top-K-Frequent-Words\"><a href=\"#692-Top-K-Frequent-Words\" class=\"headerlink\" title=\"692. Top K Frequent Words\"></a>692. Top K Frequent Words</h3><p>题目大意是找到前k个出现频率最高的单词，按照频率从大到小排，如果频率相同就按单词字母从小到大的顺序，小字母开头的在前。<br>继续利用HashMap+优先队列，继续模板代码。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">String</span>&gt; topKFrequent(<span class=\"keyword\">String</span>[] words, <span class=\"built_in\">int</span> k) &#123;</span><br><span class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, Integer&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> w : words) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">map</span>.put(w, <span class=\"built_in\">map</span>.getOrDefault(w, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PriorityQueue&lt;<span class=\"keyword\">String</span>&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(</span><br><span class=\"line\">            (a, b)-&gt; &#123;<span class=\"keyword\">if</span>(<span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(a) == <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(b)) <span class=\"keyword\">return</span> b.compareTo(a); <span class=\"comment\">//字母大的排前面</span></span><br><span class=\"line\">\t        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(a) - <span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(b);&#125;); <span class=\"comment\">//频次小的排前面</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">String</span> w : <span class=\"built_in\">map</span>.keySet()) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">add</span>(w);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">size</span>() &gt; k) &#123;</span><br><span class=\"line\">                q.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">String</span>&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">add</span>(q.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.<span class=\"built_in\">reverse</span>(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>做了这么多前k个问题的题目，对最小堆（优先队列）有了一定的认识，其实前k个题目都可以转成排序的问题来做，我个人的理解是转成排序的话就是完全排序，每个元素都是排好的，那么问题都好解决，就比如前k个的问题其实并不需要完全排序，只需要粗略排，比如优先队列中头部元素永远是最大或者最小的，那么可能多余的操作就不必要了。堆的本质还是一个二叉树，父节点永远比子节点大（小）。</p>\n"},{"title":"LeetCode Heap系列（一）","date":"2019-03-29T15:31:25.000Z","description":"Leetcode BST 703/973/451/347","_content":"\n## Heap\n>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。\n\n堆可以理解成一个二叉树，而这个二叉树的性质是父节点总是大于或小于子节点。\n\n### 703. Kth Largest Element in a Stream\n题目大意是找到数组中第k大的元素，每次添加元素的时候也都返回第k大的元素。\n\n```\nclass KthLargest {\n    private PriorityQueue<Integer> q;\n\tprivate int k;\n    \n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        q = new PriorityQueue<>();\n\t    for(int i : nums) {\n\t    \tadd(i);\n\t    }\n    }\n    public int add(int val) {\n        q.add(val);\n\t\tif(q.size() > k) {\n\t\t\tq.remove();\n\t\t}\n\t\treturn q.peek();\n    }\n   \n}\n\n```\n\n### 973. K Closest Points to Origin\n题目大意是找到一系列点中距离原点最近的k个点。\n同样用上面最小堆的思想将点保存到优先队列中。\n```\nclass Solution {\n    public int[][] kClosest(int[][] points, int K) {\n        PriorityQueue<Point> q = new PriorityQueue<>();\n        int[][] res = new int[K][2];\n        int n = points.length;\n        for(int i=0; i < n; i++) {\n            int[] t = points[i];\n            int square = t[0]*t[0] + t[1]*t[1];\n            Point p = new Point(i, square);\n            q.add(p);\n           \n        }\n        for(int i=0; i<K; i++) {\n            res[i] = points[q.peek().posi];\n            q.remove();\n        }\n        return res;\n    }\n    \n    class Point implements Comparable<Point> {\n        private int square;   //距离的平方\n        private int posi;     // 第几个点\n        public Point(int posi, int square) {\n            this.posi = posi;\n            this.square = square;\n        }\n\t\tpublic int compareTo(Point o) {\t\n\t\t\treturn this.square - o.square;\n\t\t}\n    }\n}\n```\n\n### 451. Sort Characters By Frequency\n题目大意是按照字符串中重复字母数来输出字符串，重复越多越靠前，不考虑相同次数的顺序。\n还是利用优先队列次数多的排前面的思路，用HashMap用来保存字符以及统计它出现的次数。discuss里的用优先队列的写法比我的好太多，简练很多，于是最后改成用他那种写法。\n```\nclass Solution {\n    public String frequencySort(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int n = s.length();\n        for(int i=0; i<n; i++) {\n            char t = s.charAt(i);\n            map.put(t, map.getOrDefault(t, 0) + 1);\n        }\n        \n        PriorityQueue<Map.Entry<Character, Integer>> q = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n\t    q.addAll(map.entrySet());\n         StringBuilder sb = new StringBuilder();\n         while (!q.isEmpty()) {\n            Map.Entry e = q.poll();\n            for (int i = 0; i < (int)e.getValue(); i++) \n                sb.append(e.getKey());\n        }\n        return sb.toString();\n    }\n \n}，\n```\n\n### 347. Top K Frequent Elements\n题目大意是求前k个出现最频繁的元素，要求时间复杂度不超过O(nlogN)。\n这题和上面那个统计重复字母数有点类似，统计频次时存入map的操作时间复杂度是O(n)，再放入优先队列中时间复杂度是O(nlogN)，所以总的还是不超过题目要求的，照着上面的模子就可以写出如下代码：\n```\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0; i<n; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for(Integer key : map.keySet()) {\n            q.add(key);\n            if(q.size()>k) {\n                q.poll();\n            }\n        }\n        List<Integer> list = new LinkedList<>();\n        while(!q.isEmpty()) {\n            list.add(q.poll());\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```","source":"_posts/2019-03-28-Heap系列（一）.md","raw":"---\ntitle: LeetCode Heap系列（一）\ndate: 2019-03-29 23:31:25\ntags: [LeetCode,Heap,algorithm]\ncategory: LeetCode\ndescription: Leetcode BST 703/973/451/347\n---\n\n## Heap\n>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。\n\n堆可以理解成一个二叉树，而这个二叉树的性质是父节点总是大于或小于子节点。\n\n### 703. Kth Largest Element in a Stream\n题目大意是找到数组中第k大的元素，每次添加元素的时候也都返回第k大的元素。\n\n```\nclass KthLargest {\n    private PriorityQueue<Integer> q;\n\tprivate int k;\n    \n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        q = new PriorityQueue<>();\n\t    for(int i : nums) {\n\t    \tadd(i);\n\t    }\n    }\n    public int add(int val) {\n        q.add(val);\n\t\tif(q.size() > k) {\n\t\t\tq.remove();\n\t\t}\n\t\treturn q.peek();\n    }\n   \n}\n\n```\n\n### 973. K Closest Points to Origin\n题目大意是找到一系列点中距离原点最近的k个点。\n同样用上面最小堆的思想将点保存到优先队列中。\n```\nclass Solution {\n    public int[][] kClosest(int[][] points, int K) {\n        PriorityQueue<Point> q = new PriorityQueue<>();\n        int[][] res = new int[K][2];\n        int n = points.length;\n        for(int i=0; i < n; i++) {\n            int[] t = points[i];\n            int square = t[0]*t[0] + t[1]*t[1];\n            Point p = new Point(i, square);\n            q.add(p);\n           \n        }\n        for(int i=0; i<K; i++) {\n            res[i] = points[q.peek().posi];\n            q.remove();\n        }\n        return res;\n    }\n    \n    class Point implements Comparable<Point> {\n        private int square;   //距离的平方\n        private int posi;     // 第几个点\n        public Point(int posi, int square) {\n            this.posi = posi;\n            this.square = square;\n        }\n\t\tpublic int compareTo(Point o) {\t\n\t\t\treturn this.square - o.square;\n\t\t}\n    }\n}\n```\n\n### 451. Sort Characters By Frequency\n题目大意是按照字符串中重复字母数来输出字符串，重复越多越靠前，不考虑相同次数的顺序。\n还是利用优先队列次数多的排前面的思路，用HashMap用来保存字符以及统计它出现的次数。discuss里的用优先队列的写法比我的好太多，简练很多，于是最后改成用他那种写法。\n```\nclass Solution {\n    public String frequencySort(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int n = s.length();\n        for(int i=0; i<n; i++) {\n            char t = s.charAt(i);\n            map.put(t, map.getOrDefault(t, 0) + 1);\n        }\n        \n        PriorityQueue<Map.Entry<Character, Integer>> q = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n\t    q.addAll(map.entrySet());\n         StringBuilder sb = new StringBuilder();\n         while (!q.isEmpty()) {\n            Map.Entry e = q.poll();\n            for (int i = 0; i < (int)e.getValue(); i++) \n                sb.append(e.getKey());\n        }\n        return sb.toString();\n    }\n \n}，\n```\n\n### 347. Top K Frequent Elements\n题目大意是求前k个出现最频繁的元素，要求时间复杂度不超过O(nlogN)。\n这题和上面那个统计重复字母数有点类似，统计频次时存入map的操作时间复杂度是O(n)，再放入优先队列中时间复杂度是O(nlogN)，所以总的还是不超过题目要求的，照着上面的模子就可以写出如下代码：\n```\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int n = nums.length;\n        for(int i=0; i<n; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for(Integer key : map.keySet()) {\n            q.add(key);\n            if(q.size()>k) {\n                q.poll();\n            }\n        }\n        List<Integer> list = new LinkedList<>();\n        while(!q.isEmpty()) {\n            list.add(q.poll());\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```","slug":"Heap系列（一）","published":1,"updated":"2019-03-29T16:08:03.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewol000gi0h66oa7wwzk","content":"<h2 id=\"Heap\"><a href=\"#Heap\" class=\"headerlink\" title=\"Heap\"></a>Heap</h2><blockquote>\n<p>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。</p>\n</blockquote>\n<p>堆可以理解成一个二叉树，而这个二叉树的性质是父节点总是大于或小于子节点。</p>\n<h3 id=\"703-Kth-Largest-Element-in-a-Stream\"><a href=\"#703-Kth-Largest-Element-in-a-Stream\" class=\"headerlink\" title=\"703. Kth Largest Element in a Stream\"></a>703. Kth Largest Element in a Stream</h3><p>题目大意是找到数组中第k大的元素，每次添加元素的时候也都返回第k大的元素。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">KthLargest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PriorityQueue&lt;Integer&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">KthLargest</span>(<span class=\"params\"><span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.k = k;</span><br><span class=\"line\">        q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : nums) &#123;</span><br><span class=\"line\">\t    \t<span class=\"keyword\">add</span>(i);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span>(<span class=\"params\"><span class=\"keyword\">int</span> val</span>)</span> &#123;</span><br><span class=\"line\">        q.<span class=\"keyword\">add</span>(val);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q.size() &gt; k) &#123;</span><br><span class=\"line\">\t\t\tq.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> q.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"973-K-Closest-Points-to-Origin\"><a href=\"#973-K-Closest-Points-to-Origin\" class=\"headerlink\" title=\"973. K Closest Points to Origin\"></a>973. K Closest Points to Origin</h3><p>题目大意是找到一系列点中距离原点最近的k个点。<br>同样用上面最小堆的思想将点保存到优先队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] kClosest(<span class=\"keyword\">int</span>[][] points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;Point&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[K][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = points.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] t = points[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> square = t[<span class=\"number\">0</span>]*t[<span class=\"number\">0</span>] + t[<span class=\"number\">1</span>]*t[<span class=\"number\">1</span>];</span><br><span class=\"line\">            Point p = <span class=\"keyword\">new</span> Point(i, square);</span><br><span class=\"line\">            q.add(p);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;K; i++) &#123;</span><br><span class=\"line\">            res[i] = points[q.peek().posi];</span><br><span class=\"line\">            q.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Point</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> square;   <span class=\"comment\">//距离的平方</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> posi;     <span class=\"comment\">// 第几个点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> posi, <span class=\"keyword\">int</span> square)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.posi = posi;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.square = square;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Point o)</span> </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.square - o.square;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"451-Sort-Characters-By-Frequency\"><a href=\"#451-Sort-Characters-By-Frequency\" class=\"headerlink\" title=\"451. Sort Characters By Frequency\"></a>451. Sort Characters By Frequency</h3><p>题目大意是按照字符串中重复字母数来输出字符串，重复越多越靠前，不考虑相同次数的顺序。<br>还是利用优先队列次数多的排前面的思路，用HashMap用来保存字符以及统计它出现的次数。discuss里的用优先队列的写法比我的好太多，简练很多，于是最后改成用他那种写法。<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    public String frequencySort(String s) &#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        int n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            char t = s.charAt(i);</span><br><span class=\"line\">            map.put(t, map.getOrDefault(t, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;<span class=\"function\"><span class=\"params\">((a, b) -&gt; b.getValue() - a.getValue())</span>;</span></span><br><span class=\"line\"><span class=\"function\">\t    <span class=\"title\">q</span>.<span class=\"title\">addAll</span><span class=\"params\">(map.entrySet())</span>;</span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"title\">StringBuilder</span> <span class=\"title\">sb</span> = <span class=\"title\">new</span> <span class=\"title\">StringBuilder</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"title\">while</span> <span class=\"params\">(!q.isEmpty())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">Map</span>.<span class=\"title\">Entry</span> <span class=\"title\">e</span> = <span class=\"title\">q</span>.<span class=\"title\">poll</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">for</span> <span class=\"params\">(int i = <span class=\"number\">0</span>; i &lt; (int)e.getValue(); i++)</span> </span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">sb</span>.<span class=\"title\">append</span><span class=\"params\">(e.getKey())</span>;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">sb</span>.<span class=\"title\">toString</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> </span></span><br><span class=\"line\"><span class=\"function\">&#125;，</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"347-Top-K-Frequent-Elements\"><a href=\"#347-Top-K-Frequent-Elements\" class=\"headerlink\" title=\"347. Top K Frequent Elements\"></a>347. Top K Frequent Elements</h3><p>题目大意是求前k个出现最频繁的元素，要求时间复杂度不超过O(nlogN)。<br>这题和上面那个统计重复字母数有点类似，统计频次时存入map的操作时间复杂度是O(n)，再放入优先队列中时间复杂度是O(nlogN)，所以总的还是不超过题目要求的，照着上面的模子就可以写出如下代码：<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;<span class=\"function\"><span class=\"params\">((a, b) -&gt; map.get(a) - map.get(b))</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">for</span><span class=\"params\">(Integer key : map.keySet())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">q</span>.<span class=\"title\">add</span><span class=\"params\">(key)</span>;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">if</span><span class=\"params\">(q.size()&gt;k)</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">q</span>.<span class=\"title\">poll</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">List</span>&lt;<span class=\"title\">Integer</span>&gt; <span class=\"title\">list</span> = <span class=\"title\">new</span> <span class=\"title\">LinkedList</span>&lt;&gt;<span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">while</span><span class=\"params\">(!q.isEmpty())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">list</span>.<span class=\"title\">add</span><span class=\"params\">(q.poll())</span>;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">Collections</span>.<span class=\"title\">reverse</span><span class=\"params\">(list)</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Heap\"><a href=\"#Heap\" class=\"headerlink\" title=\"Heap\"></a>Heap</h2><blockquote>\n<p>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。</p>\n</blockquote>\n<p>堆可以理解成一个二叉树，而这个二叉树的性质是父节点总是大于或小于子节点。</p>\n<h3 id=\"703-Kth-Largest-Element-in-a-Stream\"><a href=\"#703-Kth-Largest-Element-in-a-Stream\" class=\"headerlink\" title=\"703. Kth Largest Element in a Stream\"></a>703. Kth Largest Element in a Stream</h3><p>题目大意是找到数组中第k大的元素，每次添加元素的时候也都返回第k大的元素。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">KthLargest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PriorityQueue&lt;Integer&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">KthLargest</span>(<span class=\"params\"><span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span>[] nums</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.k = k;</span><br><span class=\"line\">        q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : nums) &#123;</span><br><span class=\"line\">\t    \t<span class=\"keyword\">add</span>(i);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span>(<span class=\"params\"><span class=\"keyword\">int</span> val</span>)</span> &#123;</span><br><span class=\"line\">        q.<span class=\"keyword\">add</span>(val);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q.size() &gt; k) &#123;</span><br><span class=\"line\">\t\t\tq.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> q.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"973-K-Closest-Points-to-Origin\"><a href=\"#973-K-Closest-Points-to-Origin\" class=\"headerlink\" title=\"973. K Closest Points to Origin\"></a>973. K Closest Points to Origin</h3><p>题目大意是找到一系列点中距离原点最近的k个点。<br>同样用上面最小堆的思想将点保存到优先队列中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] kClosest(<span class=\"keyword\">int</span>[][] points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;Point&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[K][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = points.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] t = points[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> square = t[<span class=\"number\">0</span>]*t[<span class=\"number\">0</span>] + t[<span class=\"number\">1</span>]*t[<span class=\"number\">1</span>];</span><br><span class=\"line\">            Point p = <span class=\"keyword\">new</span> Point(i, square);</span><br><span class=\"line\">            q.add(p);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;K; i++) &#123;</span><br><span class=\"line\">            res[i] = points[q.peek().posi];</span><br><span class=\"line\">            q.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Point</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> square;   <span class=\"comment\">//距离的平方</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> posi;     <span class=\"comment\">// 第几个点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> posi, <span class=\"keyword\">int</span> square)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.posi = posi;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.square = square;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Point o)</span> </span>&#123;\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.square - o.square;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"451-Sort-Characters-By-Frequency\"><a href=\"#451-Sort-Characters-By-Frequency\" class=\"headerlink\" title=\"451. Sort Characters By Frequency\"></a>451. Sort Characters By Frequency</h3><p>题目大意是按照字符串中重复字母数来输出字符串，重复越多越靠前，不考虑相同次数的顺序。<br>还是利用优先队列次数多的排前面的思路，用HashMap用来保存字符以及统计它出现的次数。discuss里的用优先队列的写法比我的好太多，简练很多，于是最后改成用他那种写法。<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    public String frequencySort(String s) &#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        int n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            char t = s.charAt(i);</span><br><span class=\"line\">            map.put(t, map.getOrDefault(t, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;<span class=\"function\"><span class=\"params\">((a, b) -&gt; b.getValue() - a.getValue())</span>;</span></span><br><span class=\"line\"><span class=\"function\">\t    <span class=\"title\">q</span>.<span class=\"title\">addAll</span><span class=\"params\">(map.entrySet())</span>;</span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"title\">StringBuilder</span> <span class=\"title\">sb</span> = <span class=\"title\">new</span> <span class=\"title\">StringBuilder</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"title\">while</span> <span class=\"params\">(!q.isEmpty())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">Map</span>.<span class=\"title\">Entry</span> <span class=\"title\">e</span> = <span class=\"title\">q</span>.<span class=\"title\">poll</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">for</span> <span class=\"params\">(int i = <span class=\"number\">0</span>; i &lt; (int)e.getValue(); i++)</span> </span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">sb</span>.<span class=\"title\">append</span><span class=\"params\">(e.getKey())</span>;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">sb</span>.<span class=\"title\">toString</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"> </span></span><br><span class=\"line\"><span class=\"function\">&#125;，</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"347-Top-K-Frequent-Elements\"><a href=\"#347-Top-K-Frequent-Elements\" class=\"headerlink\" title=\"347. Top K Frequent Elements\"></a>347. Top K Frequent Elements</h3><p>题目大意是求前k个出现最频繁的元素，要求时间复杂度不超过O(nlogN)。<br>这题和上面那个统计重复字母数有点类似，统计频次时存入map的操作时间复杂度是O(n)，再放入优先队列中时间复杂度是O(nlogN)，所以总的还是不超过题目要求的，照着上面的模子就可以写出如下代码：<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int i=<span class=\"number\">0</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">            map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;<span class=\"function\"><span class=\"params\">((a, b) -&gt; map.get(a) - map.get(b))</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">for</span><span class=\"params\">(Integer key : map.keySet())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">q</span>.<span class=\"title\">add</span><span class=\"params\">(key)</span>;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">if</span><span class=\"params\">(q.size()&gt;k)</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">q</span>.<span class=\"title\">poll</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">List</span>&lt;<span class=\"title\">Integer</span>&gt; <span class=\"title\">list</span> = <span class=\"title\">new</span> <span class=\"title\">LinkedList</span>&lt;&gt;<span class=\"params\">()</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">while</span><span class=\"params\">(!q.isEmpty())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">list</span>.<span class=\"title\">add</span><span class=\"params\">(q.poll())</span>;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">Collections</span>.<span class=\"title\">reverse</span><span class=\"params\">(list)</span>;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">return</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"LeetCode HashTable系列（一）","date":"2019-07-09T02:08:10.000Z","description":"Leetcode HashTable 1002/500/884","toc":true,"_content":"\n### 1002.Find Common Characters\n题目大意是给定一个字符串数组，找出每个字符串公共的字母，包括重复的，比如一个字母在每个字符串里重复了3次，那么最后也输出3次。\n\n1.Example 1:\nInput: [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\n\n2.Example 2:\nInput: [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]\n\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/find-common-characters/ \"Find Common Characters\" %}\nclass Solution {\n    public List<String> commonChars(String[] A) {\n        int Alen = A.length;\n        List<String> res = new ArrayList<>();\n        int[] nums = new int[26];\n        Arrays.fill(nums, Integer.MAX_VALUE);\n        for(int i=0; i<Alen; i++) {\n            String s = A[i];\n            int[] temp = new int[26];\n            for(int j=0; j<s.length(); j++) {\n                temp[s.charAt(j) - 'a']++;\n            }\n            for(int k=0; k<26; k++) {\n                nums[k] = Math.min(nums[k], temp[k]);  //记录出现次数最少的\n            }\n        }\n        for(int i=0; i<26; i++) {\n            while(nums[i]-- > 0) {\n                res.add(String.valueOf((char)(i + 97)));\n            }\n        }\n        return res;\n    }\n}\n{% endcodeblock %}\n\n这题目一开始想到是用数组去记录26个字母出现次数的，但是在重复的地方比较容易出错，比如说在一个字符串中重复了多次，但是其他字符串没有，后来看了一个discuss，才意识到需要额外一个数组来记录单个字符串字母出现的次数，通过这个数组和最终计数的数组比较取最小值，来统计出实际重复的次数。既然每个都要重复，那么最终肯定最少是一次，没出现过就是零次。\n\n### 500. Keyboard Row\n题目大意是给定一个字符串数组，判断每个字符串字母是否是由键盘上同一行的字母组成，输出符合条件的字符串。假定只用到键盘每一行的字母，以及字母可以重复。\n我的思路就是键盘上三行分成三组，拿每一个字符串每个字母去比较，一旦出现字母不在同一行那就排除。最终运行时间0ms挺让我惊讶的。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/keyboard-row/ \" Keyboard Row\" %}\nclass Solution {\n    public String[] findWords(String[] words) {\n        String row1 = \"qwertyuiop\";\n        String row2 = \"asdfghjkl\";\n        String row3 = \"zxcvbnm\";\n        List<String> res = new ArrayList<>();\n        for(int i=0; i<words.length; i++) {\n            String s = words[i];\n            String lowerS = s.toLowerCase();\n            int row = 0;\n            for(int j=0; j<lowerS.length(); j++) {\n                if(row1.indexOf(lowerS.charAt(j)) > -1) {\n                    if(j == 0) {\n                        row = 1;\n                    } else if(row != 1) {\n                        row = 0;\n                        break;\n                    }\n                } else if(row2.indexOf(lowerS.charAt(j)) > -1) {\n                     if(j == 0) {\n                        row = 2;\n                     } else if(row != 2) {\n                        row = 0;\n                        break;\n                    }\n                } else {\n                     if(j == 0) {\n                        row = 3;\n                     } else if(row != 3) {\n                        row = 0;\n                        break;\n                    }\n                }\n            }\n            if(row != 0) {\n                res.add(s);\n            }\n        }\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n\n### 884. Uncommon Words from Two Sentences\n题目大意是给定两个有单词空格组成的字符串，要求找到两个字符串中仅出现一次的单词。\n这道题目总共做了三遍用了三种解法，第一遍想法是利用集合概念中交集的补集去做，但是容易忽略两个集合各自重复的元素，它们也是需要在最后的集合中移除掉的。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n \t\tSet<String> a = new HashSet<>();\n        Set<String> acommon = new HashSet<>();\n        String[] asArr = A.split(\" \");\n        for(int i=0; i<asArr.length; i++) {\n            if(a.contains(asArr[i])) {\n                acommon.add(asArr[i]);    //a集合中重复的元素记录一下\n            } else {\n                a.add(asArr[i]);\n            }\n        }\n        Set<String> b = new HashSet<>();\n        Set<String> bcommon = new HashSet<>();\n        String[] bsArr = B.split(\" \");\n        for(int i=0; i<bsArr.length; i++) {\n            if(b.contains(bsArr[i])) {\n                bcommon.add(bsArr[i]);\n            } else {\n                b.add(bsArr[i]);\n            }\n        }\n        \n        Set<String> common = new HashSet<>();\n        common.addAll(a);\n        common.retainAll(b);   //取交集\n        Set<String> res = new HashSet<>();\n        res.addAll(a);\n        res.addAll(b);    // 取并集\n        res.removeAll(bcommon);    //剔除各自集合重复元素\n        res.removeAll(acommon);\n        for(String t : common) {\n            System.out.println(t);\n        }\n        res.removeAll(common); // 并集再移除交集就是补集\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n因为用时7ms过了也懒得把可复用的代码整理下，但是看着冗长所以想了第二种解法。因为是在HashTable标签下，那么想着map应该也能解决，毕竟set也是hashmap中key的集合，所以就很容易想到遍历记录次数，单词仅出现一次的就保留。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n\t\tString[] asArr = (A+ \" \" + B).split(\" \");\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tSet<String> res = new HashSet<>();\n\t\tfor(int i=0; i<asArr.length; i++) {\n\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], 0)+1);\n\t\t}\n\t\tmap.forEach((k,v)->{\n            System.out.println(k + \"==\" + v);\n            if(v == 1) {\n                res.add(k);\n            }\n        });\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n虽然通过了但用了40ms觉得肯定有优化的地方，然后觉得在统计的时候直接存入结果应该会比后面再重头遍历一次好一点，那么只需要每次判断一下出现了一次就放入结果，超了就移除。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n\t\tString[] asArr = (A+ \" \" + B).split(\" \");\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tSet<String> res = new HashSet<>();\n\t\tfor(int i=0; i<asArr.length; i++) {\n\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], 0)+1);\n\t\t\tif(map.get(asArr[i]) == 1) {\n                res.add(asArr[i]);\n            } else {\n                res.remove(asArr[i]);\n            }\n\t\t}\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n果然和我判断的一样，当字符多的时候重头再一次一次计数浪费了时间，上面的解法就用了3ms。\n","source":"_posts/2019-07-09-LeetCode-HashTable系列（一）.md","raw":"---\ntitle: LeetCode HashTable系列（一）\ndate: 2019-07-09 10:08:10\ntags: [LeetCode,HashTable,algorithm]\ncategory: LeetCode\ndescription: Leetcode HashTable 1002/500/884\ntoc: true\n---\n\n### 1002.Find Common Characters\n题目大意是给定一个字符串数组，找出每个字符串公共的字母，包括重复的，比如一个字母在每个字符串里重复了3次，那么最后也输出3次。\n\n1.Example 1:\nInput: [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\n\n2.Example 2:\nInput: [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]\n\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/find-common-characters/ \"Find Common Characters\" %}\nclass Solution {\n    public List<String> commonChars(String[] A) {\n        int Alen = A.length;\n        List<String> res = new ArrayList<>();\n        int[] nums = new int[26];\n        Arrays.fill(nums, Integer.MAX_VALUE);\n        for(int i=0; i<Alen; i++) {\n            String s = A[i];\n            int[] temp = new int[26];\n            for(int j=0; j<s.length(); j++) {\n                temp[s.charAt(j) - 'a']++;\n            }\n            for(int k=0; k<26; k++) {\n                nums[k] = Math.min(nums[k], temp[k]);  //记录出现次数最少的\n            }\n        }\n        for(int i=0; i<26; i++) {\n            while(nums[i]-- > 0) {\n                res.add(String.valueOf((char)(i + 97)));\n            }\n        }\n        return res;\n    }\n}\n{% endcodeblock %}\n\n这题目一开始想到是用数组去记录26个字母出现次数的，但是在重复的地方比较容易出错，比如说在一个字符串中重复了多次，但是其他字符串没有，后来看了一个discuss，才意识到需要额外一个数组来记录单个字符串字母出现的次数，通过这个数组和最终计数的数组比较取最小值，来统计出实际重复的次数。既然每个都要重复，那么最终肯定最少是一次，没出现过就是零次。\n\n### 500. Keyboard Row\n题目大意是给定一个字符串数组，判断每个字符串字母是否是由键盘上同一行的字母组成，输出符合条件的字符串。假定只用到键盘每一行的字母，以及字母可以重复。\n我的思路就是键盘上三行分成三组，拿每一个字符串每个字母去比较，一旦出现字母不在同一行那就排除。最终运行时间0ms挺让我惊讶的。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/keyboard-row/ \" Keyboard Row\" %}\nclass Solution {\n    public String[] findWords(String[] words) {\n        String row1 = \"qwertyuiop\";\n        String row2 = \"asdfghjkl\";\n        String row3 = \"zxcvbnm\";\n        List<String> res = new ArrayList<>();\n        for(int i=0; i<words.length; i++) {\n            String s = words[i];\n            String lowerS = s.toLowerCase();\n            int row = 0;\n            for(int j=0; j<lowerS.length(); j++) {\n                if(row1.indexOf(lowerS.charAt(j)) > -1) {\n                    if(j == 0) {\n                        row = 1;\n                    } else if(row != 1) {\n                        row = 0;\n                        break;\n                    }\n                } else if(row2.indexOf(lowerS.charAt(j)) > -1) {\n                     if(j == 0) {\n                        row = 2;\n                     } else if(row != 2) {\n                        row = 0;\n                        break;\n                    }\n                } else {\n                     if(j == 0) {\n                        row = 3;\n                     } else if(row != 3) {\n                        row = 0;\n                        break;\n                    }\n                }\n            }\n            if(row != 0) {\n                res.add(s);\n            }\n        }\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n\n### 884. Uncommon Words from Two Sentences\n题目大意是给定两个有单词空格组成的字符串，要求找到两个字符串中仅出现一次的单词。\n这道题目总共做了三遍用了三种解法，第一遍想法是利用集合概念中交集的补集去做，但是容易忽略两个集合各自重复的元素，它们也是需要在最后的集合中移除掉的。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n \t\tSet<String> a = new HashSet<>();\n        Set<String> acommon = new HashSet<>();\n        String[] asArr = A.split(\" \");\n        for(int i=0; i<asArr.length; i++) {\n            if(a.contains(asArr[i])) {\n                acommon.add(asArr[i]);    //a集合中重复的元素记录一下\n            } else {\n                a.add(asArr[i]);\n            }\n        }\n        Set<String> b = new HashSet<>();\n        Set<String> bcommon = new HashSet<>();\n        String[] bsArr = B.split(\" \");\n        for(int i=0; i<bsArr.length; i++) {\n            if(b.contains(bsArr[i])) {\n                bcommon.add(bsArr[i]);\n            } else {\n                b.add(bsArr[i]);\n            }\n        }\n        \n        Set<String> common = new HashSet<>();\n        common.addAll(a);\n        common.retainAll(b);   //取交集\n        Set<String> res = new HashSet<>();\n        res.addAll(a);\n        res.addAll(b);    // 取并集\n        res.removeAll(bcommon);    //剔除各自集合重复元素\n        res.removeAll(acommon);\n        for(String t : common) {\n            System.out.println(t);\n        }\n        res.removeAll(common); // 并集再移除交集就是补集\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n因为用时7ms过了也懒得把可复用的代码整理下，但是看着冗长所以想了第二种解法。因为是在HashTable标签下，那么想着map应该也能解决，毕竟set也是hashmap中key的集合，所以就很容易想到遍历记录次数，单词仅出现一次的就保留。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n\t\tString[] asArr = (A+ \" \" + B).split(\" \");\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tSet<String> res = new HashSet<>();\n\t\tfor(int i=0; i<asArr.length; i++) {\n\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], 0)+1);\n\t\t}\n\t\tmap.forEach((k,v)->{\n            System.out.println(k + \"==\" + v);\n            if(v == 1) {\n                res.add(k);\n            }\n        });\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n虽然通过了但用了40ms觉得肯定有优化的地方，然后觉得在统计的时候直接存入结果应该会比后面再重头遍历一次好一点，那么只需要每次判断一下出现了一次就放入结果，超了就移除。\n{% codeblock \"Solution\" lang:Java https://leetcode.com/problems/uncommon-words-from-two-sentences/ \"Uncommon Words from Two Sentences\" %}\nclass Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n\t\tString[] asArr = (A+ \" \" + B).split(\" \");\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tSet<String> res = new HashSet<>();\n\t\tfor(int i=0; i<asArr.length; i++) {\n\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], 0)+1);\n\t\t\tif(map.get(asArr[i]) == 1) {\n                res.add(asArr[i]);\n            } else {\n                res.remove(asArr[i]);\n            }\n\t\t}\n        return res.toArray(new String[0]);\n    }\n}\n{% endcodeblock %}\n果然和我判断的一样，当字符多的时候重头再一次一次计数浪费了时间，上面的解法就用了3ms。\n","slug":"LeetCode-HashTable系列（一）","published":1,"updated":"2019-07-12T05:10:03.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewoq000ii0h6m0k5eorq","content":"<h3 id=\"1002-Find-Common-Characters\"><a href=\"#1002-Find-Common-Characters\" class=\"headerlink\" title=\"1002.Find Common Characters\"></a>1002.Find Common Characters</h3><p>题目大意是给定一个字符串数组，找出每个字符串公共的字母，包括重复的，比如一个字母在每个字符串里重复了3次，那么最后也输出3次。</p>\n<p>1.Example 1:<br>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]</p>\n<p>2.Example 2:<br>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/find-common-characters/\" target=\"_blank\" rel=\"noopener\">Find Common Characters</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">commonChars</span><span class=\"params\">(String[] A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Alen = A.length;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        Arrays.fill(nums, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;Alen; i++) &#123;</span><br><span class=\"line\">            String s = A[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;s.length(); j++) &#123;</span><br><span class=\"line\">                temp[s.charAt(j) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k&lt;<span class=\"number\">26</span>; k++) &#123;</span><br><span class=\"line\">                nums[k] = Math.min(nums[k], temp[k]);  <span class=\"comment\">//记录出现次数最少的</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nums[i]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.add(String.valueOf((<span class=\"keyword\">char</span>)(i + <span class=\"number\">97</span>)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这题目一开始想到是用数组去记录26个字母出现次数的，但是在重复的地方比较容易出错，比如说在一个字符串中重复了多次，但是其他字符串没有，后来看了一个discuss，才意识到需要额外一个数组来记录单个字符串字母出现的次数，通过这个数组和最终计数的数组比较取最小值，来统计出实际重复的次数。既然每个都要重复，那么最终肯定最少是一次，没出现过就是零次。</p>\n<h3 id=\"500-Keyboard-Row\"><a href=\"#500-Keyboard-Row\" class=\"headerlink\" title=\"500. Keyboard Row\"></a>500. Keyboard Row</h3><p>题目大意是给定一个字符串数组，判断每个字符串字母是否是由键盘上同一行的字母组成，输出符合条件的字符串。假定只用到键盘每一行的字母，以及字母可以重复。<br>我的思路就是键盘上三行分成三组，拿每一个字符串每个字母去比较，一旦出现字母不在同一行那就排除。最终运行时间0ms挺让我惊讶的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/keyboard-row/\" target=\"_blank\" rel=\"noopener\">Keyboard Row</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] findWords(String[] words) &#123;</span><br><span class=\"line\">        String row1 = <span class=\"string\">\"qwertyuiop\"</span>;</span><br><span class=\"line\">        String row2 = <span class=\"string\">\"asdfghjkl\"</span>;</span><br><span class=\"line\">        String row3 = <span class=\"string\">\"zxcvbnm\"</span>;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;words.length; i++) &#123;</span><br><span class=\"line\">            String s = words[i];</span><br><span class=\"line\">            String lowerS = s.toLowerCase();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;lowerS.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(row1.indexOf(lowerS.charAt(j)) &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row2.indexOf(lowerS.charAt(j)) &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">2</span>;</span><br><span class=\"line\">                     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">3</span>;</span><br><span class=\"line\">                     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(row != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"884-Uncommon-Words-from-Two-Sentences\"><a href=\"#884-Uncommon-Words-from-Two-Sentences\" class=\"headerlink\" title=\"884. Uncommon Words from Two Sentences\"></a>884. Uncommon Words from Two Sentences</h3><p>题目大意是给定两个有单词空格组成的字符串，要求找到两个字符串中仅出现一次的单词。<br>这道题目总共做了三遍用了三种解法，第一遍想法是利用集合概念中交集的补集去做，但是容易忽略两个集合各自重复的元素，它们也是需要在最后的集合中移除掉的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\"> \t\tSet&lt;String&gt; a = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; acommon = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        String[] asArr = A.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.contains(asArr[i])) &#123;</span><br><span class=\"line\">                acommon.add(asArr[i]);    <span class=\"comment\">//a集合中重复的元素记录一下</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                a.add(asArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;String&gt; b = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; bcommon = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        String[] bsArr = B.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;bsArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b.contains(bsArr[i])) &#123;</span><br><span class=\"line\">                bcommon.add(bsArr[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                b.add(bsArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;String&gt; common = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        common.addAll(a);</span><br><span class=\"line\">        common.retainAll(b);   <span class=\"comment\">//取交集</span></span><br><span class=\"line\">        Set&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        res.addAll(a);</span><br><span class=\"line\">        res.addAll(b);    <span class=\"comment\">// 取并集</span></span><br><span class=\"line\">        res.removeAll(bcommon);    <span class=\"comment\">//剔除各自集合重复元素</span></span><br><span class=\"line\">        res.removeAll(acommon);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String t : common) &#123;</span><br><span class=\"line\">            System.out.println(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.removeAll(common); <span class=\"comment\">// 并集再移除交集就是补集</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>因为用时7ms过了也懒得把可复用的代码整理下，但是看着冗长所以想了第二种解法。因为是在HashTable标签下，那么想着map应该也能解决，毕竟set也是hashmap中key的集合，所以就很容易想到遍历记录次数，单词仅出现一次的就保留。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\">\t\tString[] asArr = (A+ <span class=\"string\">\" \"</span> + B).split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\tSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], <span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmap.forEach((k,v)-&gt;&#123;</span><br><span class=\"line\">            System.out.println(k + <span class=\"string\">\"==\"</span> + v);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(v == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.add(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>虽然通过了但用了40ms觉得肯定有优化的地方，然后觉得在统计的时候直接存入结果应该会比后面再重头遍历一次好一点，那么只需要每次判断一下出现了一次就放入结果，超了就移除。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\">\t\tString[] asArr = (A+ <span class=\"string\">\" \"</span> + B).split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\tSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], <span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(map.get(asArr[i]) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.add(asArr[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.remove(asArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>果然和我判断的一样，当字符多的时候重头再一次一次计数浪费了时间，上面的解法就用了3ms。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1002-Find-Common-Characters\"><a href=\"#1002-Find-Common-Characters\" class=\"headerlink\" title=\"1002.Find Common Characters\"></a>1002.Find Common Characters</h3><p>题目大意是给定一个字符串数组，找出每个字符串公共的字母，包括重复的，比如一个字母在每个字符串里重复了3次，那么最后也输出3次。</p>\n<p>1.Example 1:<br>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]</p>\n<p>2.Example 2:<br>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/find-common-characters/\" target=\"_blank\" rel=\"noopener\">Find Common Characters</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">commonChars</span><span class=\"params\">(String[] A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> Alen = A.length;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        Arrays.fill(nums, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;Alen; i++) &#123;</span><br><span class=\"line\">            String s = A[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;s.length(); j++) &#123;</span><br><span class=\"line\">                temp[s.charAt(j) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k&lt;<span class=\"number\">26</span>; k++) &#123;</span><br><span class=\"line\">                nums[k] = Math.min(nums[k], temp[k]);  <span class=\"comment\">//记录出现次数最少的</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nums[i]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.add(String.valueOf((<span class=\"keyword\">char</span>)(i + <span class=\"number\">97</span>)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这题目一开始想到是用数组去记录26个字母出现次数的，但是在重复的地方比较容易出错，比如说在一个字符串中重复了多次，但是其他字符串没有，后来看了一个discuss，才意识到需要额外一个数组来记录单个字符串字母出现的次数，通过这个数组和最终计数的数组比较取最小值，来统计出实际重复的次数。既然每个都要重复，那么最终肯定最少是一次，没出现过就是零次。</p>\n<h3 id=\"500-Keyboard-Row\"><a href=\"#500-Keyboard-Row\" class=\"headerlink\" title=\"500. Keyboard Row\"></a>500. Keyboard Row</h3><p>题目大意是给定一个字符串数组，判断每个字符串字母是否是由键盘上同一行的字母组成，输出符合条件的字符串。假定只用到键盘每一行的字母，以及字母可以重复。<br>我的思路就是键盘上三行分成三组，拿每一个字符串每个字母去比较，一旦出现字母不在同一行那就排除。最终运行时间0ms挺让我惊讶的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/keyboard-row/\" target=\"_blank\" rel=\"noopener\">Keyboard Row</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] findWords(String[] words) &#123;</span><br><span class=\"line\">        String row1 = <span class=\"string\">\"qwertyuiop\"</span>;</span><br><span class=\"line\">        String row2 = <span class=\"string\">\"asdfghjkl\"</span>;</span><br><span class=\"line\">        String row3 = <span class=\"string\">\"zxcvbnm\"</span>;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;words.length; i++) &#123;</span><br><span class=\"line\">            String s = words[i];</span><br><span class=\"line\">            String lowerS = s.toLowerCase();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;lowerS.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(row1.indexOf(lowerS.charAt(j)) &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row2.indexOf(lowerS.charAt(j)) &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">2</span>;</span><br><span class=\"line\">                     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">3</span>;</span><br><span class=\"line\">                     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row != <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        row = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(row != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"884-Uncommon-Words-from-Two-Sentences\"><a href=\"#884-Uncommon-Words-from-Two-Sentences\" class=\"headerlink\" title=\"884. Uncommon Words from Two Sentences\"></a>884. Uncommon Words from Two Sentences</h3><p>题目大意是给定两个有单词空格组成的字符串，要求找到两个字符串中仅出现一次的单词。<br>这道题目总共做了三遍用了三种解法，第一遍想法是利用集合概念中交集的补集去做，但是容易忽略两个集合各自重复的元素，它们也是需要在最后的集合中移除掉的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\"> \t\tSet&lt;String&gt; a = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; acommon = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        String[] asArr = A.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.contains(asArr[i])) &#123;</span><br><span class=\"line\">                acommon.add(asArr[i]);    <span class=\"comment\">//a集合中重复的元素记录一下</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                a.add(asArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;String&gt; b = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; bcommon = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        String[] bsArr = B.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;bsArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b.contains(bsArr[i])) &#123;</span><br><span class=\"line\">                bcommon.add(bsArr[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                b.add(bsArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;String&gt; common = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        common.addAll(a);</span><br><span class=\"line\">        common.retainAll(b);   <span class=\"comment\">//取交集</span></span><br><span class=\"line\">        Set&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        res.addAll(a);</span><br><span class=\"line\">        res.addAll(b);    <span class=\"comment\">// 取并集</span></span><br><span class=\"line\">        res.removeAll(bcommon);    <span class=\"comment\">//剔除各自集合重复元素</span></span><br><span class=\"line\">        res.removeAll(acommon);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String t : common) &#123;</span><br><span class=\"line\">            System.out.println(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.removeAll(common); <span class=\"comment\">// 并集再移除交集就是补集</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>因为用时7ms过了也懒得把可复用的代码整理下，但是看着冗长所以想了第二种解法。因为是在HashTable标签下，那么想着map应该也能解决，毕竟set也是hashmap中key的集合，所以就很容易想到遍历记录次数，单词仅出现一次的就保留。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\">\t\tString[] asArr = (A+ <span class=\"string\">\" \"</span> + B).split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\tSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], <span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmap.forEach((k,v)-&gt;&#123;</span><br><span class=\"line\">            System.out.println(k + <span class=\"string\">\"==\"</span> + v);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(v == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.add(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>虽然通过了但用了40ms觉得肯定有优化的地方，然后觉得在统计的时候直接存入结果应该会比后面再重头遍历一次好一点，那么只需要每次判断一下出现了一次就放入结果，超了就移除。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/uncommon-words-from-two-sentences/\" target=\"_blank\" rel=\"noopener\">Uncommon Words from Two Sentences</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class=\"line\">\t\tString[] asArr = (A+ <span class=\"string\">\" \"</span> + B).split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\tSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;asArr.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmap.put(asArr[i], map.getOrDefault(asArr[i], <span class=\"number\">0</span>)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(map.get(asArr[i]) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.add(asArr[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.remove(asArr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>果然和我判断的一样，当字符多的时候重头再一次一次计数浪费了时间，上面的解法就用了3ms。</p>\n"},{"title":"JVM Run-Time Data Area","date":"2019-06-27T02:19:44.000Z","description":"Java虚拟机运行时数据区域","toc":true,"_content":"\n这篇主要是阅读Java虚拟机规范做的摘录和笔记。<https://docs.oracle.com/javase/specs/jvms/se8/html>\nJVM运行时数据区域只是JVM结构体系的一部分，主要是针对内存分布。\nJVM在一个程序执行期间定义了不同的运行时数据区域来让程序使用，大体上分为两类：\n1. JVM启动时创建的Data Area,只能在JVM退出时销毁\n2. 每个线程创建的Data Area, 只能在线程退出时销毁\n\n![JVM-Run-Time-Data-Area](JVM-Run-time-Data-Areas.png)\n\n### 一. The pc(program counter) Register(寄存器)\n程序计数器记录了当前指令执行的地址，每个线程都会创建程序计数器，当一个方法为native时，程序计数器的值为undefined，\n只有方法不是native时，程序计数器才会执行指令。\n\n### 二. Java Virtual Machine Stacks\n每一个虚拟机线程都有私有的随线程同时创建的JVM stack，JVM stack用来存储frames。JVM stack有点和C语言的stack相似，它存储本地变量和部分结果，是触发方法执行和返回的一部分，因为stack不能直接操纵除了入栈出栈，frames也由Heap来分配，所以它不需要里内存很近。JVM的实现提供了可以由程序或者用户来控制stack的大小，stack的大小可以是动态的，也可以是固定大小的，以下两种情况的异常会和JVM stack有关：\n1. 如果一个线程内执行的计算需要超过被允许的stack大小的限制，JVM抛出StackOverflowError\n2. 如果stack可以动态扩张，但是尝试扩大的大小超过了内存的大小，JVM抛出OutOfMemoryError\n\n### 三. Heap\nJVM Heap被所有线程共享，它为所有class实例和数组分配内存。堆在JVM启动时创建，存储对象的堆空间被自动存储管理系统（垃圾回收）再利用，对象从不会显式地被释放。堆的内存空间不需要连续。当需要更多堆空间而超过自动存储管理系统所能提供的大小时，JVM抛出OutOfMemoryError\n![Heap](heap.gif)\n\n \n### 四. Method Area\nJVM的方法区同样也是被所有线程共享。方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段的存储区域，（谷歌翻译而来，需要更进一步理解）。方法区存储了每个类的结构，例如运行时常量池，域，方法数据以及包括类接口实例化时的特殊方法的代码。方法区在JVM启动时创建，尽管方法区是堆的逻辑上的部分，简单的实现也许不会被垃圾回收或者压缩。这个特性不需要方法区管它的位置以及管理编译代码的策略。方法区大小可固定，可扩展，内存不需要连续。同样方法区大小不够也会抛出\nOutOfMemoryError异常。\n\n### 五. Run-Time Constant Pool\n运行时常量池是一个记录每个类或者接口类信息的表，包含各种不同类型的常量，每个常量池表由JVM方法区分配，并且在类或者接口构造时由JVM创建，构造阶段如果内存分配不足同样也会抛出OutOfMemoryError异常。\n\n### 六. Native Method Stacks\n本地方法栈JVM用传统栈的实现来支持不同语言写的方法，同样也用来被一种语言的解释器的实现来解释JVM的指令集。\n本地方法栈内存大小不够时抛出StackOverflowError或者OutOfMemoryError异常。\n","source":"_posts/2019-06-27-JVM-Run-Time-Data-Area.md","raw":"---\ntitle: JVM Run-Time Data Area\ndate: 2019-06-27 10:19:44\ntags: [Java, JVM, Data Area]\ncategory: JVM\ndescription: Java虚拟机运行时数据区域\ntoc: true\n---\n\n这篇主要是阅读Java虚拟机规范做的摘录和笔记。<https://docs.oracle.com/javase/specs/jvms/se8/html>\nJVM运行时数据区域只是JVM结构体系的一部分，主要是针对内存分布。\nJVM在一个程序执行期间定义了不同的运行时数据区域来让程序使用，大体上分为两类：\n1. JVM启动时创建的Data Area,只能在JVM退出时销毁\n2. 每个线程创建的Data Area, 只能在线程退出时销毁\n\n![JVM-Run-Time-Data-Area](JVM-Run-time-Data-Areas.png)\n\n### 一. The pc(program counter) Register(寄存器)\n程序计数器记录了当前指令执行的地址，每个线程都会创建程序计数器，当一个方法为native时，程序计数器的值为undefined，\n只有方法不是native时，程序计数器才会执行指令。\n\n### 二. Java Virtual Machine Stacks\n每一个虚拟机线程都有私有的随线程同时创建的JVM stack，JVM stack用来存储frames。JVM stack有点和C语言的stack相似，它存储本地变量和部分结果，是触发方法执行和返回的一部分，因为stack不能直接操纵除了入栈出栈，frames也由Heap来分配，所以它不需要里内存很近。JVM的实现提供了可以由程序或者用户来控制stack的大小，stack的大小可以是动态的，也可以是固定大小的，以下两种情况的异常会和JVM stack有关：\n1. 如果一个线程内执行的计算需要超过被允许的stack大小的限制，JVM抛出StackOverflowError\n2. 如果stack可以动态扩张，但是尝试扩大的大小超过了内存的大小，JVM抛出OutOfMemoryError\n\n### 三. Heap\nJVM Heap被所有线程共享，它为所有class实例和数组分配内存。堆在JVM启动时创建，存储对象的堆空间被自动存储管理系统（垃圾回收）再利用，对象从不会显式地被释放。堆的内存空间不需要连续。当需要更多堆空间而超过自动存储管理系统所能提供的大小时，JVM抛出OutOfMemoryError\n![Heap](heap.gif)\n\n \n### 四. Method Area\nJVM的方法区同样也是被所有线程共享。方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段的存储区域，（谷歌翻译而来，需要更进一步理解）。方法区存储了每个类的结构，例如运行时常量池，域，方法数据以及包括类接口实例化时的特殊方法的代码。方法区在JVM启动时创建，尽管方法区是堆的逻辑上的部分，简单的实现也许不会被垃圾回收或者压缩。这个特性不需要方法区管它的位置以及管理编译代码的策略。方法区大小可固定，可扩展，内存不需要连续。同样方法区大小不够也会抛出\nOutOfMemoryError异常。\n\n### 五. Run-Time Constant Pool\n运行时常量池是一个记录每个类或者接口类信息的表，包含各种不同类型的常量，每个常量池表由JVM方法区分配，并且在类或者接口构造时由JVM创建，构造阶段如果内存分配不足同样也会抛出OutOfMemoryError异常。\n\n### 六. Native Method Stacks\n本地方法栈JVM用传统栈的实现来支持不同语言写的方法，同样也用来被一种语言的解释器的实现来解释JVM的指令集。\n本地方法栈内存大小不够时抛出StackOverflowError或者OutOfMemoryError异常。\n","slug":"JVM-Run-Time-Data-Area","published":1,"updated":"2019-07-04T03:50:48.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewov000mi0h61xmo230e","content":"<p>这篇主要是阅读Java虚拟机规范做的摘录和笔记。<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jvms/se8/html</a><br>JVM运行时数据区域只是JVM结构体系的一部分，主要是针对内存分布。<br>JVM在一个程序执行期间定义了不同的运行时数据区域来让程序使用，大体上分为两类：</p>\n<ol>\n<li>JVM启动时创建的Data Area,只能在JVM退出时销毁</li>\n<li>每个线程创建的Data Area, 只能在线程退出时销毁</li>\n</ol>\n<p><img src=\"JVM-Run-time-Data-Areas.png\" alt=\"JVM-Run-Time-Data-Area\"></p>\n<h3 id=\"一-The-pc-program-counter-Register-寄存器\"><a href=\"#一-The-pc-program-counter-Register-寄存器\" class=\"headerlink\" title=\"一. The pc(program counter) Register(寄存器)\"></a>一. The pc(program counter) Register(寄存器)</h3><p>程序计数器记录了当前指令执行的地址，每个线程都会创建程序计数器，当一个方法为native时，程序计数器的值为undefined，<br>只有方法不是native时，程序计数器才会执行指令。</p>\n<h3 id=\"二-Java-Virtual-Machine-Stacks\"><a href=\"#二-Java-Virtual-Machine-Stacks\" class=\"headerlink\" title=\"二. Java Virtual Machine Stacks\"></a>二. Java Virtual Machine Stacks</h3><p>每一个虚拟机线程都有私有的随线程同时创建的JVM stack，JVM stack用来存储frames。JVM stack有点和C语言的stack相似，它存储本地变量和部分结果，是触发方法执行和返回的一部分，因为stack不能直接操纵除了入栈出栈，frames也由Heap来分配，所以它不需要里内存很近。JVM的实现提供了可以由程序或者用户来控制stack的大小，stack的大小可以是动态的，也可以是固定大小的，以下两种情况的异常会和JVM stack有关：</p>\n<ol>\n<li>如果一个线程内执行的计算需要超过被允许的stack大小的限制，JVM抛出StackOverflowError</li>\n<li>如果stack可以动态扩张，但是尝试扩大的大小超过了内存的大小，JVM抛出OutOfMemoryError</li>\n</ol>\n<h3 id=\"三-Heap\"><a href=\"#三-Heap\" class=\"headerlink\" title=\"三. Heap\"></a>三. Heap</h3><p>JVM Heap被所有线程共享，它为所有class实例和数组分配内存。堆在JVM启动时创建，存储对象的堆空间被自动存储管理系统（垃圾回收）再利用，对象从不会显式地被释放。堆的内存空间不需要连续。当需要更多堆空间而超过自动存储管理系统所能提供的大小时，JVM抛出OutOfMemoryError<br><img src=\"heap.gif\" alt=\"Heap\"></p>\n<h3 id=\"四-Method-Area\"><a href=\"#四-Method-Area\" class=\"headerlink\" title=\"四. Method Area\"></a>四. Method Area</h3><p>JVM的方法区同样也是被所有线程共享。方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段的存储区域，（谷歌翻译而来，需要更进一步理解）。方法区存储了每个类的结构，例如运行时常量池，域，方法数据以及包括类接口实例化时的特殊方法的代码。方法区在JVM启动时创建，尽管方法区是堆的逻辑上的部分，简单的实现也许不会被垃圾回收或者压缩。这个特性不需要方法区管它的位置以及管理编译代码的策略。方法区大小可固定，可扩展，内存不需要连续。同样方法区大小不够也会抛出<br>OutOfMemoryError异常。</p>\n<h3 id=\"五-Run-Time-Constant-Pool\"><a href=\"#五-Run-Time-Constant-Pool\" class=\"headerlink\" title=\"五. Run-Time Constant Pool\"></a>五. Run-Time Constant Pool</h3><p>运行时常量池是一个记录每个类或者接口类信息的表，包含各种不同类型的常量，每个常量池表由JVM方法区分配，并且在类或者接口构造时由JVM创建，构造阶段如果内存分配不足同样也会抛出OutOfMemoryError异常。</p>\n<h3 id=\"六-Native-Method-Stacks\"><a href=\"#六-Native-Method-Stacks\" class=\"headerlink\" title=\"六. Native Method Stacks\"></a>六. Native Method Stacks</h3><p>本地方法栈JVM用传统栈的实现来支持不同语言写的方法，同样也用来被一种语言的解释器的实现来解释JVM的指令集。<br>本地方法栈内存大小不够时抛出StackOverflowError或者OutOfMemoryError异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇主要是阅读Java虚拟机规范做的摘录和笔记。<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jvms/se8/html</a><br>JVM运行时数据区域只是JVM结构体系的一部分，主要是针对内存分布。<br>JVM在一个程序执行期间定义了不同的运行时数据区域来让程序使用，大体上分为两类：</p>\n<ol>\n<li>JVM启动时创建的Data Area,只能在JVM退出时销毁</li>\n<li>每个线程创建的Data Area, 只能在线程退出时销毁</li>\n</ol>\n<p><img src=\"JVM-Run-time-Data-Areas.png\" alt=\"JVM-Run-Time-Data-Area\"></p>\n<h3 id=\"一-The-pc-program-counter-Register-寄存器\"><a href=\"#一-The-pc-program-counter-Register-寄存器\" class=\"headerlink\" title=\"一. The pc(program counter) Register(寄存器)\"></a>一. The pc(program counter) Register(寄存器)</h3><p>程序计数器记录了当前指令执行的地址，每个线程都会创建程序计数器，当一个方法为native时，程序计数器的值为undefined，<br>只有方法不是native时，程序计数器才会执行指令。</p>\n<h3 id=\"二-Java-Virtual-Machine-Stacks\"><a href=\"#二-Java-Virtual-Machine-Stacks\" class=\"headerlink\" title=\"二. Java Virtual Machine Stacks\"></a>二. Java Virtual Machine Stacks</h3><p>每一个虚拟机线程都有私有的随线程同时创建的JVM stack，JVM stack用来存储frames。JVM stack有点和C语言的stack相似，它存储本地变量和部分结果，是触发方法执行和返回的一部分，因为stack不能直接操纵除了入栈出栈，frames也由Heap来分配，所以它不需要里内存很近。JVM的实现提供了可以由程序或者用户来控制stack的大小，stack的大小可以是动态的，也可以是固定大小的，以下两种情况的异常会和JVM stack有关：</p>\n<ol>\n<li>如果一个线程内执行的计算需要超过被允许的stack大小的限制，JVM抛出StackOverflowError</li>\n<li>如果stack可以动态扩张，但是尝试扩大的大小超过了内存的大小，JVM抛出OutOfMemoryError</li>\n</ol>\n<h3 id=\"三-Heap\"><a href=\"#三-Heap\" class=\"headerlink\" title=\"三. Heap\"></a>三. Heap</h3><p>JVM Heap被所有线程共享，它为所有class实例和数组分配内存。堆在JVM启动时创建，存储对象的堆空间被自动存储管理系统（垃圾回收）再利用，对象从不会显式地被释放。堆的内存空间不需要连续。当需要更多堆空间而超过自动存储管理系统所能提供的大小时，JVM抛出OutOfMemoryError<br><img src=\"heap.gif\" alt=\"Heap\"></p>\n<h3 id=\"四-Method-Area\"><a href=\"#四-Method-Area\" class=\"headerlink\" title=\"四. Method Area\"></a>四. Method Area</h3><p>JVM的方法区同样也是被所有线程共享。方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段的存储区域，（谷歌翻译而来，需要更进一步理解）。方法区存储了每个类的结构，例如运行时常量池，域，方法数据以及包括类接口实例化时的特殊方法的代码。方法区在JVM启动时创建，尽管方法区是堆的逻辑上的部分，简单的实现也许不会被垃圾回收或者压缩。这个特性不需要方法区管它的位置以及管理编译代码的策略。方法区大小可固定，可扩展，内存不需要连续。同样方法区大小不够也会抛出<br>OutOfMemoryError异常。</p>\n<h3 id=\"五-Run-Time-Constant-Pool\"><a href=\"#五-Run-Time-Constant-Pool\" class=\"headerlink\" title=\"五. Run-Time Constant Pool\"></a>五. Run-Time Constant Pool</h3><p>运行时常量池是一个记录每个类或者接口类信息的表，包含各种不同类型的常量，每个常量池表由JVM方法区分配，并且在类或者接口构造时由JVM创建，构造阶段如果内存分配不足同样也会抛出OutOfMemoryError异常。</p>\n<h3 id=\"六-Native-Method-Stacks\"><a href=\"#六-Native-Method-Stacks\" class=\"headerlink\" title=\"六. Native Method Stacks\"></a>六. Native Method Stacks</h3><p>本地方法栈JVM用传统栈的实现来支持不同语言写的方法，同样也用来被一种语言的解释器的实现来解释JVM的指令集。<br>本地方法栈内存大小不够时抛出StackOverflowError或者OutOfMemoryError异常。</p>\n"},{"title":"LeetCode HashTable系列（二）","toc":true,"date":"2019-07-15T07:25:49.000Z","description":"LeetCode HashTable 739/290","_content":"\n### 739. Daily Temperatures\n题目大意给定一个整数数组表示温度，找出比当前温度高的日子最近需要几天，结果用数组表示，如果没有这样的一天，结果用0表示。例如T = [73, 74, 75, 71, 69, 72, 76, 73]，那么结果就是[1, 1, 4, 2, 1, 1, 0, 0]。其实就是找到比当前数字大的出现的第一个数字，求他们的距离。\n第一想到暴力解法试试，能过，但是耗时两百多ms。\n#### 暴力解法\n```Java Solution https://leetcode.com/problems/daily-temperatures/ Daily Temperatures\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int len = T.length;\n        int[] res = new int[len];\n        for(int i=0; i<len; i++) {\n            int cnt = 0;\n            for(int j= i; j<len; j++) {              \n                if(T[i] < T[j]) {\n                    res[i] = cnt;\n                    break;\n                } else {\n                    cnt++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n#### 栈\n这种解法利用了栈的思想，这个栈记录的是每个放入值的下标（索引），并且最底部是最大的，依次往上递减，我们从头开始遍历数组，依次放入栈中，在每一次放之前，用当前的值和栈顶索引对应的值比较，如果比栈顶对应的值大，那么就知道了栈顶索引对应的最近距离较大的值是哪个，计入结果数组，同时移除，继续当前值和新的栈顶的值比较。（总觉得应该把这题归在Stack下）\n```Java Solution https://leetcode.com/problems/daily-temperatures/ Daily Temperatures\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] stack = new int[T.length];\n        int top = -1;\n        int[] ret = new int[T.length];\n        for(int i = 0; i < T.length; i++) {   \n            while(top > -1 && T[i] > T[stack[top]]) {\n                int idx = stack[top--];\n                ret[idx] = i - idx; \n            }\n            stack[++top] = i;\n        }\n        return ret;\n    }\n}\n```\n\n### 290. Word Pattern\n题目大意给定几个单词组成的一个字符串，再给一个字符串代表几个单词的模式，问这几个单词是否匹配该模式。\nExample 1:\n\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\nExample 2:\n\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\n第一反应就是用map把单词和模式的字母做好一一映射的关系，然后就是逻辑判断了，如果包含key那么value不等说明不匹配，如果不包含key那么又存在value说明也不匹配，还有一种就是单词数和模式字符串长度不等也不匹配。\n\n```Java Solution https://leetcode.com/problems/word-pattern/ Word Pattern\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] s = str.split(\" \");\n        Map<String, String> map = new HashMap<>();\n        if(s.length != pattern.length()) {\n            return false;\n        }\n        for(int i=0; i<s.length; i++) {\n            String key = String.valueOf(pattern.charAt(i));\n            String value  = s[i];\n            if(map.containsKey(key)) {\n               if(!map.get(key).equals(value)) {\n                 return false;\n               }\n            } else {\n                if(map.containsValue(value)) {\n                    return false;\n                }\n                map.put(key, value);\n            }\n        }\n        return true;  \n\n    }\n}\n```\n\n### 387. First Unique Character in a String\n题目大意是找到给定字符串中第一次出现且不重复的字母的索引。\nExamples:\n\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n#### 1.beat 100%解\n先贴一个beat 100%的答案，写的十分精简，简直完美。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int len = s.length();\n        int lowest = len;\n        for (char i = 'a'; i <= 'z' ; i++) {\n            int first = s.indexOf(i);\n            if (first >= 0) {\n                if (lowest > first && s.lastIndexOf(i) == first)  //仅出现一次，并且靠前\n                    lowest = first;\n            }\n        }\n        return lowest == len ? -1 :lowest;\n    }\n}\n\n```\n#### 2.Map\n第二种自然是想到HashMap，官方给出的也是这种解，利用Map存储统计次数，但是Java中HashMap是无排序的，如果用LinkedHashMap就能根据放入先后顺序排了。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int len = s.length();\n        Map<Character, Integer> map = new LinkedHashMap<>();\n        for(int i=0; i<len; i++) {\n            char key = s.charAt(i);\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n        \n        Optional<Entry<Character, Integer>> res = map.entrySet().stream()\n        .filter(x -> x.getValue() == 1).findFirst();\n        if(res.isPresent()) {\n            return s.indexOf(res.get().getKey());\n        } else {\n            return -1;\n        }\n    }\n}\n\n```\n#### 3.数组\n第三种就是利用数组统计。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int[] nums = new int[26];\n        int len = s.length();\n        for(int i=0; i<len; i++) {\n            int k = (int)(s.charAt(i) - 'a');\n            nums[k]++;\n        }\n        for(int i=0; i<len; i++) {\n           if(nums[(int)(s.charAt(i) - 'a')] == 1){\n               return i;\n           }\n        }\n        return -1;\n    }\n}\n\n```","source":"_posts/2019-07-15-Leetcode-HashTaable系列（二）.md","raw":"---\ntitle: LeetCode HashTable系列（二）\ntoc: true\ndate: 2019-07-15 15:25:49\ntags: [LeetCode,HashTable,algorithm]\ncategory: LeetCode\ndescription: LeetCode HashTable 739/290\n---\n\n### 739. Daily Temperatures\n题目大意给定一个整数数组表示温度，找出比当前温度高的日子最近需要几天，结果用数组表示，如果没有这样的一天，结果用0表示。例如T = [73, 74, 75, 71, 69, 72, 76, 73]，那么结果就是[1, 1, 4, 2, 1, 1, 0, 0]。其实就是找到比当前数字大的出现的第一个数字，求他们的距离。\n第一想到暴力解法试试，能过，但是耗时两百多ms。\n#### 暴力解法\n```Java Solution https://leetcode.com/problems/daily-temperatures/ Daily Temperatures\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int len = T.length;\n        int[] res = new int[len];\n        for(int i=0; i<len; i++) {\n            int cnt = 0;\n            for(int j= i; j<len; j++) {              \n                if(T[i] < T[j]) {\n                    res[i] = cnt;\n                    break;\n                } else {\n                    cnt++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n#### 栈\n这种解法利用了栈的思想，这个栈记录的是每个放入值的下标（索引），并且最底部是最大的，依次往上递减，我们从头开始遍历数组，依次放入栈中，在每一次放之前，用当前的值和栈顶索引对应的值比较，如果比栈顶对应的值大，那么就知道了栈顶索引对应的最近距离较大的值是哪个，计入结果数组，同时移除，继续当前值和新的栈顶的值比较。（总觉得应该把这题归在Stack下）\n```Java Solution https://leetcode.com/problems/daily-temperatures/ Daily Temperatures\nclass Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] stack = new int[T.length];\n        int top = -1;\n        int[] ret = new int[T.length];\n        for(int i = 0; i < T.length; i++) {   \n            while(top > -1 && T[i] > T[stack[top]]) {\n                int idx = stack[top--];\n                ret[idx] = i - idx; \n            }\n            stack[++top] = i;\n        }\n        return ret;\n    }\n}\n```\n\n### 290. Word Pattern\n题目大意给定几个单词组成的一个字符串，再给一个字符串代表几个单词的模式，问这几个单词是否匹配该模式。\nExample 1:\n\nInput: pattern = \"abba\", str = \"dog cat cat dog\"\nOutput: true\nExample 2:\n\nInput:pattern = \"abba\", str = \"dog cat cat fish\"\nOutput: false\n\n第一反应就是用map把单词和模式的字母做好一一映射的关系，然后就是逻辑判断了，如果包含key那么value不等说明不匹配，如果不包含key那么又存在value说明也不匹配，还有一种就是单词数和模式字符串长度不等也不匹配。\n\n```Java Solution https://leetcode.com/problems/word-pattern/ Word Pattern\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] s = str.split(\" \");\n        Map<String, String> map = new HashMap<>();\n        if(s.length != pattern.length()) {\n            return false;\n        }\n        for(int i=0; i<s.length; i++) {\n            String key = String.valueOf(pattern.charAt(i));\n            String value  = s[i];\n            if(map.containsKey(key)) {\n               if(!map.get(key).equals(value)) {\n                 return false;\n               }\n            } else {\n                if(map.containsValue(value)) {\n                    return false;\n                }\n                map.put(key, value);\n            }\n        }\n        return true;  \n\n    }\n}\n```\n\n### 387. First Unique Character in a String\n题目大意是找到给定字符串中第一次出现且不重复的字母的索引。\nExamples:\n\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n#### 1.beat 100%解\n先贴一个beat 100%的答案，写的十分精简，简直完美。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int len = s.length();\n        int lowest = len;\n        for (char i = 'a'; i <= 'z' ; i++) {\n            int first = s.indexOf(i);\n            if (first >= 0) {\n                if (lowest > first && s.lastIndexOf(i) == first)  //仅出现一次，并且靠前\n                    lowest = first;\n            }\n        }\n        return lowest == len ? -1 :lowest;\n    }\n}\n\n```\n#### 2.Map\n第二种自然是想到HashMap，官方给出的也是这种解，利用Map存储统计次数，但是Java中HashMap是无排序的，如果用LinkedHashMap就能根据放入先后顺序排了。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int len = s.length();\n        Map<Character, Integer> map = new LinkedHashMap<>();\n        for(int i=0; i<len; i++) {\n            char key = s.charAt(i);\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n        \n        Optional<Entry<Character, Integer>> res = map.entrySet().stream()\n        .filter(x -> x.getValue() == 1).findFirst();\n        if(res.isPresent()) {\n            return s.indexOf(res.get().getKey());\n        } else {\n            return -1;\n        }\n    }\n}\n\n```\n#### 3.数组\n第三种就是利用数组统计。\n```Java Solution https://leetcode.com/problems/first-unique-character-in-a-string/  First Unique Character in a String\nclass Solution {\n    public int firstUniqChar(String s) {\n        int[] nums = new int[26];\n        int len = s.length();\n        for(int i=0; i<len; i++) {\n            int k = (int)(s.charAt(i) - 'a');\n            nums[k]++;\n        }\n        for(int i=0; i<len; i++) {\n           if(nums[(int)(s.charAt(i) - 'a')] == 1){\n               return i;\n           }\n        }\n        return -1;\n    }\n}\n\n```","slug":"Leetcode-HashTaable系列（二）","published":1,"updated":"2019-08-01T09:39:03.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewoy000pi0h6k8qs9vjx","content":"<h3 id=\"739-Daily-Temperatures\"><a href=\"#739-Daily-Temperatures\" class=\"headerlink\" title=\"739. Daily Temperatures\"></a>739. Daily Temperatures</h3><p>题目大意给定一个整数数组表示温度，找出比当前温度高的日子最近需要几天，结果用数组表示，如果没有这样的一天，结果用0表示。例如T = [73, 74, 75, 71, 69, 72, 76, 73]，那么结果就是[1, 1, 4, 2, 1, 1, 0, 0]。其实就是找到比当前数字大的出现的第一个数字，求他们的距离。<br>第一想到暴力解法试试，能过，但是耗时两百多ms。</p>\n<h4 id=\"暴力解法\"><a href=\"#暴力解法\" class=\"headerlink\" title=\"暴力解法\"></a>暴力解法</h4><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/daily-temperatures/\" target=\"_blank\" rel=\"noopener\">Daily Temperatures</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dailyTemperatures(<span class=\"keyword\">int</span>[] T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = T.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j= i; j&lt;len; j++) &#123;              </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T[i] &lt; T[j]) &#123;</span><br><span class=\"line\">                    res[i] = cnt;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>这种解法利用了栈的思想，这个栈记录的是每个放入值的下标（索引），并且最底部是最大的，依次往上递减，我们从头开始遍历数组，依次放入栈中，在每一次放之前，用当前的值和栈顶索引对应的值比较，如果比栈顶对应的值大，那么就知道了栈顶索引对应的最近距离较大的值是哪个，计入结果数组，同时移除，继续当前值和新的栈顶的值比较。（总觉得应该把这题归在Stack下）<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/daily-temperatures/\" target=\"_blank\" rel=\"noopener\">Daily Temperatures</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dailyTemperatures(<span class=\"keyword\">int</span>[] T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stack = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ret = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T.length; i++) &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top &gt; -<span class=\"number\">1</span> &amp;&amp; T[i] &gt; T[stack[top]]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> idx = stack[top--];</span><br><span class=\"line\">                ret[idx] = i - idx; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack[++top] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"290-Word-Pattern\"><a href=\"#290-Word-Pattern\" class=\"headerlink\" title=\"290. Word Pattern\"></a>290. Word Pattern</h3><p>题目大意给定几个单词组成的一个字符串，再给一个字符串代表几个单词的模式，问这几个单词是否匹配该模式。<br>Example 1:</p>\n<p>Input: pattern = “abba”, str = “dog cat cat dog”<br>Output: true<br>Example 2:</p>\n<p>Input:pattern = “abba”, str = “dog cat cat fish”<br>Output: false</p>\n<p>第一反应就是用map把单词和模式的字母做好一一映射的关系，然后就是逻辑判断了，如果包含key那么value不等说明不匹配，如果不包含key那么又存在value说明也不匹配，还有一种就是单词数和模式字符串长度不等也不匹配。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/word-pattern/\" target=\"_blank\" rel=\"noopener\">Word Pattern</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordPattern</span><span class=\"params\">(String pattern, String str)</span> </span>&#123;</span><br><span class=\"line\">        String[] s = str.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length != pattern.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;s.length; i++) &#123;</span><br><span class=\"line\">            String key = String.valueOf(pattern.charAt(i));</span><br><span class=\"line\">            String value  = s[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(key)) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(!map.get(key).equals(value)) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(map.containsValue(value)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                map.put(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"387-First-Unique-Character-in-a-String\"><a href=\"#387-First-Unique-Character-in-a-String\" class=\"headerlink\" title=\"387. First Unique Character in a String\"></a>387. First Unique Character in a String</h3><p>题目大意是找到给定字符串中第一次出现且不重复的字母的索引。<br>Examples:</p>\n<p>s = “leetcode”<br>return 0.</p>\n<p>s = “loveleetcode”,<br>return 2.</p>\n<h4 id=\"1-beat-100-解\"><a href=\"#1-beat-100-解\" class=\"headerlink\" title=\"1.beat 100%解\"></a>1.beat 100%解</h4><p>先贴一个beat 100%的答案，写的十分精简，简直完美。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lowest = len;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> i = <span class=\"string\">'a'</span>; i &lt;= <span class=\"string\">'z'</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = s.indexOf(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lowest &gt; first &amp;&amp; s.lastIndexOf(i) == first)  <span class=\"comment\">//仅出现一次，并且靠前</span></span><br><span class=\"line\">                    lowest = first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lowest == len ? -<span class=\"number\">1</span> :lowest;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-Map\"><a href=\"#2-Map\" class=\"headerlink\" title=\"2.Map\"></a>2.Map</h4><p>第二种自然是想到HashMap，官方给出的也是这种解，利用Map存储统计次数，但是Java中HashMap是无排序的，如果用LinkedHashMap就能根据放入先后顺序排了。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> key = s.charAt(i);</span><br><span class=\"line\">            map.put(key, map.getOrDefault(key, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Optional&lt;Entry&lt;Character, Integer&gt;&gt; res = map.entrySet().stream()</span><br><span class=\"line\">        .filter(x -&gt; x.getValue() == <span class=\"number\">1</span>).findFirst();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.isPresent()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s.indexOf(res.get().getKey());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-数组\"><a href=\"#3-数组\" class=\"headerlink\" title=\"3.数组\"></a>3.数组</h4><p>第三种就是利用数组统计。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = (<span class=\"keyword\">int</span>)(s.charAt(i) - <span class=\"string\">'a'</span>);</span><br><span class=\"line\">            nums[k]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(nums[(<span class=\"keyword\">int</span>)(s.charAt(i) - <span class=\"string\">'a'</span>)] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"739-Daily-Temperatures\"><a href=\"#739-Daily-Temperatures\" class=\"headerlink\" title=\"739. Daily Temperatures\"></a>739. Daily Temperatures</h3><p>题目大意给定一个整数数组表示温度，找出比当前温度高的日子最近需要几天，结果用数组表示，如果没有这样的一天，结果用0表示。例如T = [73, 74, 75, 71, 69, 72, 76, 73]，那么结果就是[1, 1, 4, 2, 1, 1, 0, 0]。其实就是找到比当前数字大的出现的第一个数字，求他们的距离。<br>第一想到暴力解法试试，能过，但是耗时两百多ms。</p>\n<h4 id=\"暴力解法\"><a href=\"#暴力解法\" class=\"headerlink\" title=\"暴力解法\"></a>暴力解法</h4><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/daily-temperatures/\" target=\"_blank\" rel=\"noopener\">Daily Temperatures</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dailyTemperatures(<span class=\"keyword\">int</span>[] T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = T.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j= i; j&lt;len; j++) &#123;              </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(T[i] &lt; T[j]) &#123;</span><br><span class=\"line\">                    res[i] = cnt;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>这种解法利用了栈的思想，这个栈记录的是每个放入值的下标（索引），并且最底部是最大的，依次往上递减，我们从头开始遍历数组，依次放入栈中，在每一次放之前，用当前的值和栈顶索引对应的值比较，如果比栈顶对应的值大，那么就知道了栈顶索引对应的最近距离较大的值是哪个，计入结果数组，同时移除，继续当前值和新的栈顶的值比较。（总觉得应该把这题归在Stack下）<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/daily-temperatures/\" target=\"_blank\" rel=\"noopener\">Daily Temperatures</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dailyTemperatures(<span class=\"keyword\">int</span>[] T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stack = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ret = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T.length; i++) &#123;   </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top &gt; -<span class=\"number\">1</span> &amp;&amp; T[i] &gt; T[stack[top]]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> idx = stack[top--];</span><br><span class=\"line\">                ret[idx] = i - idx; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack[++top] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"290-Word-Pattern\"><a href=\"#290-Word-Pattern\" class=\"headerlink\" title=\"290. Word Pattern\"></a>290. Word Pattern</h3><p>题目大意给定几个单词组成的一个字符串，再给一个字符串代表几个单词的模式，问这几个单词是否匹配该模式。<br>Example 1:</p>\n<p>Input: pattern = “abba”, str = “dog cat cat dog”<br>Output: true<br>Example 2:</p>\n<p>Input:pattern = “abba”, str = “dog cat cat fish”<br>Output: false</p>\n<p>第一反应就是用map把单词和模式的字母做好一一映射的关系，然后就是逻辑判断了，如果包含key那么value不等说明不匹配，如果不包含key那么又存在value说明也不匹配，还有一种就是单词数和模式字符串长度不等也不匹配。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/word-pattern/\" target=\"_blank\" rel=\"noopener\">Word Pattern</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordPattern</span><span class=\"params\">(String pattern, String str)</span> </span>&#123;</span><br><span class=\"line\">        String[] s = str.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length != pattern.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;s.length; i++) &#123;</span><br><span class=\"line\">            String key = String.valueOf(pattern.charAt(i));</span><br><span class=\"line\">            String value  = s[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(key)) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(!map.get(key).equals(value)) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(map.containsValue(value)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                map.put(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"387-First-Unique-Character-in-a-String\"><a href=\"#387-First-Unique-Character-in-a-String\" class=\"headerlink\" title=\"387. First Unique Character in a String\"></a>387. First Unique Character in a String</h3><p>题目大意是找到给定字符串中第一次出现且不重复的字母的索引。<br>Examples:</p>\n<p>s = “leetcode”<br>return 0.</p>\n<p>s = “loveleetcode”,<br>return 2.</p>\n<h4 id=\"1-beat-100-解\"><a href=\"#1-beat-100-解\" class=\"headerlink\" title=\"1.beat 100%解\"></a>1.beat 100%解</h4><p>先贴一个beat 100%的答案，写的十分精简，简直完美。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lowest = len;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> i = <span class=\"string\">'a'</span>; i &lt;= <span class=\"string\">'z'</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = s.indexOf(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lowest &gt; first &amp;&amp; s.lastIndexOf(i) == first)  <span class=\"comment\">//仅出现一次，并且靠前</span></span><br><span class=\"line\">                    lowest = first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lowest == len ? -<span class=\"number\">1</span> :lowest;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-Map\"><a href=\"#2-Map\" class=\"headerlink\" title=\"2.Map\"></a>2.Map</h4><p>第二种自然是想到HashMap，官方给出的也是这种解，利用Map存储统计次数，但是Java中HashMap是无排序的，如果用LinkedHashMap就能根据放入先后顺序排了。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> key = s.charAt(i);</span><br><span class=\"line\">            map.put(key, map.getOrDefault(key, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Optional&lt;Entry&lt;Character, Integer&gt;&gt; res = map.entrySet().stream()</span><br><span class=\"line\">        .filter(x -&gt; x.getValue() == <span class=\"number\">1</span>).findFirst();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.isPresent()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s.indexOf(res.get().getKey());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-数组\"><a href=\"#3-数组\" class=\"headerlink\" title=\"3.数组\"></a>3.数组</h4><p>第三种就是利用数组统计。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">First Unique Character in a String</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = (<span class=\"keyword\">int</span>)(s.charAt(i) - <span class=\"string\">'a'</span>);</span><br><span class=\"line\">            nums[k]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(nums[(<span class=\"keyword\">int</span>)(s.charAt(i) - <span class=\"string\">'a'</span>)] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"LeetCode Stack系列（一）","toc":true,"date":"2019-08-01T02:47:31.000Z","description":"Leetcode Stack 71/921/150/402","_content":"\n### 71. Simplify Path\n题目大意是给定一个unix下的绝对路径，然后要求简化成标准路径格式。\nExample 1:\nInput: \"/home/\"\nOutput: \"/home\"\nExplanation: 最后一个路径后面没有\"/\"\n\nExample 2:\nInput: \"/../\"\nOutput: \"/\"\nExplanation: root路径只有\"/\"\n\nExample 3:\nInput: \"/home//foo/\"\nOutput: \"/home/foo\"\n\nExample 4:\nInput: \"/a/./b/../../c/\"\nOutput: \"/c\"\n\n既然是用栈这种数据结构，那么很明显入栈的应该是路径名，\"/\"用来分割给定的路径字符串。既然确定了入栈的是路径名，那么什么时候出栈，用\"/\"分割字符串后剩下的只有路径名、\"\"空串、\".\"、\"..\"这四种情况，因为碰到\"..\"是像上一级，所以应该这时候出栈了。\n\n```Java Solution https://leetcode.com/problems/simplify-path/ Simplify Path\nclass Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>(); // Java推荐用ArrayDeque用作Stack\n        String[] arr = path.split(\"/\");\n        for(String s: arr) {\n            if(\".\".equals(s) || \"\".equals(s)) {\n                continue;\n            } else if (\"..\".equals(s)) {\n                if(!stack.isEmpty()) {\n                      stack.pop();\n                }\n            } else {\n                stack.push(s);\n            }\n        }\n        if(stack.isEmpty()) {\n            return \"/\";\n        }\n        StringBuilder sb = new StringBuilder();               \n        while(!stack.isEmpty()) {                         //Stack在这里用for遍历从底部开始，而ArrayDeque是从顶部开始\n            sb.append(\"/\").append(stack.pollLast());      //ArrayDeque是个双端队列，所以底部移除拼接\n        }\n        return sb.toString();\n    }\n}\n```\n### 921. Minimum Add to Make Parentheses Valid\n题目大意是给定一个只包含\"(\"、 \")\"的字符串，然后判断需要插入几个括号使得他有效（完美闭合），每一个左括号都有一个右括号与之对应。\nExample 1:\nInput: \"())\"\nOutput: 1\n\nExample 2:\nInput: \"(((\"\nOutput: 3\n\nExample 3:\nInput: \"()\"\nOutput: 0\n\nExample 4:\nInput: \"()))((\"\nOutput: 4\n\n思路还是找到入栈出栈的时机，这里入栈的元素既可以是\"(\"又可以是\")\"，每次新加入的括号只要不和栈顶的括号相等并且不是\"(\"，那么就有一个配对成功出栈，栈里剩的都是缺失的括号，统计即可得出答案。\n```Java Solution https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/  Minimum Add to Make Parentheses Valid\nclass Solution {\n    public int minAddToMakeValid(String S) {\n        Deque<Character> stack = new ArrayDeque<>();\n        char[] arr = S.toCharArray();\n        for(char c : arr) {\n            if(!stack.isEmpty() && stack.peek() != c && c != '(') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n### 150. Evaluate Reverse Polish Notation\n题目大意是给定一个字符串数组，里面包含数字和操作符，每次按照给定的操作符计算前面两个数，最终输出最后结果，题目保证了有结果并且除数不会为0。\n这里面入栈的元素就是数字，碰到操作符就出栈两个数，计算完成后还得再入栈。这里面如果用变量保存结果而不把结果入栈就不符合题目给定的先后运算关系了。\n```Java Solution https://leetcode.com/problems/evaluate-reverse-polish-notation/  Evaluate Reverse Polish Notation\nclass Solution {\n    public int evalRPN(String[] tokens) {\n         Deque<Integer> stack = new ArrayDeque<>();\n        int res = 0;\n        int a,b;\n        boolean flag = true;\n        for (String s :tokens) {\n           if(\"+\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a+b);\n            } else if(\"-\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a-b);\n            } else if(\"*\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a*b);\n            } else if (\"/\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a/b);\n            } else {\n                stack.push(Integer.valueOf(s));\n            }\n        }\n        return stack.peek();\n    }\n}\n```\n### 402. Remove K Digits\n题目大意是给定一个数字字符串和一个整数k，要求从这个字符串中移除k个数字字符后使得新的字符串表示的数字最小。不能以0开头，并且新的字符串为空时用0表示。\nExample 1:\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\n\nExample 2:\nInput: num = \"10200\", k = 1\nOutput: \"200\"\n\nExample 3:\nInput: num = \"10\", k = 2\nOutput: \"0\"\n\n既然要想组成最小数字，理论上就是高位越小越好，那么从头开始遍历把数字压入栈中，只要出现比栈顶小的数字那么栈顶数字移除继续和下一个栈顶数字比较，这里每出一次栈都要减小一次k，有可能还没遍历完k为0，也有可能遍历完k还不为0，当k不0时，只要继续栈顶移除就好了，因为在入栈时我们就保证了从小到大的顺序，最终只要从栈底部开始拼接输出就好了。注意剔除掉0开头的字符。\n```Java Solution https://leetcode.com/problems/remove-k-digits/  Remove K Digits\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Deque<Character> stack = new ArrayDeque<>();\n        char[] arr = num.toCharArray();\n        for (char c : arr) {\n            while(!stack.isEmpty() && k != 0 && stack.peek() > c) {  //出栈的时机\n                stack.pop();\n                k--;\n            }\n            stack.push(c);\n        }\n        while (k!=0) {\n            stack.pop();\n            k--;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            sb.append(stack.pollLast());\n        }\n        String a = sb.toString().replaceAll(\"^(0+)\", \"\");\n        return a.isEmpty() ? \"0\" : a;\n    }\n}\n```","source":"_posts/2019-08-01-LeetCode-Stack系列（一）.md","raw":"---\ntitle: LeetCode Stack系列（一）\ntoc: true\ndate: 2019-08-01 10:47:31\ntags: [LeetCode,Stack,algorithm]\ncategory: LeetCode\ndescription: Leetcode Stack 71/921/150/402\n---\n\n### 71. Simplify Path\n题目大意是给定一个unix下的绝对路径，然后要求简化成标准路径格式。\nExample 1:\nInput: \"/home/\"\nOutput: \"/home\"\nExplanation: 最后一个路径后面没有\"/\"\n\nExample 2:\nInput: \"/../\"\nOutput: \"/\"\nExplanation: root路径只有\"/\"\n\nExample 3:\nInput: \"/home//foo/\"\nOutput: \"/home/foo\"\n\nExample 4:\nInput: \"/a/./b/../../c/\"\nOutput: \"/c\"\n\n既然是用栈这种数据结构，那么很明显入栈的应该是路径名，\"/\"用来分割给定的路径字符串。既然确定了入栈的是路径名，那么什么时候出栈，用\"/\"分割字符串后剩下的只有路径名、\"\"空串、\".\"、\"..\"这四种情况，因为碰到\"..\"是像上一级，所以应该这时候出栈了。\n\n```Java Solution https://leetcode.com/problems/simplify-path/ Simplify Path\nclass Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>(); // Java推荐用ArrayDeque用作Stack\n        String[] arr = path.split(\"/\");\n        for(String s: arr) {\n            if(\".\".equals(s) || \"\".equals(s)) {\n                continue;\n            } else if (\"..\".equals(s)) {\n                if(!stack.isEmpty()) {\n                      stack.pop();\n                }\n            } else {\n                stack.push(s);\n            }\n        }\n        if(stack.isEmpty()) {\n            return \"/\";\n        }\n        StringBuilder sb = new StringBuilder();               \n        while(!stack.isEmpty()) {                         //Stack在这里用for遍历从底部开始，而ArrayDeque是从顶部开始\n            sb.append(\"/\").append(stack.pollLast());      //ArrayDeque是个双端队列，所以底部移除拼接\n        }\n        return sb.toString();\n    }\n}\n```\n### 921. Minimum Add to Make Parentheses Valid\n题目大意是给定一个只包含\"(\"、 \")\"的字符串，然后判断需要插入几个括号使得他有效（完美闭合），每一个左括号都有一个右括号与之对应。\nExample 1:\nInput: \"())\"\nOutput: 1\n\nExample 2:\nInput: \"(((\"\nOutput: 3\n\nExample 3:\nInput: \"()\"\nOutput: 0\n\nExample 4:\nInput: \"()))((\"\nOutput: 4\n\n思路还是找到入栈出栈的时机，这里入栈的元素既可以是\"(\"又可以是\")\"，每次新加入的括号只要不和栈顶的括号相等并且不是\"(\"，那么就有一个配对成功出栈，栈里剩的都是缺失的括号，统计即可得出答案。\n```Java Solution https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/  Minimum Add to Make Parentheses Valid\nclass Solution {\n    public int minAddToMakeValid(String S) {\n        Deque<Character> stack = new ArrayDeque<>();\n        char[] arr = S.toCharArray();\n        for(char c : arr) {\n            if(!stack.isEmpty() && stack.peek() != c && c != '(') {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n### 150. Evaluate Reverse Polish Notation\n题目大意是给定一个字符串数组，里面包含数字和操作符，每次按照给定的操作符计算前面两个数，最终输出最后结果，题目保证了有结果并且除数不会为0。\n这里面入栈的元素就是数字，碰到操作符就出栈两个数，计算完成后还得再入栈。这里面如果用变量保存结果而不把结果入栈就不符合题目给定的先后运算关系了。\n```Java Solution https://leetcode.com/problems/evaluate-reverse-polish-notation/  Evaluate Reverse Polish Notation\nclass Solution {\n    public int evalRPN(String[] tokens) {\n         Deque<Integer> stack = new ArrayDeque<>();\n        int res = 0;\n        int a,b;\n        boolean flag = true;\n        for (String s :tokens) {\n           if(\"+\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a+b);\n            } else if(\"-\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a-b);\n            } else if(\"*\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a*b);\n            } else if (\"/\".equals(s)) {\n                b = stack.pop();\n                a = stack.pop();\n                stack.push(a/b);\n            } else {\n                stack.push(Integer.valueOf(s));\n            }\n        }\n        return stack.peek();\n    }\n}\n```\n### 402. Remove K Digits\n题目大意是给定一个数字字符串和一个整数k，要求从这个字符串中移除k个数字字符后使得新的字符串表示的数字最小。不能以0开头，并且新的字符串为空时用0表示。\nExample 1:\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\n\nExample 2:\nInput: num = \"10200\", k = 1\nOutput: \"200\"\n\nExample 3:\nInput: num = \"10\", k = 2\nOutput: \"0\"\n\n既然要想组成最小数字，理论上就是高位越小越好，那么从头开始遍历把数字压入栈中，只要出现比栈顶小的数字那么栈顶数字移除继续和下一个栈顶数字比较，这里每出一次栈都要减小一次k，有可能还没遍历完k为0，也有可能遍历完k还不为0，当k不0时，只要继续栈顶移除就好了，因为在入栈时我们就保证了从小到大的顺序，最终只要从栈底部开始拼接输出就好了。注意剔除掉0开头的字符。\n```Java Solution https://leetcode.com/problems/remove-k-digits/  Remove K Digits\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Deque<Character> stack = new ArrayDeque<>();\n        char[] arr = num.toCharArray();\n        for (char c : arr) {\n            while(!stack.isEmpty() && k != 0 && stack.peek() > c) {  //出栈的时机\n                stack.pop();\n                k--;\n            }\n            stack.push(c);\n        }\n        while (k!=0) {\n            stack.pop();\n            k--;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            sb.append(stack.pollLast());\n        }\n        String a = sb.toString().replaceAll(\"^(0+)\", \"\");\n        return a.isEmpty() ? \"0\" : a;\n    }\n}\n```","slug":"LeetCode-Stack系列（一）","published":1,"updated":"2019-08-01T09:38:53.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewp2000ui0h6pptjgen4","content":"<h3 id=\"71-Simplify-Path\"><a href=\"#71-Simplify-Path\" class=\"headerlink\" title=\"71. Simplify Path\"></a>71. Simplify Path</h3><p>题目大意是给定一个unix下的绝对路径，然后要求简化成标准路径格式。<br>Example 1:<br>Input: “/home/“<br>Output: “/home”<br>Explanation: 最后一个路径后面没有”/“</p>\n<p>Example 2:<br>Input: “/../“<br>Output: “/“<br>Explanation: root路径只有”/“</p>\n<p>Example 3:<br>Input: “/home//foo/“<br>Output: “/home/foo”</p>\n<p>Example 4:<br>Input: “/a/./b/../../c/“<br>Output: “/c”</p>\n<p>既然是用栈这种数据结构，那么很明显入栈的应该是路径名，”/“用来分割给定的路径字符串。既然确定了入栈的是路径名，那么什么时候出栈，用”/“分割字符串后剩下的只有路径名、””空串、”.”、”..”这四种情况，因为碰到”..”是像上一级，所以应该这时候出栈了。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/simplify-path/\" target=\"_blank\" rel=\"noopener\">Simplify Path</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">simplifyPath</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;String&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;(); <span class=\"comment\">// Java推荐用ArrayDeque用作Stack</span></span><br><span class=\"line\">        String[] arr = path.split(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s: arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\".\"</span>.equals(s) || <span class=\"string\">\"\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"..\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">                      stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();               </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;                         <span class=\"comment\">//Stack在这里用for遍历从底部开始，而ArrayDeque是从顶部开始</span></span><br><span class=\"line\">            sb.append(<span class=\"string\">\"/\"</span>).append(stack.pollLast());      <span class=\"comment\">//ArrayDeque是个双端队列，所以底部移除拼接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"921-Minimum-Add-to-Make-Parentheses-Valid\"><a href=\"#921-Minimum-Add-to-Make-Parentheses-Valid\" class=\"headerlink\" title=\"921. Minimum Add to Make Parentheses Valid\"></a>921. Minimum Add to Make Parentheses Valid</h3><p>题目大意是给定一个只包含”(“、 “)”的字符串，然后判断需要插入几个括号使得他有效（完美闭合），每一个左括号都有一个右括号与之对应。<br>Example 1:<br>Input: “())”<br>Output: 1</p>\n<p>Example 2:<br>Input: “(((“<br>Output: 3</p>\n<p>Example 3:<br>Input: “()”<br>Output: 0</p>\n<p>Example 4:<br>Input: “()))((“<br>Output: 4</p>\n<p>思路还是找到入栈出栈的时机，这里入栈的元素既可以是”(“又可以是”)”，每次新加入的括号只要不和栈顶的括号相等并且不是”(“，那么就有一个配对成功出栈，栈里剩的都是缺失的括号，统计即可得出答案。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\" target=\"_blank\" rel=\"noopener\">Minimum Add to Make Parentheses Valid</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minAddToMakeValid</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = S.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != c &amp;&amp; c != <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"150-Evaluate-Reverse-Polish-Notation\"><a href=\"#150-Evaluate-Reverse-Polish-Notation\" class=\"headerlink\" title=\"150. Evaluate Reverse Polish Notation\"></a>150. Evaluate Reverse Polish Notation</h3><p>题目大意是给定一个字符串数组，里面包含数字和操作符，每次按照给定的操作符计算前面两个数，最终输出最后结果，题目保证了有结果并且除数不会为0。<br>这里面入栈的元素就是数字，碰到操作符就出栈两个数，计算完成后还得再入栈。这里面如果用变量保存结果而不把结果入栈就不符合题目给定的先后运算关系了。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener\">Evaluate Reverse Polish Notation</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(String[] tokens)</span> </span>&#123;</span><br><span class=\"line\">         Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s :tokens) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(<span class=\"string\">\"+\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a+b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"-\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a-b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"*\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a*b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"/\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a/b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(Integer.valueOf(s));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"402-Remove-K-Digits\"><a href=\"#402-Remove-K-Digits\" class=\"headerlink\" title=\"402. Remove K Digits\"></a>402. Remove K Digits</h3><p>题目大意是给定一个数字字符串和一个整数k，要求从这个字符串中移除k个数字字符后使得新的字符串表示的数字最小。不能以0开头，并且新的字符串为空时用0表示。<br>Example 1:<br>Input: num = “1432219”, k = 3<br>Output: “1219”</p>\n<p>Example 2:<br>Input: num = “10200”, k = 1<br>Output: “200”</p>\n<p>Example 3:<br>Input: num = “10”, k = 2<br>Output: “0”</p>\n<p>既然要想组成最小数字，理论上就是高位越小越好，那么从头开始遍历把数字压入栈中，只要出现比栈顶小的数字那么栈顶数字移除继续和下一个栈顶数字比较，这里每出一次栈都要减小一次k，有可能还没遍历完k为0，也有可能遍历完k还不为0，当k不0时，只要继续栈顶移除就好了，因为在入栈时我们就保证了从小到大的顺序，最终只要从栈底部开始拼接输出就好了。注意剔除掉0开头的字符。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/remove-k-digits/\" target=\"_blank\" rel=\"noopener\">Remove K Digits</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeKdigits</span><span class=\"params\">(String num, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = num.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack.isEmpty() &amp;&amp; k != <span class=\"number\">0</span> &amp;&amp; stack.peek() &gt; c) &#123;  <span class=\"comment\">//出栈的时机</span></span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack.push(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">            k--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            sb.append(stack.pollLast());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String a = sb.toString().replaceAll(<span class=\"string\">\"^(0+)\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.isEmpty() ? <span class=\"string\">\"0\"</span> : a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"71-Simplify-Path\"><a href=\"#71-Simplify-Path\" class=\"headerlink\" title=\"71. Simplify Path\"></a>71. Simplify Path</h3><p>题目大意是给定一个unix下的绝对路径，然后要求简化成标准路径格式。<br>Example 1:<br>Input: “/home/“<br>Output: “/home”<br>Explanation: 最后一个路径后面没有”/“</p>\n<p>Example 2:<br>Input: “/../“<br>Output: “/“<br>Explanation: root路径只有”/“</p>\n<p>Example 3:<br>Input: “/home//foo/“<br>Output: “/home/foo”</p>\n<p>Example 4:<br>Input: “/a/./b/../../c/“<br>Output: “/c”</p>\n<p>既然是用栈这种数据结构，那么很明显入栈的应该是路径名，”/“用来分割给定的路径字符串。既然确定了入栈的是路径名，那么什么时候出栈，用”/“分割字符串后剩下的只有路径名、””空串、”.”、”..”这四种情况，因为碰到”..”是像上一级，所以应该这时候出栈了。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/simplify-path/\" target=\"_blank\" rel=\"noopener\">Simplify Path</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">simplifyPath</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;String&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;(); <span class=\"comment\">// Java推荐用ArrayDeque用作Stack</span></span><br><span class=\"line\">        String[] arr = path.split(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String s: arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\".\"</span>.equals(s) || <span class=\"string\">\"\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"..\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">                      stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"/\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();               </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;                         <span class=\"comment\">//Stack在这里用for遍历从底部开始，而ArrayDeque是从顶部开始</span></span><br><span class=\"line\">            sb.append(<span class=\"string\">\"/\"</span>).append(stack.pollLast());      <span class=\"comment\">//ArrayDeque是个双端队列，所以底部移除拼接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"921-Minimum-Add-to-Make-Parentheses-Valid\"><a href=\"#921-Minimum-Add-to-Make-Parentheses-Valid\" class=\"headerlink\" title=\"921. Minimum Add to Make Parentheses Valid\"></a>921. Minimum Add to Make Parentheses Valid</h3><p>题目大意是给定一个只包含”(“、 “)”的字符串，然后判断需要插入几个括号使得他有效（完美闭合），每一个左括号都有一个右括号与之对应。<br>Example 1:<br>Input: “())”<br>Output: 1</p>\n<p>Example 2:<br>Input: “(((“<br>Output: 3</p>\n<p>Example 3:<br>Input: “()”<br>Output: 0</p>\n<p>Example 4:<br>Input: “()))((“<br>Output: 4</p>\n<p>思路还是找到入栈出栈的时机，这里入栈的元素既可以是”(“又可以是”)”，每次新加入的括号只要不和栈顶的括号相等并且不是”(“，那么就有一个配对成功出栈，栈里剩的都是缺失的括号，统计即可得出答案。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\" target=\"_blank\" rel=\"noopener\">Minimum Add to Make Parentheses Valid</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minAddToMakeValid</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = S.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() != c &amp;&amp; c != <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"150-Evaluate-Reverse-Polish-Notation\"><a href=\"#150-Evaluate-Reverse-Polish-Notation\" class=\"headerlink\" title=\"150. Evaluate Reverse Polish Notation\"></a>150. Evaluate Reverse Polish Notation</h3><p>题目大意是给定一个字符串数组，里面包含数字和操作符，每次按照给定的操作符计算前面两个数，最终输出最后结果，题目保证了有结果并且除数不会为0。<br>这里面入栈的元素就是数字，碰到操作符就出栈两个数，计算完成后还得再入栈。这里面如果用变量保存结果而不把结果入栈就不符合题目给定的先后运算关系了。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener\">Evaluate Reverse Polish Notation</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(String[] tokens)</span> </span>&#123;</span><br><span class=\"line\">         Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s :tokens) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(<span class=\"string\">\"+\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a+b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"-\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a-b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"*\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a*b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"/\"</span>.equals(s)) &#123;</span><br><span class=\"line\">                b = stack.pop();</span><br><span class=\"line\">                a = stack.pop();</span><br><span class=\"line\">                stack.push(a/b);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(Integer.valueOf(s));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"402-Remove-K-Digits\"><a href=\"#402-Remove-K-Digits\" class=\"headerlink\" title=\"402. Remove K Digits\"></a>402. Remove K Digits</h3><p>题目大意是给定一个数字字符串和一个整数k，要求从这个字符串中移除k个数字字符后使得新的字符串表示的数字最小。不能以0开头，并且新的字符串为空时用0表示。<br>Example 1:<br>Input: num = “1432219”, k = 3<br>Output: “1219”</p>\n<p>Example 2:<br>Input: num = “10200”, k = 1<br>Output: “200”</p>\n<p>Example 3:<br>Input: num = “10”, k = 2<br>Output: “0”</p>\n<p>既然要想组成最小数字，理论上就是高位越小越好，那么从头开始遍历把数字压入栈中，只要出现比栈顶小的数字那么栈顶数字移除继续和下一个栈顶数字比较，这里每出一次栈都要减小一次k，有可能还没遍历完k为0，也有可能遍历完k还不为0，当k不0时，只要继续栈顶移除就好了，因为在入栈时我们就保证了从小到大的顺序，最终只要从栈底部开始拼接输出就好了。注意剔除掉0开头的字符。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/remove-k-digits/\" target=\"_blank\" rel=\"noopener\">Remove K Digits</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeKdigits</span><span class=\"params\">(String num, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = num.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack.isEmpty() &amp;&amp; k != <span class=\"number\">0</span> &amp;&amp; stack.peek() &gt; c) &#123;  <span class=\"comment\">//出栈的时机</span></span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack.push(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">            k--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            sb.append(stack.pollLast());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String a = sb.toString().replaceAll(<span class=\"string\">\"^(0+)\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.isEmpty() ? <span class=\"string\">\"0\"</span> : a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"移动端Video标签踩坑记录","toc":true,"date":"2019-08-05T02:25:39.000Z","description":"本文主要记录了一下video标签在手机端展示的一些坑，ios下video标签默认封面为空白，以及相对应采取的简单措施。","_content":"\n### 需求\n用户能在手机上上传视频并预览。\n\n### 问题\n1. 上传完成后安卓下封面展示正常，ios下封面空白。如下图所示：\n![ios下上传成功后的展示](ios-blank-video.png)\n2. 利用canvas截取视频第一帧发现，ios下截取到的第一帧一直是空白图片, 安卓正常。\n3. 后端利用javacv库截取，返回给前台封面图，ios竖屏拍摄下的视频截取到的图片有90度旋转，javacv库无法取得旋转信息，但是控制台打印出的视频元信息带有旋转信息。安卓无论横屏竖屏都没有旋转。\n\n### 解决方案\n1. 上述的前两个问题，ios下html开发的文档中指出了video标签只有用户触发了playback才会展示封面图，否则建议指定poster，参考链接如下\n<https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1>\n那么既然要触发播放，我就想到利用js模拟click事件之后截取第一帧，发现依然是空白，于是放弃用后台截取。\n这里如果前端能实现利用第一帧作为封面图，那么视频上传预览时，完全不必要把视频传到后端了，利用URL.createObjectURL这个api可以轻松做到前端预览，但是由于这个封面问题只能上传到后端。\n2. 后端利用javacv轻松截取到，但是竖屏拍摄图片旋转的问题难以解决。不知道为何getMetaData获取到的永远是个空的map，但是控制台红色输出的信息中又包含了各种元信息，虽然怀疑是java调用c的api出了问题，但是水平实在不够，于是只能放弃。最终由于时间紧，也没要求到必须旋转回来，毕竟空白问题解决，所以只能草草了之。但是也预备了个方案，继续寻找第三方能获取到视频元信息的依赖，这条路肯定是可以走通的。\n\n### 总结\n移动端的坑还是挺多的，尤其是展示上的，除此以外就是考虑到wx这个大平台的展示，只能是碰到了就一点点的记录。但是随着技术的发展，这点小坑终将会被填平。\n","source":"_posts/2019-08-05-移动端Video标签踩坑记录.md","raw":"---\ntitle: 移动端Video标签踩坑记录\ntoc: true\ndate: 2019-08-05 10:25:39\ntags: [html, js, video, canvas, ios, Android, mobile, 前端]\ncategory: 前端\ndescription: 本文主要记录了一下video标签在手机端展示的一些坑，ios下video标签默认封面为空白，以及相对应采取的简单措施。\n---\n\n### 需求\n用户能在手机上上传视频并预览。\n\n### 问题\n1. 上传完成后安卓下封面展示正常，ios下封面空白。如下图所示：\n![ios下上传成功后的展示](ios-blank-video.png)\n2. 利用canvas截取视频第一帧发现，ios下截取到的第一帧一直是空白图片, 安卓正常。\n3. 后端利用javacv库截取，返回给前台封面图，ios竖屏拍摄下的视频截取到的图片有90度旋转，javacv库无法取得旋转信息，但是控制台打印出的视频元信息带有旋转信息。安卓无论横屏竖屏都没有旋转。\n\n### 解决方案\n1. 上述的前两个问题，ios下html开发的文档中指出了video标签只有用户触发了playback才会展示封面图，否则建议指定poster，参考链接如下\n<https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1>\n那么既然要触发播放，我就想到利用js模拟click事件之后截取第一帧，发现依然是空白，于是放弃用后台截取。\n这里如果前端能实现利用第一帧作为封面图，那么视频上传预览时，完全不必要把视频传到后端了，利用URL.createObjectURL这个api可以轻松做到前端预览，但是由于这个封面问题只能上传到后端。\n2. 后端利用javacv轻松截取到，但是竖屏拍摄图片旋转的问题难以解决。不知道为何getMetaData获取到的永远是个空的map，但是控制台红色输出的信息中又包含了各种元信息，虽然怀疑是java调用c的api出了问题，但是水平实在不够，于是只能放弃。最终由于时间紧，也没要求到必须旋转回来，毕竟空白问题解决，所以只能草草了之。但是也预备了个方案，继续寻找第三方能获取到视频元信息的依赖，这条路肯定是可以走通的。\n\n### 总结\n移动端的坑还是挺多的，尤其是展示上的，除此以外就是考虑到wx这个大平台的展示，只能是碰到了就一点点的记录。但是随着技术的发展，这点小坑终将会被填平。\n","slug":"移动端Video标签踩坑记录","published":1,"updated":"2019-08-05T03:16:07.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewp5000xi0h6g3gvbt6y","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>用户能在手机上上传视频并预览。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li>上传完成后安卓下封面展示正常，ios下封面空白。如下图所示：<br><img src=\"ios-blank-video.png\" alt=\"ios下上传成功后的展示\"></li>\n<li>利用canvas截取视频第一帧发现，ios下截取到的第一帧一直是空白图片, 安卓正常。</li>\n<li>后端利用javacv库截取，返回给前台封面图，ios竖屏拍摄下的视频截取到的图片有90度旋转，javacv库无法取得旋转信息，但是控制台打印出的视频元信息带有旋转信息。安卓无论横屏竖屏都没有旋转。</li>\n</ol>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>上述的前两个问题，ios下html开发的文档中指出了video标签只有用户触发了playback才会展示封面图，否则建议指定poster，参考链接如下<br><a href=\"https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1</a><br>那么既然要触发播放，我就想到利用js模拟click事件之后截取第一帧，发现依然是空白，于是放弃用后台截取。<br>这里如果前端能实现利用第一帧作为封面图，那么视频上传预览时，完全不必要把视频传到后端了，利用URL.createObjectURL这个api可以轻松做到前端预览，但是由于这个封面问题只能上传到后端。</li>\n<li>后端利用javacv轻松截取到，但是竖屏拍摄图片旋转的问题难以解决。不知道为何getMetaData获取到的永远是个空的map，但是控制台红色输出的信息中又包含了各种元信息，虽然怀疑是java调用c的api出了问题，但是水平实在不够，于是只能放弃。最终由于时间紧，也没要求到必须旋转回来，毕竟空白问题解决，所以只能草草了之。但是也预备了个方案，继续寻找第三方能获取到视频元信息的依赖，这条路肯定是可以走通的。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>移动端的坑还是挺多的，尤其是展示上的，除此以外就是考虑到wx这个大平台的展示，只能是碰到了就一点点的记录。但是随着技术的发展，这点小坑终将会被填平。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>用户能在手机上上传视频并预览。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li>上传完成后安卓下封面展示正常，ios下封面空白。如下图所示：<br><img src=\"ios-blank-video.png\" alt=\"ios下上传成功后的展示\"></li>\n<li>利用canvas截取视频第一帧发现，ios下截取到的第一帧一直是空白图片, 安卓正常。</li>\n<li>后端利用javacv库截取，返回给前台封面图，ios竖屏拍摄下的视频截取到的图片有90度旋转，javacv库无法取得旋转信息，但是控制台打印出的视频元信息带有旋转信息。安卓无论横屏竖屏都没有旋转。</li>\n</ol>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>上述的前两个问题，ios下html开发的文档中指出了video标签只有用户触发了playback才会展示封面图，否则建议指定poster，参考链接如下<br><a href=\"https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1</a><br>那么既然要触发播放，我就想到利用js模拟click事件之后截取第一帧，发现依然是空白，于是放弃用后台截取。<br>这里如果前端能实现利用第一帧作为封面图，那么视频上传预览时，完全不必要把视频传到后端了，利用URL.createObjectURL这个api可以轻松做到前端预览，但是由于这个封面问题只能上传到后端。</li>\n<li>后端利用javacv轻松截取到，但是竖屏拍摄图片旋转的问题难以解决。不知道为何getMetaData获取到的永远是个空的map，但是控制台红色输出的信息中又包含了各种元信息，虽然怀疑是java调用c的api出了问题，但是水平实在不够，于是只能放弃。最终由于时间紧，也没要求到必须旋转回来，毕竟空白问题解决，所以只能草草了之。但是也预备了个方案，继续寻找第三方能获取到视频元信息的依赖，这条路肯定是可以走通的。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>移动端的坑还是挺多的，尤其是展示上的，除此以外就是考虑到wx这个大平台的展示，只能是碰到了就一点点的记录。但是随着技术的发展，这点小坑终将会被填平。</p>\n"},{"title":"LeetCode Sort系列（一）","toc":true,"date":"2019-08-13T03:45:20.000Z","description":"Leetcode Sort 1030/349/350/1122","_content":"\n### 1030. Matrix Cells in Distance Order\n题目大意是给定一个R行C列的坐标网格，再给定一个（r0, c0）的坐标点, 把坐标网格中的点与该点的距离按照从小到大的顺序排列出来。\n这里用了discuss里面的计数排序的解法，把距离存入了计数的数组中，距离重复就累加。\n\n```Java Solution https://leetcode.com/problems/matrix-cells-in-distance-order/ Matrix Cells in Distance Order\nclass Solution {\n    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) {\n        int[][] res = new int[R*C][2];\n        int[] count = new int[R+C];\n        for(int i=0; i<R; i++) {\n            for (int j=0; j<C; j++) {\n                int dis = Math.abs(i - r0) + Math.abs(j - c0);\n                count[dis]++;\n            }\n        }\n        for (int i=1; i<count.length; i++) {\n            count[i] = count[i] + count[i-1];\n        }\n        for (int i=0; i<R; i++) {\n            for (int j=0; j<C; j++) {\n                int dis = Math.abs(i - r0) + Math.abs(j - c0);\n                res[count[dis] - 1] = new int[]{i,j};\n                count[dis]--;\n            }\n        }\n        return res;\n    }\n}\n```\n### 349. Intersection of Two Arrays\n题目大意是给定两个整型数组，找出他们的交集，需要去重。\n最暴力的就是嵌套遍历把相等的数放入set，其次就是把两个数组里的数都放入set，再调用set自身取交集的api。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays/ intersection-of-two-arrays\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        HashSet<Integer> set1 = new HashSet<Integer>();\n    \tfor (Integer n : nums1) set1.add(n);\n    \tHashSet<Integer> set2 = new HashSet<Integer>();\n    \tfor (Integer n : nums2) set2.add(n);\n\n   \t\tset1.retainAll(set2);\n\n    \tint [] res = new int[set1.size()];\n    \tint idx = 0;\n    \tfor (int s : set1) res[idx++] = s;\n    \treturn res;\n    }\n     \n} \n```\n还有一种就是先将一个数组排序，再利用二叉查找搜索。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays/ intersection-of-two-arrays\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n\t\tint i = 0;\n\t\tArrays.sort(nums1);\n\t\tfor(int n : nums2) {\n            if(Arrays.binarySearch(nums1, n) >= 0) {\n                set.add(n);\n            }\n        }\n        int[] res = new int[set.size()];\n\t\tfor (int n : set) {\n            res[i++] = n;\n        }\n        return res;\n    }\n     \n} \n```\n### 350. Intersection of Two Arrays II\n这个题目只要求交集不用去重，那么我们就不能用HashSet了。第一种是利用HashMap，key保存第一个数组中元素，value保存出现的次数，再遍历第二个数组判断map中是否存在，若存在次数减一。这里贴一下第二种解法，把两个数组都排序后从小到大比较。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays-ii/  Intersection of Two Arrays II\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0, j = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if(nums1[i] == nums2[j]) {\n                list.add(nums1[i]);\n                i++;j++;\n            } else if(nums1[i] < nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        int[] res = new int[list.size()];\n        int k = 0;\n        for (int n : list) {\n            res[k++] = n;\n        }\n        return res;\n    }\n     \n} \n```\n### 1122. Relative Sort Array\n题目大意是给定两个数组arr1，arr2，arr2中元素不重复且都在arr1中，要求把arr1中和arr2中重复的元素按照arr2中元素顺序排序，其余元素从小到大排到后面。这里面感觉最牛逼的解法还是之前提到的计数排序，因为这里面限制了arr1,arr2内的元素大小和长度都小于等于1000，那我们可以用一个1001大小的count数组记录arr1中元素个数。\n```Java Solution https://leetcode.com/problems/relative-sort-array/submissions/ Relative Sort Array\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        for(int a : arr1) count[a]++;\n        int i = 0;\n        for(int b : arr2) {                // 先按arr2中元素排好\n            while(count[b]-- > 0) {\n                arr1[i++] = b;\n            }\n        }\n        for(int k=0; k<1001; k++) {      // 其余部分从小到追加\n            while(count[k]-- > 0) {\n                arr1[i++] = k;\n            }\n        }\n        return arr1;\n    }\n}\n```\ndiscuss里面提到说如果没有了小于等于1000的限制，那我们就把存储个数的count数组换成TreeMap这种数据结构。\n\n","source":"_posts/2019-08-13-LeetCode-Sort系列（一）.md","raw":"---\ntitle: LeetCode Sort系列（一）\ntoc: true\ndate: 2019-08-13 11:45:20\ntags: [LeetCode,Sort,algorithm]\ncategory: LeetCode\ndescription: Leetcode Sort 1030/349/350/1122\n---\n\n### 1030. Matrix Cells in Distance Order\n题目大意是给定一个R行C列的坐标网格，再给定一个（r0, c0）的坐标点, 把坐标网格中的点与该点的距离按照从小到大的顺序排列出来。\n这里用了discuss里面的计数排序的解法，把距离存入了计数的数组中，距离重复就累加。\n\n```Java Solution https://leetcode.com/problems/matrix-cells-in-distance-order/ Matrix Cells in Distance Order\nclass Solution {\n    public int[][] allCellsDistOrder(int R, int C, int r0, int c0) {\n        int[][] res = new int[R*C][2];\n        int[] count = new int[R+C];\n        for(int i=0; i<R; i++) {\n            for (int j=0; j<C; j++) {\n                int dis = Math.abs(i - r0) + Math.abs(j - c0);\n                count[dis]++;\n            }\n        }\n        for (int i=1; i<count.length; i++) {\n            count[i] = count[i] + count[i-1];\n        }\n        for (int i=0; i<R; i++) {\n            for (int j=0; j<C; j++) {\n                int dis = Math.abs(i - r0) + Math.abs(j - c0);\n                res[count[dis] - 1] = new int[]{i,j};\n                count[dis]--;\n            }\n        }\n        return res;\n    }\n}\n```\n### 349. Intersection of Two Arrays\n题目大意是给定两个整型数组，找出他们的交集，需要去重。\n最暴力的就是嵌套遍历把相等的数放入set，其次就是把两个数组里的数都放入set，再调用set自身取交集的api。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays/ intersection-of-two-arrays\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        HashSet<Integer> set1 = new HashSet<Integer>();\n    \tfor (Integer n : nums1) set1.add(n);\n    \tHashSet<Integer> set2 = new HashSet<Integer>();\n    \tfor (Integer n : nums2) set2.add(n);\n\n   \t\tset1.retainAll(set2);\n\n    \tint [] res = new int[set1.size()];\n    \tint idx = 0;\n    \tfor (int s : set1) res[idx++] = s;\n    \treturn res;\n    }\n     \n} \n```\n还有一种就是先将一个数组排序，再利用二叉查找搜索。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays/ intersection-of-two-arrays\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n\t\tint i = 0;\n\t\tArrays.sort(nums1);\n\t\tfor(int n : nums2) {\n            if(Arrays.binarySearch(nums1, n) >= 0) {\n                set.add(n);\n            }\n        }\n        int[] res = new int[set.size()];\n\t\tfor (int n : set) {\n            res[i++] = n;\n        }\n        return res;\n    }\n     \n} \n```\n### 350. Intersection of Two Arrays II\n这个题目只要求交集不用去重，那么我们就不能用HashSet了。第一种是利用HashMap，key保存第一个数组中元素，value保存出现的次数，再遍历第二个数组判断map中是否存在，若存在次数减一。这里贴一下第二种解法，把两个数组都排序后从小到大比较。\n```Java Solution https://leetcode.com/problems/intersection-of-two-arrays-ii/  Intersection of Two Arrays II\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0, j = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if(nums1[i] == nums2[j]) {\n                list.add(nums1[i]);\n                i++;j++;\n            } else if(nums1[i] < nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        int[] res = new int[list.size()];\n        int k = 0;\n        for (int n : list) {\n            res[k++] = n;\n        }\n        return res;\n    }\n     \n} \n```\n### 1122. Relative Sort Array\n题目大意是给定两个数组arr1，arr2，arr2中元素不重复且都在arr1中，要求把arr1中和arr2中重复的元素按照arr2中元素顺序排序，其余元素从小到大排到后面。这里面感觉最牛逼的解法还是之前提到的计数排序，因为这里面限制了arr1,arr2内的元素大小和长度都小于等于1000，那我们可以用一个1001大小的count数组记录arr1中元素个数。\n```Java Solution https://leetcode.com/problems/relative-sort-array/submissions/ Relative Sort Array\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        for(int a : arr1) count[a]++;\n        int i = 0;\n        for(int b : arr2) {                // 先按arr2中元素排好\n            while(count[b]-- > 0) {\n                arr1[i++] = b;\n            }\n        }\n        for(int k=0; k<1001; k++) {      // 其余部分从小到追加\n            while(count[k]-- > 0) {\n                arr1[i++] = k;\n            }\n        }\n        return arr1;\n    }\n}\n```\ndiscuss里面提到说如果没有了小于等于1000的限制，那我们就把存储个数的count数组换成TreeMap这种数据结构。\n\n","slug":"LeetCode-Sort系列（一）","published":1,"updated":"2019-08-14T08:14:21.909Z","_id":"cjzawewp70010i0h63hm9no7v","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1030-Matrix-Cells-in-Distance-Order\"><a href=\"#1030-Matrix-Cells-in-Distance-Order\" class=\"headerlink\" title=\"1030. Matrix Cells in Distance Order\"></a>1030. Matrix Cells in Distance Order</h3><p>题目大意是给定一个R行C列的坐标网格，再给定一个（r0, c0）的坐标点, 把坐标网格中的点与该点的距离按照从小到大的顺序排列出来。<br>这里用了discuss里面的计数排序的解法，把距离存入了计数的数组中，距离重复就累加。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/matrix-cells-in-distance-order/\" target=\"_blank\" rel=\"noopener\">Matrix Cells in Distance Order</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] allCellsDistOrder(<span class=\"keyword\">int</span> R, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> r0, <span class=\"keyword\">int</span> c0) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R*C][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R+C];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;R; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dis = Math.abs(i - r0) + Math.abs(j - c0);</span><br><span class=\"line\">                count[dis]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;count.length; i++) &#123;</span><br><span class=\"line\">            count[i] = count[i] + count[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;R; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dis = Math.abs(i - r0) + Math.abs(j - c0);</span><br><span class=\"line\">                res[count[dis] - <span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i,j&#125;;</span><br><span class=\"line\">                count[dis]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"349-Intersection-of-Two-Arrays\"><a href=\"#349-Intersection-of-Two-Arrays\" class=\"headerlink\" title=\"349. Intersection of Two Arrays\"></a>349. Intersection of Two Arrays</h3><p>题目大意是给定两个整型数组，找出他们的交集，需要去重。<br>最暴力的就是嵌套遍历把相等的数放入set，其次就是把两个数组里的数都放入set，再调用set自身取交集的api。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">intersection-of-two-arrays</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        HashSet&lt;Integer&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (Integer n : nums1) set1.add(n);</span><br><span class=\"line\">    \tHashSet&lt;Integer&gt; set2 = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (Integer n : nums2) set2.add(n);</span><br><span class=\"line\"></span><br><span class=\"line\">   \t\tset1.retainAll(set2);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> [] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[set1.size()];</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> s : set1) res[idx++] = s;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一种就是先将一个数组排序，再利用二叉查找搜索。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">intersection-of-two-arrays</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tArrays.sort(nums1);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Arrays.binarySearch(nums1, n) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                set.add(n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[set.size()];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : set) &#123;</span><br><span class=\"line\">            res[i++] = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"350-Intersection-of-Two-Arrays-II\"><a href=\"#350-Intersection-of-Two-Arrays-II\" class=\"headerlink\" title=\"350. Intersection of Two Arrays II\"></a>350. Intersection of Two Arrays II</h3><p>这个题目只要求交集不用去重，那么我们就不能用HashSet了。第一种是利用HashMap，key保存第一个数组中元素，value保存出现的次数，再遍历第二个数组判断map中是否存在，若存在次数减一。这里贴一下第二种解法，把两个数组都排序后从小到大比较。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays II</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums1);</span><br><span class=\"line\">        Arrays.sort(nums2);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class=\"line\">                list.add(nums1[i]);</span><br><span class=\"line\">                i++;j++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums1[i] &lt; nums2[j]) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : list) &#123;</span><br><span class=\"line\">            res[k++] = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1122-Relative-Sort-Array\"><a href=\"#1122-Relative-Sort-Array\" class=\"headerlink\" title=\"1122. Relative Sort Array\"></a>1122. Relative Sort Array</h3><p>题目大意是给定两个数组arr1，arr2，arr2中元素不重复且都在arr1中，要求把arr1中和arr2中重复的元素按照arr2中元素顺序排序，其余元素从小到大排到后面。这里面感觉最牛逼的解法还是之前提到的计数排序，因为这里面限制了arr1,arr2内的元素大小和长度都小于等于1000，那我们可以用一个1001大小的count数组记录arr1中元素个数。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/relative-sort-array/submissions/\" target=\"_blank\" rel=\"noopener\">Relative Sort Array</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] relativeSortArray(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1001</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a : arr1) count[a]++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> b : arr2) &#123;                <span class=\"comment\">// 先按arr2中元素排好</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count[b]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                arr1[i++] = b;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k&lt;<span class=\"number\">1001</span>; k++) &#123;      <span class=\"comment\">// 其余部分从小到追加</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count[k]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                arr1[i++] = k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>discuss里面提到说如果没有了小于等于1000的限制，那我们就把存储个数的count数组换成TreeMap这种数据结构。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1030-Matrix-Cells-in-Distance-Order\"><a href=\"#1030-Matrix-Cells-in-Distance-Order\" class=\"headerlink\" title=\"1030. Matrix Cells in Distance Order\"></a>1030. Matrix Cells in Distance Order</h3><p>题目大意是给定一个R行C列的坐标网格，再给定一个（r0, c0）的坐标点, 把坐标网格中的点与该点的距离按照从小到大的顺序排列出来。<br>这里用了discuss里面的计数排序的解法，把距离存入了计数的数组中，距离重复就累加。</p>\n<figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/matrix-cells-in-distance-order/\" target=\"_blank\" rel=\"noopener\">Matrix Cells in Distance Order</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] allCellsDistOrder(<span class=\"keyword\">int</span> R, <span class=\"keyword\">int</span> C, <span class=\"keyword\">int</span> r0, <span class=\"keyword\">int</span> c0) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R*C][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R+C];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;R; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dis = Math.abs(i - r0) + Math.abs(j - c0);</span><br><span class=\"line\">                count[dis]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;count.length; i++) &#123;</span><br><span class=\"line\">            count[i] = count[i] + count[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;R; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dis = Math.abs(i - r0) + Math.abs(j - c0);</span><br><span class=\"line\">                res[count[dis] - <span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i,j&#125;;</span><br><span class=\"line\">                count[dis]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"349-Intersection-of-Two-Arrays\"><a href=\"#349-Intersection-of-Two-Arrays\" class=\"headerlink\" title=\"349. Intersection of Two Arrays\"></a>349. Intersection of Two Arrays</h3><p>题目大意是给定两个整型数组，找出他们的交集，需要去重。<br>最暴力的就是嵌套遍历把相等的数放入set，其次就是把两个数组里的数都放入set，再调用set自身取交集的api。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">intersection-of-two-arrays</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        HashSet&lt;Integer&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (Integer n : nums1) set1.add(n);</span><br><span class=\"line\">    \tHashSet&lt;Integer&gt; set2 = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (Integer n : nums2) set2.add(n);</span><br><span class=\"line\"></span><br><span class=\"line\">   \t\tset1.retainAll(set2);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> [] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[set1.size()];</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> s : set1) res[idx++] = s;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还有一种就是先将一个数组排序，再利用二叉查找搜索。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays/\" target=\"_blank\" rel=\"noopener\">intersection-of-two-arrays</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tArrays.sort(nums1);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Arrays.binarySearch(nums1, n) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                set.add(n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[set.size()];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : set) &#123;</span><br><span class=\"line\">            res[i++] = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"350-Intersection-of-Two-Arrays-II\"><a href=\"#350-Intersection-of-Two-Arrays-II\" class=\"headerlink\" title=\"350. Intersection of Two Arrays II\"></a>350. Intersection of Two Arrays II</h3><p>这个题目只要求交集不用去重，那么我们就不能用HashSet了。第一种是利用HashMap，key保存第一个数组中元素，value保存出现的次数，再遍历第二个数组判断map中是否存在，若存在次数减一。这里贴一下第二种解法，把两个数组都排序后从小到大比较。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/intersection-of-two-arrays-ii/\" target=\"_blank\" rel=\"noopener\">Intersection of Two Arrays II</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intersection(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums1);</span><br><span class=\"line\">        Arrays.sort(nums2);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class=\"line\">                list.add(nums1[i]);</span><br><span class=\"line\">                i++;j++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums1[i] &lt; nums2[j]) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : list) &#123;</span><br><span class=\"line\">            res[k++] = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1122-Relative-Sort-Array\"><a href=\"#1122-Relative-Sort-Array\" class=\"headerlink\" title=\"1122. Relative Sort Array\"></a>1122. Relative Sort Array</h3><p>题目大意是给定两个数组arr1，arr2，arr2中元素不重复且都在arr1中，要求把arr1中和arr2中重复的元素按照arr2中元素顺序排序，其余元素从小到大排到后面。这里面感觉最牛逼的解法还是之前提到的计数排序，因为这里面限制了arr1,arr2内的元素大小和长度都小于等于1000，那我们可以用一个1001大小的count数组记录arr1中元素个数。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://leetcode.com/problems/relative-sort-array/submissions/\" target=\"_blank\" rel=\"noopener\">Relative Sort Array</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] relativeSortArray(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1001</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a : arr1) count[a]++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> b : arr2) &#123;                <span class=\"comment\">// 先按arr2中元素排好</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count[b]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                arr1[i++] = b;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k&lt;<span class=\"number\">1001</span>; k++) &#123;      <span class=\"comment\">// 其余部分从小到追加</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count[k]-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                arr1[i++] = k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>discuss里面提到说如果没有了小于等于1000的限制，那我们就把存储个数的count数组换成TreeMap这种数据结构。</p>\n"},{"title":"CodingBat  递归练习题解","toc":true,"date":"2019-08-09T03:14:41.000Z","description":null,"_content":"\n一直以来，我理解递归都觉得很困难，简单点的还好，leetcode里有些复杂晦涩冗长的递归真的是太难理解了，所以特地从头训练一遍递归的题目找找感觉，<https://codingbat.com/java> 这个里面的递归练习的题目就很符合我的口味，循序渐进，第一部分的递归基础题目很简单，大概抽空花了两个早上做完了。这里主要记录第二部分难度稍微大一点的递归题目的我的题解。\n\n### groupSum \n题目大意是给定一个整型数组，和一个目标数，从数组中找出一组数要满足这组数的和与目标数相等，如果存在返回true，不存在返回false，不能用循环。\n思路就是从这数组中找数字，无非就是两种情况，这个数字要不要，如果选择了那么我们的target就减掉它，如果没选择target保持不变，到最后的递归退出就是判断target是否等于0。\nExamples:\n\tgroupSum(0, [2, 4, 8], 10) → true\n\tgroupSum(0, [2, 4, 8], 14) → true\n\tgroupSum(0, [2, 4, 8], 9) → false\n```Java Solution https://codingbat.com/prob/p145416 groupSum\npublic boolean groupSum(int start, int[] nums, int target) {\n   if(start >= nums.length ) return target == 0;\n   return groupSum(start+1, nums,target) || groupSum(start+1, nums, target-nums[start]);\n}\n```\n### groupSum6 \n这道题比上面多了个限制条件就是6必须选。\n```Java Solution https://codingbat.com/prob/p199368 groupSum6\npublic boolean groupSum6(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 6) return groupSum6(start+1, nums, target-6);\n  return groupSum6(start+1, nums, target) || groupSum6(start+1, nums, target-nums[start]);\n}\n```\n### groupNoAdj \n这道题的限制是相邻的数字不能选，我们确定选择了一个数字那就直接跳过下一个。\n```Java Solution https://codingbat.com/prob/p169605 groupNoAdj \npublic boolean groupNoAdj(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  return groupNoAdj(start+2,nums,target-nums[start]) || groupNoAdj(start+1,nums,target);\n}\n```\n### groupSum5\n这道题的限制是所有5的倍数必须选择，但是紧跟着5倍数后面的1不能选择，这道题的testcase不知道是不是没全，我把1全都不选竟然也能过。\n```Java Solution https://codingbat.com/prob/p138907 groupSum5 \npublic boolean groupSum5(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 1  &&  nums.length == 1) return true;\n  if(nums[start] % 5 == 0) return groupSum5(start+1, nums, target - nums[start]);\n  if(nums[start] == 1) return groupSum5(start+1, nums, target);\n  return groupSum5(start+1, nums, target - nums[start]) ||  groupSum5(start+1, nums, target);\n}\n```\n但实际上是有问题的，比如groupSum5(0, new int[]{4, 5, 10, 2, 1}, 16)，应该为true才对。\n这里面其实是开始的逻辑错了，过了我就没管了，后来经人提醒又改了一遍。\n```Java Solution https://codingbat.com/prob/p138907 groupSum5 \npublic boolean groupSum5(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 1  &&  nums.length == 1) return true;\n  if(nums[start] % 5 == 0) {\n\t  if(start+1 < nums.length && nums[start+1] == 1) {\n\t      return groupSum5(start+2, nums, target-nums[start]);\n\t    } else {\n\t      return groupSum5(start+1, nums, target-nums[start] );\n\t   }\n  }\n  return groupSum5(start+1, nums, target - nums[start]) ||  groupSum5(start+1, nums, target);\n}\n```\n### groupSumClump\n这道题的限制是连续出现的数，要么全选择要么全不选，这里允许用一个for来记录连续出现的次数，因为我们知道了连续出现的次数就可以知道需要选择多少个或者不选多少个。\n```Java Solution https://codingbat.com/prob/p105136 groupSumClump \npublic boolean groupSumClump(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  int ident = 1;\n  for(int i = start; i+1<nums.length; i++) {\n    if(nums[i] == nums[i+1]) {\n      ident++;\n    } else {\n      break;\n    }\n  }\n  return groupSumClump(start+ident, nums, target - ident * nums[start]) ||  groupSumClump(start+ident, nums, target); \n}\n```\n### splitArray\n题目大意是能否把这个数组分成两组，两组的和相等，并且每个数字只能分到一组。这里面允许我们用额外的函数来帮助递归。\n这题我是沿用之前的思路，选择的数放到一组同时把这组数的和当做目标，然后累加每一个数当做总和，最终比较目标的2倍是否正好与总和相等。\n```Java Solution https://codingbat.com/prob/p185204 splitArray \npublic boolean splitArray(int[] nums) {\n  return helper(0, nums, 0, 0);\n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n if(start >= nums.length) return target * 2 == sum;\n return helper(start+1, nums, sum + nums[start], target) || helper(start+1, nums, sum + nums[start], target + nums[start]);\n}\n\n```\n### splitOdd10\n这题在上面的基础上加了限制，一组的和要求是10的倍数，另一组的和是奇数。\n总的和依然可以知道，放入其中一组的target和也知道，所以继续沿用上面的。\n```Java Solution https://codingbat.com/prob/p171660 splitOdd10 \npublic boolean splitOdd10(int[] nums) {\n  return helper(0,nums,0,0);\n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n  if(start>=nums.length) return target % 10 == 0 && (sum - target) % 2 != 0;\n  return helper(start+1,nums, sum+nums[start],target+nums[start]) || helper(start+1,nums, sum+nums[start],target);\n}\n```\n### split53\n这题要求两组和相等，但是对每一组的数有要求，5的倍数必须在一组，而3的倍数但不是5的倍数的数必须在另一组。\n那我们选择选target的时候就要注意放入里面的数字，这里我选择3的倍数但不是5的倍数为目标组。\n```Java Solution https://codingbat.com/prob/p168295 split53 \npublic boolean split53(int[] nums) {\n return helper(0,nums,0,0); \n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n  if(start >= nums.length) return target * 2 == sum;\n  if(nums[start] % 3 == 0 && nums[start] % 5 != 0) return helper(start+1, nums, sum+nums[start], target+nums[start]);\n  if(nums[start] % 5 == 0) return helper(start+1, nums, sum+nums[start], target);\n   return helper(start+1, nums, sum+nums[start], target) ||  helper(start+1, nums, sum+nums[start], target+nums[start]);\n}\n```\n\n### 总结\n通过以上的题目可以知道，一定要找到递归退出条件的最基本情况，脑海里必须得始终记着这个最基本的原则，上面大部分题目的分解大概就是第一步判断退出条件，第二步写递归逻辑。虽然很多时候理解不了复杂的递归，但是背下来终有一天可以顿悟的，况且有时候你可能只需要一支笔一张纸，不停地记录下每一步递归的返回，或许就搞懂了，共勉。","source":"_posts/2019-08-09-CodingBat-递归练习题解.md","raw":"---\ntitle: CodingBat  递归练习题解\ntoc: true\ndate: 2019-08-09 11:14:41\ntags: [递归, CodingBat, algorithm]\ncategory: 算法\ndescription: \n---\n\n一直以来，我理解递归都觉得很困难，简单点的还好，leetcode里有些复杂晦涩冗长的递归真的是太难理解了，所以特地从头训练一遍递归的题目找找感觉，<https://codingbat.com/java> 这个里面的递归练习的题目就很符合我的口味，循序渐进，第一部分的递归基础题目很简单，大概抽空花了两个早上做完了。这里主要记录第二部分难度稍微大一点的递归题目的我的题解。\n\n### groupSum \n题目大意是给定一个整型数组，和一个目标数，从数组中找出一组数要满足这组数的和与目标数相等，如果存在返回true，不存在返回false，不能用循环。\n思路就是从这数组中找数字，无非就是两种情况，这个数字要不要，如果选择了那么我们的target就减掉它，如果没选择target保持不变，到最后的递归退出就是判断target是否等于0。\nExamples:\n\tgroupSum(0, [2, 4, 8], 10) → true\n\tgroupSum(0, [2, 4, 8], 14) → true\n\tgroupSum(0, [2, 4, 8], 9) → false\n```Java Solution https://codingbat.com/prob/p145416 groupSum\npublic boolean groupSum(int start, int[] nums, int target) {\n   if(start >= nums.length ) return target == 0;\n   return groupSum(start+1, nums,target) || groupSum(start+1, nums, target-nums[start]);\n}\n```\n### groupSum6 \n这道题比上面多了个限制条件就是6必须选。\n```Java Solution https://codingbat.com/prob/p199368 groupSum6\npublic boolean groupSum6(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 6) return groupSum6(start+1, nums, target-6);\n  return groupSum6(start+1, nums, target) || groupSum6(start+1, nums, target-nums[start]);\n}\n```\n### groupNoAdj \n这道题的限制是相邻的数字不能选，我们确定选择了一个数字那就直接跳过下一个。\n```Java Solution https://codingbat.com/prob/p169605 groupNoAdj \npublic boolean groupNoAdj(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  return groupNoAdj(start+2,nums,target-nums[start]) || groupNoAdj(start+1,nums,target);\n}\n```\n### groupSum5\n这道题的限制是所有5的倍数必须选择，但是紧跟着5倍数后面的1不能选择，这道题的testcase不知道是不是没全，我把1全都不选竟然也能过。\n```Java Solution https://codingbat.com/prob/p138907 groupSum5 \npublic boolean groupSum5(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 1  &&  nums.length == 1) return true;\n  if(nums[start] % 5 == 0) return groupSum5(start+1, nums, target - nums[start]);\n  if(nums[start] == 1) return groupSum5(start+1, nums, target);\n  return groupSum5(start+1, nums, target - nums[start]) ||  groupSum5(start+1, nums, target);\n}\n```\n但实际上是有问题的，比如groupSum5(0, new int[]{4, 5, 10, 2, 1}, 16)，应该为true才对。\n这里面其实是开始的逻辑错了，过了我就没管了，后来经人提醒又改了一遍。\n```Java Solution https://codingbat.com/prob/p138907 groupSum5 \npublic boolean groupSum5(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  if(nums[start] == 1  &&  nums.length == 1) return true;\n  if(nums[start] % 5 == 0) {\n\t  if(start+1 < nums.length && nums[start+1] == 1) {\n\t      return groupSum5(start+2, nums, target-nums[start]);\n\t    } else {\n\t      return groupSum5(start+1, nums, target-nums[start] );\n\t   }\n  }\n  return groupSum5(start+1, nums, target - nums[start]) ||  groupSum5(start+1, nums, target);\n}\n```\n### groupSumClump\n这道题的限制是连续出现的数，要么全选择要么全不选，这里允许用一个for来记录连续出现的次数，因为我们知道了连续出现的次数就可以知道需要选择多少个或者不选多少个。\n```Java Solution https://codingbat.com/prob/p105136 groupSumClump \npublic boolean groupSumClump(int start, int[] nums, int target) {\n  if(start >= nums.length) return target == 0;\n  int ident = 1;\n  for(int i = start; i+1<nums.length; i++) {\n    if(nums[i] == nums[i+1]) {\n      ident++;\n    } else {\n      break;\n    }\n  }\n  return groupSumClump(start+ident, nums, target - ident * nums[start]) ||  groupSumClump(start+ident, nums, target); \n}\n```\n### splitArray\n题目大意是能否把这个数组分成两组，两组的和相等，并且每个数字只能分到一组。这里面允许我们用额外的函数来帮助递归。\n这题我是沿用之前的思路，选择的数放到一组同时把这组数的和当做目标，然后累加每一个数当做总和，最终比较目标的2倍是否正好与总和相等。\n```Java Solution https://codingbat.com/prob/p185204 splitArray \npublic boolean splitArray(int[] nums) {\n  return helper(0, nums, 0, 0);\n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n if(start >= nums.length) return target * 2 == sum;\n return helper(start+1, nums, sum + nums[start], target) || helper(start+1, nums, sum + nums[start], target + nums[start]);\n}\n\n```\n### splitOdd10\n这题在上面的基础上加了限制，一组的和要求是10的倍数，另一组的和是奇数。\n总的和依然可以知道，放入其中一组的target和也知道，所以继续沿用上面的。\n```Java Solution https://codingbat.com/prob/p171660 splitOdd10 \npublic boolean splitOdd10(int[] nums) {\n  return helper(0,nums,0,0);\n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n  if(start>=nums.length) return target % 10 == 0 && (sum - target) % 2 != 0;\n  return helper(start+1,nums, sum+nums[start],target+nums[start]) || helper(start+1,nums, sum+nums[start],target);\n}\n```\n### split53\n这题要求两组和相等，但是对每一组的数有要求，5的倍数必须在一组，而3的倍数但不是5的倍数的数必须在另一组。\n那我们选择选target的时候就要注意放入里面的数字，这里我选择3的倍数但不是5的倍数为目标组。\n```Java Solution https://codingbat.com/prob/p168295 split53 \npublic boolean split53(int[] nums) {\n return helper(0,nums,0,0); \n}\npublic boolean helper(int start, int[] nums, int sum, int target) {\n  if(start >= nums.length) return target * 2 == sum;\n  if(nums[start] % 3 == 0 && nums[start] % 5 != 0) return helper(start+1, nums, sum+nums[start], target+nums[start]);\n  if(nums[start] % 5 == 0) return helper(start+1, nums, sum+nums[start], target);\n   return helper(start+1, nums, sum+nums[start], target) ||  helper(start+1, nums, sum+nums[start], target+nums[start]);\n}\n```\n\n### 总结\n通过以上的题目可以知道，一定要找到递归退出条件的最基本情况，脑海里必须得始终记着这个最基本的原则，上面大部分题目的分解大概就是第一步判断退出条件，第二步写递归逻辑。虽然很多时候理解不了复杂的递归，但是背下来终有一天可以顿悟的，况且有时候你可能只需要一支笔一张纸，不停地记录下每一步递归的返回，或许就搞懂了，共勉。","slug":"CodingBat-递归练习题解","published":1,"updated":"2019-08-09T06:44:44.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewp90013i0h6kzpk4rm6","content":"<p>一直以来，我理解递归都觉得很困难，简单点的还好，leetcode里有些复杂晦涩冗长的递归真的是太难理解了，所以特地从头训练一遍递归的题目找找感觉，<a href=\"https://codingbat.com/java\" target=\"_blank\" rel=\"noopener\">https://codingbat.com/java</a> 这个里面的递归练习的题目就很符合我的口味，循序渐进，第一部分的递归基础题目很简单，大概抽空花了两个早上做完了。这里主要记录第二部分难度稍微大一点的递归题目的我的题解。</p>\n<h3 id=\"groupSum\"><a href=\"#groupSum\" class=\"headerlink\" title=\"groupSum\"></a>groupSum</h3><p>题目大意是给定一个整型数组，和一个目标数，从数组中找出一组数要满足这组数的和与目标数相等，如果存在返回true，不存在返回false，不能用循环。<br>思路就是从这数组中找数字，无非就是两种情况，这个数字要不要，如果选择了那么我们的target就减掉它，如果没选择target保持不变，到最后的递归退出就是判断target是否等于0。<br>Examples:<br>    groupSum(0, [2, 4, 8], 10) → true<br>    groupSum(0, [2, 4, 8], 14) → true<br>    groupSum(0, [2, 4, 8], 9) → false<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p145416\" target=\"_blank\" rel=\"noopener\">groupSum</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(start &gt;= nums.length ) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> groupSum(start+<span class=\"number\">1</span>, nums,target) || groupSum(start+<span class=\"number\">1</span>, nums, target-nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSum6\"><a href=\"#groupSum6\" class=\"headerlink\" title=\"groupSum6\"></a>groupSum6</h3><p>这道题比上面多了个限制条件就是6必须选。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p199368\" target=\"_blank\" rel=\"noopener\">groupSum6</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum6</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">6</span>) <span class=\"keyword\">return</span> groupSum6(start+<span class=\"number\">1</span>, nums, target-<span class=\"number\">6</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum6(start+<span class=\"number\">1</span>, nums, target) || groupSum6(start+<span class=\"number\">1</span>, nums, target-nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupNoAdj\"><a href=\"#groupNoAdj\" class=\"headerlink\" title=\"groupNoAdj\"></a>groupNoAdj</h3><p>这道题的限制是相邻的数字不能选，我们确定选择了一个数字那就直接跳过下一个。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p169605\" target=\"_blank\" rel=\"noopener\">groupNoAdj </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupNoAdj</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupNoAdj(start+<span class=\"number\">2</span>,nums,target-nums[start]) || groupNoAdj(start+<span class=\"number\">1</span>,nums,target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSum5\"><a href=\"#groupSum5\" class=\"headerlink\" title=\"groupSum5\"></a>groupSum5</h3><p>这道题的限制是所有5的倍数必须选择，但是紧跟着5倍数后面的1不能选择，这道题的testcase不知道是不是没全，我把1全都不选竟然也能过。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p138907\" target=\"_blank\" rel=\"noopener\">groupSum5 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum5</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>  &amp;&amp;  nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]) ||  groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但实际上是有问题的，比如groupSum5(0, new int[]{4, 5, 10, 2, 1}, 16)，应该为true才对。<br>这里面其实是开始的逻辑错了，过了我就没管了，后来经人提醒又改了一遍。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p138907\" target=\"_blank\" rel=\"noopener\">groupSum5 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum5</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>  &amp;&amp;  nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span>(start+<span class=\"number\">1</span> &lt; nums.length &amp;&amp; nums[start+<span class=\"number\">1</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">2</span>, nums, target-nums[start]);</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target-nums[start] );</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]) ||  groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSumClump\"><a href=\"#groupSumClump\" class=\"headerlink\" title=\"groupSumClump\"></a>groupSumClump</h3><p>这道题的限制是连续出现的数，要么全选择要么全不选，这里允许用一个for来记录连续出现的次数，因为我们知道了连续出现的次数就可以知道需要选择多少个或者不选多少个。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p105136\" target=\"_blank\" rel=\"noopener\">groupSumClump </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSumClump</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ident = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = start; i+<span class=\"number\">1</span>&lt;nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[i] == nums[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      ident++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSumClump(start+ident, nums, target - ident * nums[start]) ||  groupSumClump(start+ident, nums, target); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitArray\"><a href=\"#splitArray\" class=\"headerlink\" title=\"splitArray\"></a>splitArray</h3><p>题目大意是能否把这个数组分成两组，两组的和相等，并且每个数字只能分到一组。这里面允许我们用额外的函数来帮助递归。<br>这题我是沿用之前的思路，选择的数放到一组同时把这组数的和当做目标，然后累加每一个数当做总和，最终比较目标的2倍是否正好与总和相等。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p185204\" target=\"_blank\" rel=\"noopener\">splitArray </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">splitArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>, nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target * <span class=\"number\">2</span> == sum;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum + nums[start], target) || helper(start+<span class=\"number\">1</span>, nums, sum + nums[start], target + nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitOdd10\"><a href=\"#splitOdd10\" class=\"headerlink\" title=\"splitOdd10\"></a>splitOdd10</h3><p>这题在上面的基础上加了限制，一组的和要求是10的倍数，另一组的和是奇数。<br>总的和依然可以知道，放入其中一组的target和也知道，所以继续沿用上面的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p171660\" target=\"_blank\" rel=\"noopener\">splitOdd10 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">splitOdd10</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>,nums,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start&gt;=nums.length) <span class=\"keyword\">return</span> target % <span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; (sum - target) % <span class=\"number\">2</span> != <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>,nums, sum+nums[start],target+nums[start]) || helper(start+<span class=\"number\">1</span>,nums, sum+nums[start],target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"split53\"><a href=\"#split53\" class=\"headerlink\" title=\"split53\"></a>split53</h3><p>这题要求两组和相等，但是对每一组的数有要求，5的倍数必须在一组，而3的倍数但不是5的倍数的数必须在另一组。<br>那我们选择选target的时候就要注意放入里面的数字，这里我选择3的倍数但不是5的倍数为目标组。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p168295\" target=\"_blank\" rel=\"noopener\">split53 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">split53</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>,nums,<span class=\"number\">0</span>,<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target * <span class=\"number\">2</span> == sum;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">3</span> == <span class=\"number\">0</span> &amp;&amp; nums[start] % <span class=\"number\">5</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target+nums[start]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target) ||  helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target+nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的题目可以知道，一定要找到递归退出条件的最基本情况，脑海里必须得始终记着这个最基本的原则，上面大部分题目的分解大概就是第一步判断退出条件，第二步写递归逻辑。虽然很多时候理解不了复杂的递归，但是背下来终有一天可以顿悟的，况且有时候你可能只需要一支笔一张纸，不停地记录下每一步递归的返回，或许就搞懂了，共勉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一直以来，我理解递归都觉得很困难，简单点的还好，leetcode里有些复杂晦涩冗长的递归真的是太难理解了，所以特地从头训练一遍递归的题目找找感觉，<a href=\"https://codingbat.com/java\" target=\"_blank\" rel=\"noopener\">https://codingbat.com/java</a> 这个里面的递归练习的题目就很符合我的口味，循序渐进，第一部分的递归基础题目很简单，大概抽空花了两个早上做完了。这里主要记录第二部分难度稍微大一点的递归题目的我的题解。</p>\n<h3 id=\"groupSum\"><a href=\"#groupSum\" class=\"headerlink\" title=\"groupSum\"></a>groupSum</h3><p>题目大意是给定一个整型数组，和一个目标数，从数组中找出一组数要满足这组数的和与目标数相等，如果存在返回true，不存在返回false，不能用循环。<br>思路就是从这数组中找数字，无非就是两种情况，这个数字要不要，如果选择了那么我们的target就减掉它，如果没选择target保持不变，到最后的递归退出就是判断target是否等于0。<br>Examples:<br>    groupSum(0, [2, 4, 8], 10) → true<br>    groupSum(0, [2, 4, 8], 14) → true<br>    groupSum(0, [2, 4, 8], 9) → false<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p145416\" target=\"_blank\" rel=\"noopener\">groupSum</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(start &gt;= nums.length ) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> groupSum(start+<span class=\"number\">1</span>, nums,target) || groupSum(start+<span class=\"number\">1</span>, nums, target-nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSum6\"><a href=\"#groupSum6\" class=\"headerlink\" title=\"groupSum6\"></a>groupSum6</h3><p>这道题比上面多了个限制条件就是6必须选。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p199368\" target=\"_blank\" rel=\"noopener\">groupSum6</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum6</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">6</span>) <span class=\"keyword\">return</span> groupSum6(start+<span class=\"number\">1</span>, nums, target-<span class=\"number\">6</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum6(start+<span class=\"number\">1</span>, nums, target) || groupSum6(start+<span class=\"number\">1</span>, nums, target-nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupNoAdj\"><a href=\"#groupNoAdj\" class=\"headerlink\" title=\"groupNoAdj\"></a>groupNoAdj</h3><p>这道题的限制是相邻的数字不能选，我们确定选择了一个数字那就直接跳过下一个。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p169605\" target=\"_blank\" rel=\"noopener\">groupNoAdj </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupNoAdj</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupNoAdj(start+<span class=\"number\">2</span>,nums,target-nums[start]) || groupNoAdj(start+<span class=\"number\">1</span>,nums,target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSum5\"><a href=\"#groupSum5\" class=\"headerlink\" title=\"groupSum5\"></a>groupSum5</h3><p>这道题的限制是所有5的倍数必须选择，但是紧跟着5倍数后面的1不能选择，这道题的testcase不知道是不是没全，我把1全都不选竟然也能过。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p138907\" target=\"_blank\" rel=\"noopener\">groupSum5 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum5</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>  &amp;&amp;  nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]) ||  groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但实际上是有问题的，比如groupSum5(0, new int[]{4, 5, 10, 2, 1}, 16)，应该为true才对。<br>这里面其实是开始的逻辑错了，过了我就没管了，后来经人提醒又改了一遍。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p138907\" target=\"_blank\" rel=\"noopener\">groupSum5 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSum5</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] == <span class=\"number\">1</span>  &amp;&amp;  nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span>(start+<span class=\"number\">1</span> &lt; nums.length &amp;&amp; nums[start+<span class=\"number\">1</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">2</span>, nums, target-nums[start]);</span><br><span class=\"line\">\t    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target-nums[start] );</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSum5(start+<span class=\"number\">1</span>, nums, target - nums[start]) ||  groupSum5(start+<span class=\"number\">1</span>, nums, target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"groupSumClump\"><a href=\"#groupSumClump\" class=\"headerlink\" title=\"groupSumClump\"></a>groupSumClump</h3><p>这道题的限制是连续出现的数，要么全选择要么全不选，这里允许用一个for来记录连续出现的次数，因为我们知道了连续出现的次数就可以知道需要选择多少个或者不选多少个。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p105136\" target=\"_blank\" rel=\"noopener\">groupSumClump </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">groupSumClump</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target == <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ident = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = start; i+<span class=\"number\">1</span>&lt;nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[i] == nums[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      ident++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> groupSumClump(start+ident, nums, target - ident * nums[start]) ||  groupSumClump(start+ident, nums, target); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitArray\"><a href=\"#splitArray\" class=\"headerlink\" title=\"splitArray\"></a>splitArray</h3><p>题目大意是能否把这个数组分成两组，两组的和相等，并且每个数字只能分到一组。这里面允许我们用额外的函数来帮助递归。<br>这题我是沿用之前的思路，选择的数放到一组同时把这组数的和当做目标，然后累加每一个数当做总和，最终比较目标的2倍是否正好与总和相等。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p185204\" target=\"_blank\" rel=\"noopener\">splitArray </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">splitArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>, nums, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target * <span class=\"number\">2</span> == sum;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum + nums[start], target) || helper(start+<span class=\"number\">1</span>, nums, sum + nums[start], target + nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitOdd10\"><a href=\"#splitOdd10\" class=\"headerlink\" title=\"splitOdd10\"></a>splitOdd10</h3><p>这题在上面的基础上加了限制，一组的和要求是10的倍数，另一组的和是奇数。<br>总的和依然可以知道，放入其中一组的target和也知道，所以继续沿用上面的。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p171660\" target=\"_blank\" rel=\"noopener\">splitOdd10 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">splitOdd10</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>,nums,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start&gt;=nums.length) <span class=\"keyword\">return</span> target % <span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; (sum - target) % <span class=\"number\">2</span> != <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>,nums, sum+nums[start],target+nums[start]) || helper(start+<span class=\"number\">1</span>,nums, sum+nums[start],target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"split53\"><a href=\"#split53\" class=\"headerlink\" title=\"split53\"></a>split53</h3><p>这题要求两组和相等，但是对每一组的数有要求，5的倍数必须在一组，而3的倍数但不是5的倍数的数必须在另一组。<br>那我们选择选target的时候就要注意放入里面的数字，这里我选择3的倍数但不是5的倍数为目标组。<br><figure class=\"highlight java\"><figcaption><span>Solution</span><a href=\"https://codingbat.com/prob/p168295\" target=\"_blank\" rel=\"noopener\">split53 </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">split53</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>,nums,<span class=\"number\">0</span>,<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> sum, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(start &gt;= nums.length) <span class=\"keyword\">return</span> target * <span class=\"number\">2</span> == sum;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">3</span> == <span class=\"number\">0</span> &amp;&amp; nums[start] % <span class=\"number\">5</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target+nums[start]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(nums[start] % <span class=\"number\">5</span> == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target) ||  helper(start+<span class=\"number\">1</span>, nums, sum+nums[start], target+nums[start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的题目可以知道，一定要找到递归退出条件的最基本情况，脑海里必须得始终记着这个最基本的原则，上面大部分题目的分解大概就是第一步判断退出条件，第二步写递归逻辑。虽然很多时候理解不了复杂的递归，但是背下来终有一天可以顿悟的，况且有时候你可能只需要一支笔一张纸，不停地记录下每一步递归的返回，或许就搞懂了，共勉。</p>\n"},{"title":"面试系列","date":"2019-03-20T15:17:21.000Z","description":"面试","_content":"\n# Java基础\n### 1. Java基本数据类型，多少字节\n字符型 char(16)\n逻辑型 boolean(8)\n整型 byte(8) short(16) int(32) long(64)\n浮点型 float(32) double(64)\n### 2.String类能被继承吗？为什么？\n不能，String 被final修饰，被final修饰的类不能被继承，实现细节不允许改变。\n### 3.String， StringBuffer， StringBuilder 区别\nString不可变对象，因此在每次对String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象\nStringBuffer线程安全\nStringBuilder线程不安全\nString对象拼接实质就是StringBuffer append，仅在连加情况下快\n### 4.ArrayList和LinkedList有什么区别\nArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构\n对于查找get和set操作，ArrayList优于LinkedList\n对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。\n### 5.类的实例化顺序\n父类static -> 子类static -> 父类动态代码块构造函数 -> 子类动态代码块构造函数\n### 6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？\n为了减小锁的粒度，直接锁住链表头结点，CAS+synchronized控制并发，提高了性能，分段锁并发度低，性能上差点。\n### 7.有顺序的Map实现类，如果有，他们是怎么保证有序的。\nTreeMap：根据元素key排序，可自定义比较器\nLinkedHashMap：根据元素存入顺序保证有序，内部增加了个链表存放元素顺序\n### 8.抽象类和接口区别\n抽象类可以有默认的方法实现，接口完全抽象不存在方法实现，jdk1.8接口可以有default实现 \n抽象类子类用extends关键字，接口子类使用implements关键字\n抽象类可以有构造器，接口不存在构造器\n抽象类除了不能实例化和普通类没区别，接口是完全不同的类型\n抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。\n抽象方法可以有main方法并且我们可以运行它，接口没有main方法，因此我们不能运行它。\n如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。\n### 9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型\n四种I/O模型，同步阻塞，同步非阻塞，多路复用，异步阻塞。\nnio非阻塞 bio、aio阻塞\nReactor 将I/O事件发派给对应的Handler\nAcceptor 处理客户端连接请求\nHandlers 执行非阻塞读/写\n### 10.反射的原理，反射创建类实例的三种方式是什么。\n在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法\nClass clz = Class.forName(\"java.lang.String\");\nClass clz = String.class;\nString str = new String(\"Hello\");\nClass clz = str.getClass();\n### 11.反射中，Class.forName和ClassLoader区别 。\nclass.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。\n而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。\nClass.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象\n### 12.描述动态代理的几种实现方式，分别说出相应的优缺点。\njdk动态代理 ： 目标类必须实现的某个接口，如果某个类没有实现接口则不能生成代理对象。\ncglib动态代理：针对目标类生成一个子类，覆盖其中的所有方法，所以目标类和方法不能声明为final类型。\nCGLib采用了ASM的字节码技术，其原理是通过字节码技术为一个类创建子类\n\n### 13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\n在父类中同时改写equals方法与hashCode方法；\n在子类中改写equals方法，保证子类对象可以与父类对象进行比较；\n子类中不改写hashCode方法，直接继承父类中改写的hashCode方法。\n同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。\n\n### 14.深拷贝和浅拷贝区别。\n浅拷贝，复制了主对象，里面成员变量共享，\n深拷贝，完全复制，除了不可变对象不复制\n### 15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。\n泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率\n### 16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\n序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。\n实现java.io.Serializable || java.io.Externalizable 接口\n在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。\n类里面一定要serialVersionUID，否则旧数据会反序列化会失败。serialVersionUID是根据该类名、方法名等数据生产的一个整数，用来验证版本是否一致。\n\n### 17什么情况下会发生栈内存溢出\n如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。\n如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\n","source":"_posts/interview.md","raw":"title: 面试系列\ndate: 2019-03-20 23:17:21\ntags: [面试]\ncategory: 面试\ndescription: 面试\n---\n\n# Java基础\n### 1. Java基本数据类型，多少字节\n字符型 char(16)\n逻辑型 boolean(8)\n整型 byte(8) short(16) int(32) long(64)\n浮点型 float(32) double(64)\n### 2.String类能被继承吗？为什么？\n不能，String 被final修饰，被final修饰的类不能被继承，实现细节不允许改变。\n### 3.String， StringBuffer， StringBuilder 区别\nString不可变对象，因此在每次对String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象\nStringBuffer线程安全\nStringBuilder线程不安全\nString对象拼接实质就是StringBuffer append，仅在连加情况下快\n### 4.ArrayList和LinkedList有什么区别\nArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构\n对于查找get和set操作，ArrayList优于LinkedList\n对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。\n### 5.类的实例化顺序\n父类static -> 子类static -> 父类动态代码块构造函数 -> 子类动态代码块构造函数\n### 6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？\n为了减小锁的粒度，直接锁住链表头结点，CAS+synchronized控制并发，提高了性能，分段锁并发度低，性能上差点。\n### 7.有顺序的Map实现类，如果有，他们是怎么保证有序的。\nTreeMap：根据元素key排序，可自定义比较器\nLinkedHashMap：根据元素存入顺序保证有序，内部增加了个链表存放元素顺序\n### 8.抽象类和接口区别\n抽象类可以有默认的方法实现，接口完全抽象不存在方法实现，jdk1.8接口可以有default实现 \n抽象类子类用extends关键字，接口子类使用implements关键字\n抽象类可以有构造器，接口不存在构造器\n抽象类除了不能实例化和普通类没区别，接口是完全不同的类型\n抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。\n抽象方法可以有main方法并且我们可以运行它，接口没有main方法，因此我们不能运行它。\n如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。\n### 9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型\n四种I/O模型，同步阻塞，同步非阻塞，多路复用，异步阻塞。\nnio非阻塞 bio、aio阻塞\nReactor 将I/O事件发派给对应的Handler\nAcceptor 处理客户端连接请求\nHandlers 执行非阻塞读/写\n### 10.反射的原理，反射创建类实例的三种方式是什么。\n在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法\nClass clz = Class.forName(\"java.lang.String\");\nClass clz = String.class;\nString str = new String(\"Hello\");\nClass clz = str.getClass();\n### 11.反射中，Class.forName和ClassLoader区别 。\nclass.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。\n而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。\nClass.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象\n### 12.描述动态代理的几种实现方式，分别说出相应的优缺点。\njdk动态代理 ： 目标类必须实现的某个接口，如果某个类没有实现接口则不能生成代理对象。\ncglib动态代理：针对目标类生成一个子类，覆盖其中的所有方法，所以目标类和方法不能声明为final类型。\nCGLib采用了ASM的字节码技术，其原理是通过字节码技术为一个类创建子类\n\n### 13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\n在父类中同时改写equals方法与hashCode方法；\n在子类中改写equals方法，保证子类对象可以与父类对象进行比较；\n子类中不改写hashCode方法，直接继承父类中改写的hashCode方法。\n同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。\n\n### 14.深拷贝和浅拷贝区别。\n浅拷贝，复制了主对象，里面成员变量共享，\n深拷贝，完全复制，除了不可变对象不复制\n### 15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。\n泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率\n### 16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\n序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。\n实现java.io.Serializable || java.io.Externalizable 接口\n在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。\n类里面一定要serialVersionUID，否则旧数据会反序列化会失败。serialVersionUID是根据该类名、方法名等数据生产的一个整数，用来验证版本是否一致。\n\n### 17什么情况下会发生栈内存溢出\n如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。\n如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\n","slug":"interview","published":1,"updated":"2019-03-25T04:10:27.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzawewpb0016i0h65blxx20s","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h3 id=\"1-Java基本数据类型，多少字节\"><a href=\"#1-Java基本数据类型，多少字节\" class=\"headerlink\" title=\"1. Java基本数据类型，多少字节\"></a>1. Java基本数据类型，多少字节</h3><p>字符型 char(16)<br>逻辑型 boolean(8)<br>整型 byte(8) short(16) int(32) long(64)<br>浮点型 float(32) double(64)</p>\n<h3 id=\"2-String类能被继承吗？为什么？\"><a href=\"#2-String类能被继承吗？为什么？\" class=\"headerlink\" title=\"2.String类能被继承吗？为什么？\"></a>2.String类能被继承吗？为什么？</h3><p>不能，String 被final修饰，被final修饰的类不能被继承，实现细节不允许改变。</p>\n<h3 id=\"3-String，-StringBuffer，-StringBuilder-区别\"><a href=\"#3-String，-StringBuffer，-StringBuilder-区别\" class=\"headerlink\" title=\"3.String， StringBuffer， StringBuilder 区别\"></a>3.String， StringBuffer， StringBuilder 区别</h3><p>String不可变对象，因此在每次对String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象<br>StringBuffer线程安全<br>StringBuilder线程不安全<br>String对象拼接实质就是StringBuffer append，仅在连加情况下快</p>\n<h3 id=\"4-ArrayList和LinkedList有什么区别\"><a href=\"#4-ArrayList和LinkedList有什么区别\" class=\"headerlink\" title=\"4.ArrayList和LinkedList有什么区别\"></a>4.ArrayList和LinkedList有什么区别</h3><p>ArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构<br>对于查找get和set操作，ArrayList优于LinkedList<br>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>\n<h3 id=\"5-类的实例化顺序\"><a href=\"#5-类的实例化顺序\" class=\"headerlink\" title=\"5.类的实例化顺序\"></a>5.类的实例化顺序</h3><p>父类static -&gt; 子类static -&gt; 父类动态代码块构造函数 -&gt; 子类动态代码块构造函数</p>\n<h3 id=\"6-ConcurrentHashMap为什么放弃了分段锁-有什么问题吗？\"><a href=\"#6-ConcurrentHashMap为什么放弃了分段锁-有什么问题吗？\" class=\"headerlink\" title=\"6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？\"></a>6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？</h3><p>为了减小锁的粒度，直接锁住链表头结点，CAS+synchronized控制并发，提高了性能，分段锁并发度低，性能上差点。</p>\n<h3 id=\"7-有顺序的Map实现类，如果有，他们是怎么保证有序的。\"><a href=\"#7-有顺序的Map实现类，如果有，他们是怎么保证有序的。\" class=\"headerlink\" title=\"7.有顺序的Map实现类，如果有，他们是怎么保证有序的。\"></a>7.有顺序的Map实现类，如果有，他们是怎么保证有序的。</h3><p>TreeMap：根据元素key排序，可自定义比较器<br>LinkedHashMap：根据元素存入顺序保证有序，内部增加了个链表存放元素顺序</p>\n<h3 id=\"8-抽象类和接口区别\"><a href=\"#8-抽象类和接口区别\" class=\"headerlink\" title=\"8.抽象类和接口区别\"></a>8.抽象类和接口区别</h3><p>抽象类可以有默认的方法实现，接口完全抽象不存在方法实现，jdk1.8接口可以有default实现<br>抽象类子类用extends关键字，接口子类使用implements关键字<br>抽象类可以有构造器，接口不存在构造器<br>抽象类除了不能实例化和普通类没区别，接口是完全不同的类型<br>抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。<br>抽象方法可以有main方法并且我们可以运行它，接口没有main方法，因此我们不能运行它。<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>\n<h3 id=\"9-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\"><a href=\"#9-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\" class=\"headerlink\" title=\"9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型\"></a>9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型</h3><p>四种I/O模型，同步阻塞，同步非阻塞，多路复用，异步阻塞。<br>nio非阻塞 bio、aio阻塞<br>Reactor 将I/O事件发派给对应的Handler<br>Acceptor 处理客户端连接请求<br>Handlers 执行非阻塞读/写</p>\n<h3 id=\"10-反射的原理，反射创建类实例的三种方式是什么。\"><a href=\"#10-反射的原理，反射创建类实例的三种方式是什么。\" class=\"headerlink\" title=\"10.反射的原理，反射创建类实例的三种方式是什么。\"></a>10.反射的原理，反射创建类实例的三种方式是什么。</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法<br>Class clz = Class.forName(“java.lang.String”);<br>Class clz = String.class;<br>String str = new String(“Hello”);<br>Class clz = str.getClass();</p>\n<h3 id=\"11-反射中，Class-forName和ClassLoader区别-。\"><a href=\"#11-反射中，Class-forName和ClassLoader区别-。\" class=\"headerlink\" title=\"11.反射中，Class.forName和ClassLoader区别 。\"></a>11.反射中，Class.forName和ClassLoader区别 。</h3><p>class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。<br>而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。<br>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</p>\n<h3 id=\"12-描述动态代理的几种实现方式，分别说出相应的优缺点。\"><a href=\"#12-描述动态代理的几种实现方式，分别说出相应的优缺点。\" class=\"headerlink\" title=\"12.描述动态代理的几种实现方式，分别说出相应的优缺点。\"></a>12.描述动态代理的几种实现方式，分别说出相应的优缺点。</h3><p>jdk动态代理 ： 目标类必须实现的某个接口，如果某个类没有实现接口则不能生成代理对象。<br>cglib动态代理：针对目标类生成一个子类，覆盖其中的所有方法，所以目标类和方法不能声明为final类型。<br>CGLib采用了ASM的字节码技术，其原理是通过字节码技术为一个类创建子类</p>\n<h3 id=\"13-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\"><a href=\"#13-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\" class=\"headerlink\" title=\"13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\"></a>13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h3><p>在父类中同时改写equals方法与hashCode方法；<br>在子类中改写equals方法，保证子类对象可以与父类对象进行比较；<br>子类中不改写hashCode方法，直接继承父类中改写的hashCode方法。<br>同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。</p>\n<h3 id=\"14-深拷贝和浅拷贝区别。\"><a href=\"#14-深拷贝和浅拷贝区别。\" class=\"headerlink\" title=\"14.深拷贝和浅拷贝区别。\"></a>14.深拷贝和浅拷贝区别。</h3><p>浅拷贝，复制了主对象，里面成员变量共享，<br>深拷贝，完全复制，除了不可变对象不复制</p>\n<h3 id=\"15-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。\"><a href=\"#15-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。\" class=\"headerlink\" title=\"15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。\"></a>15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。</h3><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率</p>\n<h3 id=\"16-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\"><a href=\"#16-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\" class=\"headerlink\" title=\"16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\"></a>16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h3><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。<br>实现java.io.Serializable || java.io.Externalizable 接口<br>在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。<br>类里面一定要serialVersionUID，否则旧数据会反序列化会失败。serialVersionUID是根据该类名、方法名等数据生产的一个整数，用来验证版本是否一致。</p>\n<h3 id=\"17什么情况下会发生栈内存溢出\"><a href=\"#17什么情况下会发生栈内存溢出\" class=\"headerlink\" title=\"17什么情况下会发生栈内存溢出\"></a>17什么情况下会发生栈内存溢出</h3><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。<br>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h3 id=\"1-Java基本数据类型，多少字节\"><a href=\"#1-Java基本数据类型，多少字节\" class=\"headerlink\" title=\"1. Java基本数据类型，多少字节\"></a>1. Java基本数据类型，多少字节</h3><p>字符型 char(16)<br>逻辑型 boolean(8)<br>整型 byte(8) short(16) int(32) long(64)<br>浮点型 float(32) double(64)</p>\n<h3 id=\"2-String类能被继承吗？为什么？\"><a href=\"#2-String类能被继承吗？为什么？\" class=\"headerlink\" title=\"2.String类能被继承吗？为什么？\"></a>2.String类能被继承吗？为什么？</h3><p>不能，String 被final修饰，被final修饰的类不能被继承，实现细节不允许改变。</p>\n<h3 id=\"3-String，-StringBuffer，-StringBuilder-区别\"><a href=\"#3-String，-StringBuffer，-StringBuilder-区别\" class=\"headerlink\" title=\"3.String， StringBuffer， StringBuilder 区别\"></a>3.String， StringBuffer， StringBuilder 区别</h3><p>String不可变对象，因此在每次对String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象<br>StringBuffer线程安全<br>StringBuilder线程不安全<br>String对象拼接实质就是StringBuffer append，仅在连加情况下快</p>\n<h3 id=\"4-ArrayList和LinkedList有什么区别\"><a href=\"#4-ArrayList和LinkedList有什么区别\" class=\"headerlink\" title=\"4.ArrayList和LinkedList有什么区别\"></a>4.ArrayList和LinkedList有什么区别</h3><p>ArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构<br>对于查找get和set操作，ArrayList优于LinkedList<br>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>\n<h3 id=\"5-类的实例化顺序\"><a href=\"#5-类的实例化顺序\" class=\"headerlink\" title=\"5.类的实例化顺序\"></a>5.类的实例化顺序</h3><p>父类static -&gt; 子类static -&gt; 父类动态代码块构造函数 -&gt; 子类动态代码块构造函数</p>\n<h3 id=\"6-ConcurrentHashMap为什么放弃了分段锁-有什么问题吗？\"><a href=\"#6-ConcurrentHashMap为什么放弃了分段锁-有什么问题吗？\" class=\"headerlink\" title=\"6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？\"></a>6.ConcurrentHashMap为什么放弃了分段锁,有什么问题吗？</h3><p>为了减小锁的粒度，直接锁住链表头结点，CAS+synchronized控制并发，提高了性能，分段锁并发度低，性能上差点。</p>\n<h3 id=\"7-有顺序的Map实现类，如果有，他们是怎么保证有序的。\"><a href=\"#7-有顺序的Map实现类，如果有，他们是怎么保证有序的。\" class=\"headerlink\" title=\"7.有顺序的Map实现类，如果有，他们是怎么保证有序的。\"></a>7.有顺序的Map实现类，如果有，他们是怎么保证有序的。</h3><p>TreeMap：根据元素key排序，可自定义比较器<br>LinkedHashMap：根据元素存入顺序保证有序，内部增加了个链表存放元素顺序</p>\n<h3 id=\"8-抽象类和接口区别\"><a href=\"#8-抽象类和接口区别\" class=\"headerlink\" title=\"8.抽象类和接口区别\"></a>8.抽象类和接口区别</h3><p>抽象类可以有默认的方法实现，接口完全抽象不存在方法实现，jdk1.8接口可以有default实现<br>抽象类子类用extends关键字，接口子类使用implements关键字<br>抽象类可以有构造器，接口不存在构造器<br>抽象类除了不能实例化和普通类没区别，接口是完全不同的类型<br>抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。<br>抽象方法可以有main方法并且我们可以运行它，接口没有main方法，因此我们不能运行它。<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>\n<h3 id=\"9-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\"><a href=\"#9-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型\" class=\"headerlink\" title=\"9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型\"></a>9.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型</h3><p>四种I/O模型，同步阻塞，同步非阻塞，多路复用，异步阻塞。<br>nio非阻塞 bio、aio阻塞<br>Reactor 将I/O事件发派给对应的Handler<br>Acceptor 处理客户端连接请求<br>Handlers 执行非阻塞读/写</p>\n<h3 id=\"10-反射的原理，反射创建类实例的三种方式是什么。\"><a href=\"#10-反射的原理，反射创建类实例的三种方式是什么。\" class=\"headerlink\" title=\"10.反射的原理，反射创建类实例的三种方式是什么。\"></a>10.反射的原理，反射创建类实例的三种方式是什么。</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法<br>Class clz = Class.forName(“java.lang.String”);<br>Class clz = String.class;<br>String str = new String(“Hello”);<br>Class clz = str.getClass();</p>\n<h3 id=\"11-反射中，Class-forName和ClassLoader区别-。\"><a href=\"#11-反射中，Class-forName和ClassLoader区别-。\" class=\"headerlink\" title=\"11.反射中，Class.forName和ClassLoader区别 。\"></a>11.反射中，Class.forName和ClassLoader区别 。</h3><p>class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。<br>而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。<br>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</p>\n<h3 id=\"12-描述动态代理的几种实现方式，分别说出相应的优缺点。\"><a href=\"#12-描述动态代理的几种实现方式，分别说出相应的优缺点。\" class=\"headerlink\" title=\"12.描述动态代理的几种实现方式，分别说出相应的优缺点。\"></a>12.描述动态代理的几种实现方式，分别说出相应的优缺点。</h3><p>jdk动态代理 ： 目标类必须实现的某个接口，如果某个类没有实现接口则不能生成代理对象。<br>cglib动态代理：针对目标类生成一个子类，覆盖其中的所有方法，所以目标类和方法不能声明为final类型。<br>CGLib采用了ASM的字节码技术，其原理是通过字节码技术为一个类创建子类</p>\n<h3 id=\"13-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\"><a href=\"#13-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\" class=\"headerlink\" title=\"13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。\"></a>13.如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h3><p>在父类中同时改写equals方法与hashCode方法；<br>在子类中改写equals方法，保证子类对象可以与父类对象进行比较；<br>子类中不改写hashCode方法，直接继承父类中改写的hashCode方法。<br>同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。</p>\n<h3 id=\"14-深拷贝和浅拷贝区别。\"><a href=\"#14-深拷贝和浅拷贝区别。\" class=\"headerlink\" title=\"14.深拷贝和浅拷贝区别。\"></a>14.深拷贝和浅拷贝区别。</h3><p>浅拷贝，复制了主对象，里面成员变量共享，<br>深拷贝，完全复制，除了不可变对象不复制</p>\n<h3 id=\"15-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。\"><a href=\"#15-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。\" class=\"headerlink\" title=\"15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。\"></a>15.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。</h3><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率</p>\n<h3 id=\"16-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\"><a href=\"#16-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\" class=\"headerlink\" title=\"16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。\"></a>16.什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h3><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。<br>实现java.io.Serializable || java.io.Externalizable 接口<br>在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。<br>类里面一定要serialVersionUID，否则旧数据会反序列化会失败。serialVersionUID是根据该类名、方法名等数据生产的一个整数，用来验证版本是否一致。</p>\n<h3 id=\"17什么情况下会发生栈内存溢出\"><a href=\"#17什么情况下会发生栈内存溢出\" class=\"headerlink\" title=\"17什么情况下会发生栈内存溢出\"></a>17什么情况下会发生栈内存溢出</h3><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。<br>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>\n"}],"PostAsset":[{"_id":"source/_posts/2019-03-19-BST系列（三）/1.png","slug":"1.png","post":"cjzawewnw0003i0h6zyonbxip","modified":0,"renderable":0},{"_id":"source/_posts/2019-08-05-移动端Video标签踩坑记录/ios-blank-video.png","slug":"ios-blank-video.png","post":"cjzawewp5000xi0h6g3gvbt6y","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-27-JVM-Run-Time-Data-Area/JVM-Run-time-Data-Areas.png","slug":"JVM-Run-time-Data-Areas.png","post":"cjzawewov000mi0h61xmo230e","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-27-JVM-Run-Time-Data-Area/heap.gif","slug":"heap.gif","post":"cjzawewov000mi0h61xmo230e","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjzawewo40007i0h6qbru1mjs","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewoh000di0h6upuy616h"},{"post_id":"cjzawewnp0002i0h6i44q1iow","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewoo000hi0h6lq6uj89y"},{"post_id":"cjzawewob000bi0h6y6tztua4","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewot000ji0h6p9jry7gy"},{"post_id":"cjzawewnw0003i0h6zyonbxip","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewow000ni0h61orvq6ra"},{"post_id":"cjzawewod000ci0h6m8oed4xo","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewp0000qi0h6a9stkcb2"},{"post_id":"cjzawewol000gi0h66oa7wwzk","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewp4000vi0h6qth3xcno"},{"post_id":"cjzawewo20006i0h6uzmxgtqn","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewp6000yi0h6k5euzmhl"},{"post_id":"cjzawewoq000ii0h6m0k5eorq","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewp80011i0h65rahoxu2"},{"post_id":"cjzawewoy000pi0h6k8qs9vjx","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewpc0017i0h6bkrqnt9e"},{"post_id":"cjzawewp2000ui0h6pptjgen4","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewpe001ai0h64u1wxcn4"},{"post_id":"cjzawewov000mi0h61xmo230e","category_id":"cjzawewp2000ti0h6rbjlex58","_id":"cjzawewpg001di0h60wa61gin"},{"post_id":"cjzawewp70010i0h63hm9no7v","category_id":"cjzawewny0004i0h69j43bbou","_id":"cjzawewph001fi0h6hy95mi1m"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","category_id":"cjzawewp90012i0h6ut7raul5","_id":"cjzawewpj001ii0h6h7udlsza"},{"post_id":"cjzawewp90013i0h6kzpk4rm6","category_id":"cjzawewpd0019i0h6s8sbmuoy","_id":"cjzawewpj001ji0h620n98b3o"},{"post_id":"cjzawewpb0016i0h65blxx20s","category_id":"cjzawewph001gi0h6bb8w0th2","_id":"cjzawewpl001ni0h6y66qsxls"},{"post_id":"cjzawewo60008i0h60sxaqyqf","category_id":"cjzawjnsg00003ch6jy1ehf9s","_id":"cjzawjnss00013ch62ioy4whz"}],"PostTag":[{"post_id":"cjzawewnp0002i0h6i44q1iow","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewox000oi0h6qrs3702a"},{"post_id":"cjzawewnp0002i0h6i44q1iow","tag_id":"cjzawewo8000ai0h6ilfimmx3","_id":"cjzawewp1000ri0h66uqi4cw5"},{"post_id":"cjzawewnp0002i0h6i44q1iow","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewp4000wi0h69xh4o0bz"},{"post_id":"cjzawewnw0003i0h6zyonbxip","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpd0018i0h63ol8oamm"},{"post_id":"cjzawewnw0003i0h6zyonbxip","tag_id":"cjzawewo8000ai0h6ilfimmx3","_id":"cjzawewpf001bi0h6tjzga7ir"},{"post_id":"cjzawewnw0003i0h6zyonbxip","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewph001ei0h6ebfsgt1h"},{"post_id":"cjzawewo20006i0h6uzmxgtqn","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpl001li0h69arvqmy4"},{"post_id":"cjzawewo20006i0h6uzmxgtqn","tag_id":"cjzawewo8000ai0h6ilfimmx3","_id":"cjzawewpl001mi0h623tk2v8u"},{"post_id":"cjzawewo20006i0h6uzmxgtqn","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewpm001pi0h6ch8nnpio"},{"post_id":"cjzawewo40007i0h6qbru1mjs","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpn001ri0h6pdx3yfhh"},{"post_id":"cjzawewo40007i0h6qbru1mjs","tag_id":"cjzawewo8000ai0h6ilfimmx3","_id":"cjzawewpn001si0h6su9n6hy5"},{"post_id":"cjzawewo40007i0h6qbru1mjs","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewpo001ui0h6tjcthrfb"},{"post_id":"cjzawewo60008i0h60sxaqyqf","tag_id":"cjzawewpn001qi0h6agwwkxjc","_id":"cjzawewpq001xi0h6pt855x8c"},{"post_id":"cjzawewo60008i0h60sxaqyqf","tag_id":"cjzawewpo001ti0h66c25jiqu","_id":"cjzawewpq001yi0h60z25rxtb"},{"post_id":"cjzawewo60008i0h60sxaqyqf","tag_id":"cjzawewpo001vi0h6xo8j92dd","_id":"cjzawewpr0020i0h6zc97c5b4"},{"post_id":"cjzawewob000bi0h6y6tztua4","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpr0021i0h6e3x082eu"},{"post_id":"cjzawewob000bi0h6y6tztua4","tag_id":"cjzawewo8000ai0h6ilfimmx3","_id":"cjzawewps0023i0h6k5832utd"},{"post_id":"cjzawewob000bi0h6y6tztua4","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewps0024i0h69irpsq7w"},{"post_id":"cjzawewod000ci0h6m8oed4xo","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpt0026i0h6ihcyw05e"},{"post_id":"cjzawewod000ci0h6m8oed4xo","tag_id":"cjzawewpq001zi0h69mweghzu","_id":"cjzawewpu0027i0h60hwc0zxf"},{"post_id":"cjzawewod000ci0h6m8oed4xo","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewpv0029i0h6x45jda7d"},{"post_id":"cjzawewol000gi0h66oa7wwzk","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpv002ai0h6fak0ajg3"},{"post_id":"cjzawewol000gi0h66oa7wwzk","tag_id":"cjzawewpq001zi0h69mweghzu","_id":"cjzawewpw002ci0h6l3flx2rh"},{"post_id":"cjzawewol000gi0h66oa7wwzk","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewpx002di0h6f9a08mvi"},{"post_id":"cjzawewoq000ii0h6m0k5eorq","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewpy002fi0h6c7d5tirr"},{"post_id":"cjzawewoq000ii0h6m0k5eorq","tag_id":"cjzawewpu0028i0h6rye1jbqo","_id":"cjzawewpy002gi0h6f2rk60mx"},{"post_id":"cjzawewoq000ii0h6m0k5eorq","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewpz002ii0h63f3gf2gh"},{"post_id":"cjzawewov000mi0h61xmo230e","tag_id":"cjzawewpn001qi0h6agwwkxjc","_id":"cjzawewq0002ki0h683ygr3qd"},{"post_id":"cjzawewov000mi0h61xmo230e","tag_id":"cjzawewpx002ei0h6hifjbqaf","_id":"cjzawewq0002li0h6b1323o5g"},{"post_id":"cjzawewov000mi0h61xmo230e","tag_id":"cjzawewpy002hi0h6rq5zqadw","_id":"cjzawewq1002ni0h6styib4a5"},{"post_id":"cjzawewoy000pi0h6k8qs9vjx","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewq1002oi0h6fh6pi0wl"},{"post_id":"cjzawewoy000pi0h6k8qs9vjx","tag_id":"cjzawewpu0028i0h6rye1jbqo","_id":"cjzawewq2002qi0h6oak0ybb2"},{"post_id":"cjzawewoy000pi0h6k8qs9vjx","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewq2002ri0h64jqvkibc"},{"post_id":"cjzawewp2000ui0h6pptjgen4","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewq3002ti0h6s9imc2m8"},{"post_id":"cjzawewp2000ui0h6pptjgen4","tag_id":"cjzawewq0002mi0h6wyty0z92","_id":"cjzawewq3002ui0h6a6lsfqge"},{"post_id":"cjzawewp2000ui0h6pptjgen4","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewq4002wi0h6ozs843zm"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq2002pi0h6wjl9v9tm","_id":"cjzawewq70033i0h6cz5i9f4j"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq3002si0h6glp16prd","_id":"cjzawewq70034i0h6gb5ccxyx"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq4002vi0h6ek31el7x","_id":"cjzawewq80036i0h647csd41g"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq4002xi0h6n51fj8xr","_id":"cjzawewq90037i0h6b8s7o7f7"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq5002yi0h6rpv4efjm","_id":"cjzawewqa0039i0h6p6m0gvb1"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq5002zi0h69zo3vf95","_id":"cjzawewqa003ai0h6l5k1kgtf"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq60030i0h6iabx00i7","_id":"cjzawewqb003ci0h6f8pykleq"},{"post_id":"cjzawewp5000xi0h6g3gvbt6y","tag_id":"cjzawewq60031i0h6pu8kmdhv","_id":"cjzawewqb003di0h6fi8wjwm1"},{"post_id":"cjzawewp70010i0h63hm9no7v","tag_id":"cjzawewo10005i0h6bm36vvq0","_id":"cjzawewqc003ei0h6faaozcyl"},{"post_id":"cjzawewp70010i0h63hm9no7v","tag_id":"cjzawewq60032i0h6b61vogdl","_id":"cjzawewqc003fi0h612c78c4d"},{"post_id":"cjzawewp70010i0h63hm9no7v","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewqc003gi0h68cwzi0ss"},{"post_id":"cjzawewp90013i0h6kzpk4rm6","tag_id":"cjzawewq80035i0h6rgmd84rm","_id":"cjzawewqd003hi0h61ueng43n"},{"post_id":"cjzawewp90013i0h6kzpk4rm6","tag_id":"cjzawewq90038i0h6rbssf9s6","_id":"cjzawewqd003ii0h6tmvidps7"},{"post_id":"cjzawewp90013i0h6kzpk4rm6","tag_id":"cjzawewol000fi0h6n2qb23nt","_id":"cjzawewqd003ji0h6q2vwkw2p"},{"post_id":"cjzawewpb0016i0h65blxx20s","tag_id":"cjzawewqa003bi0h6hf3bkbrl","_id":"cjzawewqe003ki0h6r27nmc5h"}],"Tag":[{"name":"LeetCode","_id":"cjzawewo10005i0h6bm36vvq0"},{"name":"BST","_id":"cjzawewo8000ai0h6ilfimmx3"},{"name":"algorithm","_id":"cjzawewol000fi0h6n2qb23nt"},{"name":"Java","_id":"cjzawewpn001qi0h6agwwkxjc"},{"name":"Thread","_id":"cjzawewpo001ti0h66c25jiqu"},{"name":"基础","_id":"cjzawewpo001vi0h6xo8j92dd"},{"name":"Heap","_id":"cjzawewpq001zi0h69mweghzu"},{"name":"HashTable","_id":"cjzawewpu0028i0h6rye1jbqo"},{"name":"JVM","_id":"cjzawewpx002ei0h6hifjbqaf"},{"name":"Data Area","_id":"cjzawewpy002hi0h6rq5zqadw"},{"name":"Stack","_id":"cjzawewq0002mi0h6wyty0z92"},{"name":"html","_id":"cjzawewq2002pi0h6wjl9v9tm"},{"name":"js","_id":"cjzawewq3002si0h6glp16prd"},{"name":"video","_id":"cjzawewq4002vi0h6ek31el7x"},{"name":"canvas","_id":"cjzawewq4002xi0h6n51fj8xr"},{"name":"ios","_id":"cjzawewq5002yi0h6rpv4efjm"},{"name":"Android","_id":"cjzawewq5002zi0h69zo3vf95"},{"name":"mobile","_id":"cjzawewq60030i0h6iabx00i7"},{"name":"前端","_id":"cjzawewq60031i0h6pu8kmdhv"},{"name":"Sort","_id":"cjzawewq60032i0h6b61vogdl"},{"name":"递归","_id":"cjzawewq80035i0h6rgmd84rm"},{"name":"CodingBat","_id":"cjzawewq90038i0h6rbssf9s6"},{"name":"面试","_id":"cjzawewqa003bi0h6hf3bkbrl"}]}}